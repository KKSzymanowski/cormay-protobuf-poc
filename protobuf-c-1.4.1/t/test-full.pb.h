// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: t/test-full.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_t_2ftest_2dfull_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_t_2ftest_2dfull_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "protobuf-c/protobuf-c.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_t_2ftest_2dfull_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_t_2ftest_2dfull_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_t_2ftest_2dfull_2eproto;
namespace foo {
class AllocValues;
struct AllocValuesDefaultTypeInternal;
extern AllocValuesDefaultTypeInternal _AllocValues_default_instance_;
class DefaultOptionalValues;
struct DefaultOptionalValuesDefaultTypeInternal;
extern DefaultOptionalValuesDefaultTypeInternal _DefaultOptionalValues_default_instance_;
class DefaultRequiredValues;
struct DefaultRequiredValuesDefaultTypeInternal;
extern DefaultRequiredValuesDefaultTypeInternal _DefaultRequiredValues_default_instance_;
class EmptyMess;
struct EmptyMessDefaultTypeInternal;
extern EmptyMessDefaultTypeInternal _EmptyMess_default_instance_;
class LowerCase;
struct LowerCaseDefaultTypeInternal;
extern LowerCaseDefaultTypeInternal _LowerCase_default_instance_;
class SubMess;
struct SubMessDefaultTypeInternal;
extern SubMessDefaultTypeInternal _SubMess_default_instance_;
class SubMess_SubSubMess;
struct SubMess_SubSubMessDefaultTypeInternal;
extern SubMess_SubSubMessDefaultTypeInternal _SubMess_SubSubMess_default_instance_;
class TestFieldFlags;
struct TestFieldFlagsDefaultTypeInternal;
extern TestFieldFlagsDefaultTypeInternal _TestFieldFlags_default_instance_;
class TestFieldNo15;
struct TestFieldNo15DefaultTypeInternal;
extern TestFieldNo15DefaultTypeInternal _TestFieldNo15_default_instance_;
class TestFieldNo16;
struct TestFieldNo16DefaultTypeInternal;
extern TestFieldNo16DefaultTypeInternal _TestFieldNo16_default_instance_;
class TestFieldNo2047;
struct TestFieldNo2047DefaultTypeInternal;
extern TestFieldNo2047DefaultTypeInternal _TestFieldNo2047_default_instance_;
class TestFieldNo2048;
struct TestFieldNo2048DefaultTypeInternal;
extern TestFieldNo2048DefaultTypeInternal _TestFieldNo2048_default_instance_;
class TestFieldNo262143;
struct TestFieldNo262143DefaultTypeInternal;
extern TestFieldNo262143DefaultTypeInternal _TestFieldNo262143_default_instance_;
class TestFieldNo262144;
struct TestFieldNo262144DefaultTypeInternal;
extern TestFieldNo262144DefaultTypeInternal _TestFieldNo262144_default_instance_;
class TestFieldNo33554431;
struct TestFieldNo33554431DefaultTypeInternal;
extern TestFieldNo33554431DefaultTypeInternal _TestFieldNo33554431_default_instance_;
class TestFieldNo33554432;
struct TestFieldNo33554432DefaultTypeInternal;
extern TestFieldNo33554432DefaultTypeInternal _TestFieldNo33554432_default_instance_;
class TestMess;
struct TestMessDefaultTypeInternal;
extern TestMessDefaultTypeInternal _TestMess_default_instance_;
class TestMessOneof;
struct TestMessOneofDefaultTypeInternal;
extern TestMessOneofDefaultTypeInternal _TestMessOneof_default_instance_;
class TestMessOptional;
struct TestMessOptionalDefaultTypeInternal;
extern TestMessOptionalDefaultTypeInternal _TestMessOptional_default_instance_;
class TestMessPacked;
struct TestMessPackedDefaultTypeInternal;
extern TestMessPackedDefaultTypeInternal _TestMessPacked_default_instance_;
class TestMessRequiredBool;
struct TestMessRequiredBoolDefaultTypeInternal;
extern TestMessRequiredBoolDefaultTypeInternal _TestMessRequiredBool_default_instance_;
class TestMessRequiredBytes;
struct TestMessRequiredBytesDefaultTypeInternal;
extern TestMessRequiredBytesDefaultTypeInternal _TestMessRequiredBytes_default_instance_;
class TestMessRequiredDouble;
struct TestMessRequiredDoubleDefaultTypeInternal;
extern TestMessRequiredDoubleDefaultTypeInternal _TestMessRequiredDouble_default_instance_;
class TestMessRequiredEnum;
struct TestMessRequiredEnumDefaultTypeInternal;
extern TestMessRequiredEnumDefaultTypeInternal _TestMessRequiredEnum_default_instance_;
class TestMessRequiredEnumSmall;
struct TestMessRequiredEnumSmallDefaultTypeInternal;
extern TestMessRequiredEnumSmallDefaultTypeInternal _TestMessRequiredEnumSmall_default_instance_;
class TestMessRequiredFixed32;
struct TestMessRequiredFixed32DefaultTypeInternal;
extern TestMessRequiredFixed32DefaultTypeInternal _TestMessRequiredFixed32_default_instance_;
class TestMessRequiredFixed64;
struct TestMessRequiredFixed64DefaultTypeInternal;
extern TestMessRequiredFixed64DefaultTypeInternal _TestMessRequiredFixed64_default_instance_;
class TestMessRequiredFloat;
struct TestMessRequiredFloatDefaultTypeInternal;
extern TestMessRequiredFloatDefaultTypeInternal _TestMessRequiredFloat_default_instance_;
class TestMessRequiredInt32;
struct TestMessRequiredInt32DefaultTypeInternal;
extern TestMessRequiredInt32DefaultTypeInternal _TestMessRequiredInt32_default_instance_;
class TestMessRequiredInt64;
struct TestMessRequiredInt64DefaultTypeInternal;
extern TestMessRequiredInt64DefaultTypeInternal _TestMessRequiredInt64_default_instance_;
class TestMessRequiredMessage;
struct TestMessRequiredMessageDefaultTypeInternal;
extern TestMessRequiredMessageDefaultTypeInternal _TestMessRequiredMessage_default_instance_;
class TestMessRequiredSFixed32;
struct TestMessRequiredSFixed32DefaultTypeInternal;
extern TestMessRequiredSFixed32DefaultTypeInternal _TestMessRequiredSFixed32_default_instance_;
class TestMessRequiredSFixed64;
struct TestMessRequiredSFixed64DefaultTypeInternal;
extern TestMessRequiredSFixed64DefaultTypeInternal _TestMessRequiredSFixed64_default_instance_;
class TestMessRequiredSInt32;
struct TestMessRequiredSInt32DefaultTypeInternal;
extern TestMessRequiredSInt32DefaultTypeInternal _TestMessRequiredSInt32_default_instance_;
class TestMessRequiredSInt64;
struct TestMessRequiredSInt64DefaultTypeInternal;
extern TestMessRequiredSInt64DefaultTypeInternal _TestMessRequiredSInt64_default_instance_;
class TestMessRequiredString;
struct TestMessRequiredStringDefaultTypeInternal;
extern TestMessRequiredStringDefaultTypeInternal _TestMessRequiredString_default_instance_;
class TestMessRequiredUInt32;
struct TestMessRequiredUInt32DefaultTypeInternal;
extern TestMessRequiredUInt32DefaultTypeInternal _TestMessRequiredUInt32_default_instance_;
class TestMessRequiredUInt64;
struct TestMessRequiredUInt64DefaultTypeInternal;
extern TestMessRequiredUInt64DefaultTypeInternal _TestMessRequiredUInt64_default_instance_;
class TestMessSubMess;
struct TestMessSubMessDefaultTypeInternal;
extern TestMessSubMessDefaultTypeInternal _TestMessSubMess_default_instance_;
class TestMessageCheck;
struct TestMessageCheckDefaultTypeInternal;
extern TestMessageCheckDefaultTypeInternal _TestMessageCheck_default_instance_;
class TestMessageCheck_SubMessage;
struct TestMessageCheck_SubMessageDefaultTypeInternal;
extern TestMessageCheck_SubMessageDefaultTypeInternal _TestMessageCheck_SubMessage_default_instance_;
class TestRequiredFieldsBitmap;
struct TestRequiredFieldsBitmapDefaultTypeInternal;
extern TestRequiredFieldsBitmapDefaultTypeInternal _TestRequiredFieldsBitmap_default_instance_;
}  // namespace foo
PROTOBUF_NAMESPACE_OPEN
template<> ::foo::AllocValues* Arena::CreateMaybeMessage<::foo::AllocValues>(Arena*);
template<> ::foo::DefaultOptionalValues* Arena::CreateMaybeMessage<::foo::DefaultOptionalValues>(Arena*);
template<> ::foo::DefaultRequiredValues* Arena::CreateMaybeMessage<::foo::DefaultRequiredValues>(Arena*);
template<> ::foo::EmptyMess* Arena::CreateMaybeMessage<::foo::EmptyMess>(Arena*);
template<> ::foo::LowerCase* Arena::CreateMaybeMessage<::foo::LowerCase>(Arena*);
template<> ::foo::SubMess* Arena::CreateMaybeMessage<::foo::SubMess>(Arena*);
template<> ::foo::SubMess_SubSubMess* Arena::CreateMaybeMessage<::foo::SubMess_SubSubMess>(Arena*);
template<> ::foo::TestFieldFlags* Arena::CreateMaybeMessage<::foo::TestFieldFlags>(Arena*);
template<> ::foo::TestFieldNo15* Arena::CreateMaybeMessage<::foo::TestFieldNo15>(Arena*);
template<> ::foo::TestFieldNo16* Arena::CreateMaybeMessage<::foo::TestFieldNo16>(Arena*);
template<> ::foo::TestFieldNo2047* Arena::CreateMaybeMessage<::foo::TestFieldNo2047>(Arena*);
template<> ::foo::TestFieldNo2048* Arena::CreateMaybeMessage<::foo::TestFieldNo2048>(Arena*);
template<> ::foo::TestFieldNo262143* Arena::CreateMaybeMessage<::foo::TestFieldNo262143>(Arena*);
template<> ::foo::TestFieldNo262144* Arena::CreateMaybeMessage<::foo::TestFieldNo262144>(Arena*);
template<> ::foo::TestFieldNo33554431* Arena::CreateMaybeMessage<::foo::TestFieldNo33554431>(Arena*);
template<> ::foo::TestFieldNo33554432* Arena::CreateMaybeMessage<::foo::TestFieldNo33554432>(Arena*);
template<> ::foo::TestMess* Arena::CreateMaybeMessage<::foo::TestMess>(Arena*);
template<> ::foo::TestMessOneof* Arena::CreateMaybeMessage<::foo::TestMessOneof>(Arena*);
template<> ::foo::TestMessOptional* Arena::CreateMaybeMessage<::foo::TestMessOptional>(Arena*);
template<> ::foo::TestMessPacked* Arena::CreateMaybeMessage<::foo::TestMessPacked>(Arena*);
template<> ::foo::TestMessRequiredBool* Arena::CreateMaybeMessage<::foo::TestMessRequiredBool>(Arena*);
template<> ::foo::TestMessRequiredBytes* Arena::CreateMaybeMessage<::foo::TestMessRequiredBytes>(Arena*);
template<> ::foo::TestMessRequiredDouble* Arena::CreateMaybeMessage<::foo::TestMessRequiredDouble>(Arena*);
template<> ::foo::TestMessRequiredEnum* Arena::CreateMaybeMessage<::foo::TestMessRequiredEnum>(Arena*);
template<> ::foo::TestMessRequiredEnumSmall* Arena::CreateMaybeMessage<::foo::TestMessRequiredEnumSmall>(Arena*);
template<> ::foo::TestMessRequiredFixed32* Arena::CreateMaybeMessage<::foo::TestMessRequiredFixed32>(Arena*);
template<> ::foo::TestMessRequiredFixed64* Arena::CreateMaybeMessage<::foo::TestMessRequiredFixed64>(Arena*);
template<> ::foo::TestMessRequiredFloat* Arena::CreateMaybeMessage<::foo::TestMessRequiredFloat>(Arena*);
template<> ::foo::TestMessRequiredInt32* Arena::CreateMaybeMessage<::foo::TestMessRequiredInt32>(Arena*);
template<> ::foo::TestMessRequiredInt64* Arena::CreateMaybeMessage<::foo::TestMessRequiredInt64>(Arena*);
template<> ::foo::TestMessRequiredMessage* Arena::CreateMaybeMessage<::foo::TestMessRequiredMessage>(Arena*);
template<> ::foo::TestMessRequiredSFixed32* Arena::CreateMaybeMessage<::foo::TestMessRequiredSFixed32>(Arena*);
template<> ::foo::TestMessRequiredSFixed64* Arena::CreateMaybeMessage<::foo::TestMessRequiredSFixed64>(Arena*);
template<> ::foo::TestMessRequiredSInt32* Arena::CreateMaybeMessage<::foo::TestMessRequiredSInt32>(Arena*);
template<> ::foo::TestMessRequiredSInt64* Arena::CreateMaybeMessage<::foo::TestMessRequiredSInt64>(Arena*);
template<> ::foo::TestMessRequiredString* Arena::CreateMaybeMessage<::foo::TestMessRequiredString>(Arena*);
template<> ::foo::TestMessRequiredUInt32* Arena::CreateMaybeMessage<::foo::TestMessRequiredUInt32>(Arena*);
template<> ::foo::TestMessRequiredUInt64* Arena::CreateMaybeMessage<::foo::TestMessRequiredUInt64>(Arena*);
template<> ::foo::TestMessSubMess* Arena::CreateMaybeMessage<::foo::TestMessSubMess>(Arena*);
template<> ::foo::TestMessageCheck* Arena::CreateMaybeMessage<::foo::TestMessageCheck>(Arena*);
template<> ::foo::TestMessageCheck_SubMessage* Arena::CreateMaybeMessage<::foo::TestMessageCheck_SubMessage>(Arena*);
template<> ::foo::TestRequiredFieldsBitmap* Arena::CreateMaybeMessage<::foo::TestRequiredFieldsBitmap>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace foo {

enum LowerCase_CaseEnum : int {
  LowerCase_CaseEnum_UPPER = 1,
  LowerCase_CaseEnum_lower = 2
};
bool LowerCase_CaseEnum_IsValid(int value);
constexpr LowerCase_CaseEnum LowerCase_CaseEnum_CaseEnum_MIN = LowerCase_CaseEnum_UPPER;
constexpr LowerCase_CaseEnum LowerCase_CaseEnum_CaseEnum_MAX = LowerCase_CaseEnum_lower;
constexpr int LowerCase_CaseEnum_CaseEnum_ARRAYSIZE = LowerCase_CaseEnum_CaseEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LowerCase_CaseEnum_descriptor();
template<typename T>
inline const std::string& LowerCase_CaseEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LowerCase_CaseEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LowerCase_CaseEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LowerCase_CaseEnum_descriptor(), enum_t_value);
}
inline bool LowerCase_CaseEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LowerCase_CaseEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LowerCase_CaseEnum>(
    LowerCase_CaseEnum_descriptor(), name, value);
}
enum TestEnumSmall : int {
  NEG_VALUE = -1,
  VALUE = 0,
  OTHER_VALUE = 1
};
bool TestEnumSmall_IsValid(int value);
constexpr TestEnumSmall TestEnumSmall_MIN = NEG_VALUE;
constexpr TestEnumSmall TestEnumSmall_MAX = OTHER_VALUE;
constexpr int TestEnumSmall_ARRAYSIZE = TestEnumSmall_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestEnumSmall_descriptor();
template<typename T>
inline const std::string& TestEnumSmall_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestEnumSmall>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestEnumSmall_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestEnumSmall_descriptor(), enum_t_value);
}
inline bool TestEnumSmall_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TestEnumSmall* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestEnumSmall>(
    TestEnumSmall_descriptor(), name, value);
}
enum TestEnum : int {
  VALUENEG123456 = -123456,
  VALUENEG1 = -1,
  VALUE0 = 0,
  VALUE1 = 1,
  VALUE127 = 127,
  VALUE128 = 128,
  VALUE16383 = 16383,
  VALUE16384 = 16384,
  VALUE2097151 = 2097151,
  VALUE2097152 = 2097152,
  VALUE268435455 = 268435455,
  VALUE268435456 = 268435456
};
bool TestEnum_IsValid(int value);
constexpr TestEnum TestEnum_MIN = VALUENEG123456;
constexpr TestEnum TestEnum_MAX = VALUE268435456;
constexpr int TestEnum_ARRAYSIZE = TestEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestEnum_descriptor();
template<typename T>
inline const std::string& TestEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestEnum_descriptor(), enum_t_value);
}
inline bool TestEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TestEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestEnum>(
    TestEnum_descriptor(), name, value);
}
enum TestEnumDupValues : int {
  VALUE_A = 42,
  VALUE_B = 42,
  VALUE_C = 42,
  VALUE_D = 666,
  VALUE_E = 666,
  VALUE_F = 1000,
  VALUE_AA = 1000,
  VALUE_BB = 1001
};
bool TestEnumDupValues_IsValid(int value);
constexpr TestEnumDupValues TestEnumDupValues_MIN = VALUE_A;
constexpr TestEnumDupValues TestEnumDupValues_MAX = VALUE_BB;
constexpr int TestEnumDupValues_ARRAYSIZE = TestEnumDupValues_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TestEnumDupValues_descriptor();
template<typename T>
inline const std::string& TestEnumDupValues_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TestEnumDupValues>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TestEnumDupValues_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TestEnumDupValues_descriptor(), enum_t_value);
}
inline bool TestEnumDupValues_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TestEnumDupValues* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TestEnumDupValues>(
    TestEnumDupValues_descriptor(), name, value);
}
// ===================================================================

class SubMess_SubSubMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.SubMess.SubSubMess) */ {
 public:
  inline SubMess_SubSubMess() : SubMess_SubSubMess(nullptr) {}
  ~SubMess_SubSubMess() override;
  explicit PROTOBUF_CONSTEXPR SubMess_SubSubMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubMess_SubSubMess(const SubMess_SubSubMess& from);
  SubMess_SubSubMess(SubMess_SubSubMess&& from) noexcept
    : SubMess_SubSubMess() {
    *this = ::std::move(from);
  }

  inline SubMess_SubSubMess& operator=(const SubMess_SubSubMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubMess_SubSubMess& operator=(SubMess_SubSubMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubMess_SubSubMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubMess_SubSubMess* internal_default_instance() {
    return reinterpret_cast<const SubMess_SubSubMess*>(
               &_SubMess_SubSubMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubMess_SubSubMess& a, SubMess_SubSubMess& b) {
    a.Swap(&b);
  }
  inline void Swap(SubMess_SubSubMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubMess_SubSubMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubMess_SubSubMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubMess_SubSubMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubMess_SubSubMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubMess_SubSubMess& from) {
    SubMess_SubSubMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubMess_SubSubMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.SubMess.SubSubMess";
  }
  protected:
  explicit SubMess_SubSubMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepFieldNumber = 4,
    kBytes1FieldNumber = 2,
    kStr1FieldNumber = 3,
    kStr2FieldNumber = 5,
    kVal1FieldNumber = 1,
  };
  // repeated int32 rep = 4;
  int rep_size() const;
  private:
  int _internal_rep_size() const;
  public:
  void clear_rep();
  private:
  int32_t _internal_rep(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_rep() const;
  void _internal_add_rep(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_rep();
  public:
  int32_t rep(int index) const;
  void set_rep(int index, int32_t value);
  void add_rep(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      rep() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_rep();

  // optional bytes bytes1 = 2 [default = "a \000 char"];
  bool has_bytes1() const;
  private:
  bool _internal_has_bytes1() const;
  public:
  void clear_bytes1();
  const std::string& bytes1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes1();
  PROTOBUF_NODISCARD std::string* release_bytes1();
  void set_allocated_bytes1(std::string* bytes1);
  private:
  const std::string& _internal_bytes1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes1(const std::string& value);
  std::string* _internal_mutable_bytes1();
  public:

  // optional string str1 = 3 [default = "hello world\n"];
  bool has_str1() const;
  private:
  bool _internal_has_str1() const;
  public:
  void clear_str1();
  const std::string& str1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str1();
  PROTOBUF_NODISCARD std::string* release_str1();
  void set_allocated_str1(std::string* str1);
  private:
  const std::string& _internal_str1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str1(const std::string& value);
  std::string* _internal_mutable_str1();
  public:

  // optional string str2 = 5 [default = "hello\000world\n", (.pb_c_field) = {
  bool has_str2() const;
  private:
  bool _internal_has_str2() const;
  public:
  void clear_str2();
  const std::string& str2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str2();
  PROTOBUF_NODISCARD std::string* release_str2();
  void set_allocated_str2(std::string* str2);
  private:
  const std::string& _internal_str2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str2(const std::string& value);
  std::string* _internal_mutable_str2();
  public:

  // optional int32 val1 = 1 [default = 100];
  bool has_val1() const;
  private:
  bool _internal_has_val1() const;
  public:
  void clear_val1();
  int32_t val1() const;
  void set_val1(int32_t value);
  private:
  int32_t _internal_val1() const;
  void _internal_set_val1(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.SubMess.SubSubMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > rep_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_bytes1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes1_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_str1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str1_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_str2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str2_;
    int32_t val1_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class SubMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.SubMess) */ {
 public:
  inline SubMess() : SubMess(nullptr) {}
  ~SubMess() override;
  explicit PROTOBUF_CONSTEXPR SubMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubMess(const SubMess& from);
  SubMess(SubMess&& from) noexcept
    : SubMess() {
    *this = ::std::move(from);
  }

  inline SubMess& operator=(const SubMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubMess& operator=(SubMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubMess* internal_default_instance() {
    return reinterpret_cast<const SubMess*>(
               &_SubMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubMess& a, SubMess& b) {
    a.Swap(&b);
  }
  inline void Swap(SubMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubMess& from) {
    SubMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.SubMess";
  }
  protected:
  explicit SubMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubMess_SubSubMess SubSubMess;

  // accessors -------------------------------------------------------

  enum : int {
    kRepFieldNumber = 8,
    kSub1FieldNumber = 9,
    kSub2FieldNumber = 10,
    kTestFieldNumber = 4,
    kVal1FieldNumber = 6,
    kVal2FieldNumber = 7,
  };
  // repeated int32 rep = 8;
  int rep_size() const;
  private:
  int _internal_rep_size() const;
  public:
  void clear_rep();
  private:
  int32_t _internal_rep(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_rep() const;
  void _internal_add_rep(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_rep();
  public:
  int32_t rep(int index) const;
  void set_rep(int index, int32_t value);
  void add_rep(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      rep() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_rep();

  // optional .foo.SubMess.SubSubMess sub1 = 9;
  bool has_sub1() const;
  private:
  bool _internal_has_sub1() const;
  public:
  void clear_sub1();
  const ::foo::SubMess_SubSubMess& sub1() const;
  PROTOBUF_NODISCARD ::foo::SubMess_SubSubMess* release_sub1();
  ::foo::SubMess_SubSubMess* mutable_sub1();
  void set_allocated_sub1(::foo::SubMess_SubSubMess* sub1);
  private:
  const ::foo::SubMess_SubSubMess& _internal_sub1() const;
  ::foo::SubMess_SubSubMess* _internal_mutable_sub1();
  public:
  void unsafe_arena_set_allocated_sub1(
      ::foo::SubMess_SubSubMess* sub1);
  ::foo::SubMess_SubSubMess* unsafe_arena_release_sub1();

  // optional .foo.SubMess.SubSubMess sub2 = 10;
  bool has_sub2() const;
  private:
  bool _internal_has_sub2() const;
  public:
  void clear_sub2();
  const ::foo::SubMess_SubSubMess& sub2() const;
  PROTOBUF_NODISCARD ::foo::SubMess_SubSubMess* release_sub2();
  ::foo::SubMess_SubSubMess* mutable_sub2();
  void set_allocated_sub2(::foo::SubMess_SubSubMess* sub2);
  private:
  const ::foo::SubMess_SubSubMess& _internal_sub2() const;
  ::foo::SubMess_SubSubMess* _internal_mutable_sub2();
  public:
  void unsafe_arena_set_allocated_sub2(
      ::foo::SubMess_SubSubMess* sub2);
  ::foo::SubMess_SubSubMess* unsafe_arena_release_sub2();

  // required int32 test = 4;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int32_t test() const;
  void set_test(int32_t value);
  private:
  int32_t _internal_test() const;
  void _internal_set_test(int32_t value);
  public:

  // optional int32 val1 = 6;
  bool has_val1() const;
  private:
  bool _internal_has_val1() const;
  public:
  void clear_val1();
  int32_t val1() const;
  void set_val1(int32_t value);
  private:
  int32_t _internal_val1() const;
  void _internal_set_val1(int32_t value);
  public:

  // optional int32 val2 = 7;
  bool has_val2() const;
  private:
  bool _internal_has_val2() const;
  public:
  void clear_val2();
  int32_t val2() const;
  void set_val2(int32_t value);
  private:
  int32_t _internal_val2() const;
  void _internal_set_val2(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.SubMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > rep_;
    ::foo::SubMess_SubSubMess* sub1_;
    ::foo::SubMess_SubSubMess* sub2_;
    int32_t test_;
    int32_t val1_;
    int32_t val2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo15 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo15) */ {
 public:
  inline TestFieldNo15() : TestFieldNo15(nullptr) {}
  ~TestFieldNo15() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo15(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo15(const TestFieldNo15& from);
  TestFieldNo15(TestFieldNo15&& from) noexcept
    : TestFieldNo15() {
    *this = ::std::move(from);
  }

  inline TestFieldNo15& operator=(const TestFieldNo15& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo15& operator=(TestFieldNo15&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo15& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo15* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo15*>(
               &_TestFieldNo15_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TestFieldNo15& a, TestFieldNo15& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo15* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo15* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo15* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo15>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo15& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo15& from) {
    TestFieldNo15::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo15* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo15";
  }
  protected:
  explicit TestFieldNo15(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 15,
  };
  // required string test = 15;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo15)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo16 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo16) */ {
 public:
  inline TestFieldNo16() : TestFieldNo16(nullptr) {}
  ~TestFieldNo16() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo16(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo16(const TestFieldNo16& from);
  TestFieldNo16(TestFieldNo16&& from) noexcept
    : TestFieldNo16() {
    *this = ::std::move(from);
  }

  inline TestFieldNo16& operator=(const TestFieldNo16& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo16& operator=(TestFieldNo16&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo16& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo16* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo16*>(
               &_TestFieldNo16_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TestFieldNo16& a, TestFieldNo16& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo16* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo16* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo16* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo16>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo16& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo16& from) {
    TestFieldNo16::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo16* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo16";
  }
  protected:
  explicit TestFieldNo16(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 16,
  };
  // required string test = 16;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo16)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo2047 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo2047) */ {
 public:
  inline TestFieldNo2047() : TestFieldNo2047(nullptr) {}
  ~TestFieldNo2047() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo2047(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo2047(const TestFieldNo2047& from);
  TestFieldNo2047(TestFieldNo2047&& from) noexcept
    : TestFieldNo2047() {
    *this = ::std::move(from);
  }

  inline TestFieldNo2047& operator=(const TestFieldNo2047& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo2047& operator=(TestFieldNo2047&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo2047& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo2047* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo2047*>(
               &_TestFieldNo2047_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TestFieldNo2047& a, TestFieldNo2047& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo2047* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo2047* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo2047* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo2047>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo2047& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo2047& from) {
    TestFieldNo2047::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo2047* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo2047";
  }
  protected:
  explicit TestFieldNo2047(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 2047,
  };
  // required string test = 2047;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo2047)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo2048 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo2048) */ {
 public:
  inline TestFieldNo2048() : TestFieldNo2048(nullptr) {}
  ~TestFieldNo2048() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo2048(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo2048(const TestFieldNo2048& from);
  TestFieldNo2048(TestFieldNo2048&& from) noexcept
    : TestFieldNo2048() {
    *this = ::std::move(from);
  }

  inline TestFieldNo2048& operator=(const TestFieldNo2048& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo2048& operator=(TestFieldNo2048&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo2048& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo2048* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo2048*>(
               &_TestFieldNo2048_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TestFieldNo2048& a, TestFieldNo2048& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo2048* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo2048* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo2048* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo2048>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo2048& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo2048& from) {
    TestFieldNo2048::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo2048* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo2048";
  }
  protected:
  explicit TestFieldNo2048(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 2048,
  };
  // required string test = 2048;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo2048)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo262143 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo262143) */ {
 public:
  inline TestFieldNo262143() : TestFieldNo262143(nullptr) {}
  ~TestFieldNo262143() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo262143(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo262143(const TestFieldNo262143& from);
  TestFieldNo262143(TestFieldNo262143&& from) noexcept
    : TestFieldNo262143() {
    *this = ::std::move(from);
  }

  inline TestFieldNo262143& operator=(const TestFieldNo262143& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo262143& operator=(TestFieldNo262143&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo262143& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo262143* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo262143*>(
               &_TestFieldNo262143_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TestFieldNo262143& a, TestFieldNo262143& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo262143* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo262143* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo262143* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo262143>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo262143& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo262143& from) {
    TestFieldNo262143::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo262143* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo262143";
  }
  protected:
  explicit TestFieldNo262143(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 262143,
  };
  // required string test = 262143;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo262143)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo262144 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo262144) */ {
 public:
  inline TestFieldNo262144() : TestFieldNo262144(nullptr) {}
  ~TestFieldNo262144() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo262144(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo262144(const TestFieldNo262144& from);
  TestFieldNo262144(TestFieldNo262144&& from) noexcept
    : TestFieldNo262144() {
    *this = ::std::move(from);
  }

  inline TestFieldNo262144& operator=(const TestFieldNo262144& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo262144& operator=(TestFieldNo262144&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo262144& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo262144* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo262144*>(
               &_TestFieldNo262144_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TestFieldNo262144& a, TestFieldNo262144& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo262144* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo262144* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo262144* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo262144>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo262144& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo262144& from) {
    TestFieldNo262144::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo262144* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo262144";
  }
  protected:
  explicit TestFieldNo262144(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 262144,
  };
  // required string test = 262144;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo262144)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo33554431 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo33554431) */ {
 public:
  inline TestFieldNo33554431() : TestFieldNo33554431(nullptr) {}
  ~TestFieldNo33554431() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo33554431(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo33554431(const TestFieldNo33554431& from);
  TestFieldNo33554431(TestFieldNo33554431&& from) noexcept
    : TestFieldNo33554431() {
    *this = ::std::move(from);
  }

  inline TestFieldNo33554431& operator=(const TestFieldNo33554431& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo33554431& operator=(TestFieldNo33554431&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo33554431& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo33554431* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo33554431*>(
               &_TestFieldNo33554431_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TestFieldNo33554431& a, TestFieldNo33554431& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo33554431* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo33554431* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo33554431* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo33554431>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo33554431& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo33554431& from) {
    TestFieldNo33554431::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo33554431* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo33554431";
  }
  protected:
  explicit TestFieldNo33554431(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 33554431,
  };
  // required string test = 33554431;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo33554431)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldNo33554432 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldNo33554432) */ {
 public:
  inline TestFieldNo33554432() : TestFieldNo33554432(nullptr) {}
  ~TestFieldNo33554432() override;
  explicit PROTOBUF_CONSTEXPR TestFieldNo33554432(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldNo33554432(const TestFieldNo33554432& from);
  TestFieldNo33554432(TestFieldNo33554432&& from) noexcept
    : TestFieldNo33554432() {
    *this = ::std::move(from);
  }

  inline TestFieldNo33554432& operator=(const TestFieldNo33554432& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldNo33554432& operator=(TestFieldNo33554432&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldNo33554432& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldNo33554432* internal_default_instance() {
    return reinterpret_cast<const TestFieldNo33554432*>(
               &_TestFieldNo33554432_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TestFieldNo33554432& a, TestFieldNo33554432& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldNo33554432* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldNo33554432* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldNo33554432* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldNo33554432>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldNo33554432& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldNo33554432& from) {
    TestFieldNo33554432::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldNo33554432* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldNo33554432";
  }
  protected:
  explicit TestFieldNo33554432(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 33554432,
  };
  // required string test = 33554432;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldNo33554432)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMess) */ {
 public:
  inline TestMess() : TestMess(nullptr) {}
  ~TestMess() override;
  explicit PROTOBUF_CONSTEXPR TestMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMess(const TestMess& from);
  TestMess(TestMess&& from) noexcept
    : TestMess() {
    *this = ::std::move(from);
  }

  inline TestMess& operator=(const TestMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMess& operator=(TestMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMess* internal_default_instance() {
    return reinterpret_cast<const TestMess*>(
               &_TestMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TestMess& a, TestMess& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMess& from) {
    TestMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMess";
  }
  protected:
  explicit TestMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestInt32FieldNumber = 1,
    kTestSint32FieldNumber = 2,
    kTestSfixed32FieldNumber = 3,
    kTestInt64FieldNumber = 4,
    kTestSint64FieldNumber = 5,
    kTestSfixed64FieldNumber = 6,
    kTestUint32FieldNumber = 7,
    kTestFixed32FieldNumber = 8,
    kTestUint64FieldNumber = 9,
    kTestFixed64FieldNumber = 10,
    kTestFloatFieldNumber = 11,
    kTestDoubleFieldNumber = 12,
    kTestBooleanFieldNumber = 13,
    kTestEnumSmallFieldNumber = 14,
    kTestEnumFieldNumber = 15,
    kTestStringFieldNumber = 16,
    kTestBytesFieldNumber = 17,
    kTestMessageFieldNumber = 18,
  };
  // repeated int32 test_int32 = 1;
  int test_int32_size() const;
  private:
  int _internal_test_int32_size() const;
  public:
  void clear_test_int32();
  private:
  int32_t _internal_test_int32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_int32() const;
  void _internal_add_test_int32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_int32();
  public:
  int32_t test_int32(int index) const;
  void set_test_int32(int index, int32_t value);
  void add_test_int32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_int32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_int32();

  // repeated sint32 test_sint32 = 2;
  int test_sint32_size() const;
  private:
  int _internal_test_sint32_size() const;
  public:
  void clear_test_sint32();
  private:
  int32_t _internal_test_sint32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_sint32() const;
  void _internal_add_test_sint32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_sint32();
  public:
  int32_t test_sint32(int index) const;
  void set_test_sint32(int index, int32_t value);
  void add_test_sint32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_sint32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_sint32();

  // repeated sfixed32 test_sfixed32 = 3;
  int test_sfixed32_size() const;
  private:
  int _internal_test_sfixed32_size() const;
  public:
  void clear_test_sfixed32();
  private:
  int32_t _internal_test_sfixed32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_sfixed32() const;
  void _internal_add_test_sfixed32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_sfixed32();
  public:
  int32_t test_sfixed32(int index) const;
  void set_test_sfixed32(int index, int32_t value);
  void add_test_sfixed32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_sfixed32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_sfixed32();

  // repeated int64 test_int64 = 4;
  int test_int64_size() const;
  private:
  int _internal_test_int64_size() const;
  public:
  void clear_test_int64();
  private:
  int64_t _internal_test_int64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_int64() const;
  void _internal_add_test_int64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_int64();
  public:
  int64_t test_int64(int index) const;
  void set_test_int64(int index, int64_t value);
  void add_test_int64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_int64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_int64();

  // repeated sint64 test_sint64 = 5;
  int test_sint64_size() const;
  private:
  int _internal_test_sint64_size() const;
  public:
  void clear_test_sint64();
  private:
  int64_t _internal_test_sint64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_sint64() const;
  void _internal_add_test_sint64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_sint64();
  public:
  int64_t test_sint64(int index) const;
  void set_test_sint64(int index, int64_t value);
  void add_test_sint64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_sint64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_sint64();

  // repeated sfixed64 test_sfixed64 = 6;
  int test_sfixed64_size() const;
  private:
  int _internal_test_sfixed64_size() const;
  public:
  void clear_test_sfixed64();
  private:
  int64_t _internal_test_sfixed64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_sfixed64() const;
  void _internal_add_test_sfixed64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_sfixed64();
  public:
  int64_t test_sfixed64(int index) const;
  void set_test_sfixed64(int index, int64_t value);
  void add_test_sfixed64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_sfixed64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_sfixed64();

  // repeated uint32 test_uint32 = 7;
  int test_uint32_size() const;
  private:
  int _internal_test_uint32_size() const;
  public:
  void clear_test_uint32();
  private:
  uint32_t _internal_test_uint32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_test_uint32() const;
  void _internal_add_test_uint32(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_test_uint32();
  public:
  uint32_t test_uint32(int index) const;
  void set_test_uint32(int index, uint32_t value);
  void add_test_uint32(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      test_uint32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_test_uint32();

  // repeated fixed32 test_fixed32 = 8;
  int test_fixed32_size() const;
  private:
  int _internal_test_fixed32_size() const;
  public:
  void clear_test_fixed32();
  private:
  uint32_t _internal_test_fixed32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_test_fixed32() const;
  void _internal_add_test_fixed32(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_test_fixed32();
  public:
  uint32_t test_fixed32(int index) const;
  void set_test_fixed32(int index, uint32_t value);
  void add_test_fixed32(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      test_fixed32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_test_fixed32();

  // repeated uint64 test_uint64 = 9;
  int test_uint64_size() const;
  private:
  int _internal_test_uint64_size() const;
  public:
  void clear_test_uint64();
  private:
  uint64_t _internal_test_uint64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_test_uint64() const;
  void _internal_add_test_uint64(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_test_uint64();
  public:
  uint64_t test_uint64(int index) const;
  void set_test_uint64(int index, uint64_t value);
  void add_test_uint64(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      test_uint64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_test_uint64();

  // repeated fixed64 test_fixed64 = 10;
  int test_fixed64_size() const;
  private:
  int _internal_test_fixed64_size() const;
  public:
  void clear_test_fixed64();
  private:
  uint64_t _internal_test_fixed64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_test_fixed64() const;
  void _internal_add_test_fixed64(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_test_fixed64();
  public:
  uint64_t test_fixed64(int index) const;
  void set_test_fixed64(int index, uint64_t value);
  void add_test_fixed64(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      test_fixed64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_test_fixed64();

  // repeated float test_float = 11;
  int test_float_size() const;
  private:
  int _internal_test_float_size() const;
  public:
  void clear_test_float();
  private:
  float _internal_test_float(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_test_float() const;
  void _internal_add_test_float(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_test_float();
  public:
  float test_float(int index) const;
  void set_test_float(int index, float value);
  void add_test_float(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      test_float() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_test_float();

  // repeated double test_double = 12;
  int test_double_size() const;
  private:
  int _internal_test_double_size() const;
  public:
  void clear_test_double();
  private:
  double _internal_test_double(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_test_double() const;
  void _internal_add_test_double(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_test_double();
  public:
  double test_double(int index) const;
  void set_test_double(int index, double value);
  void add_test_double(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      test_double() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_test_double();

  // repeated bool test_boolean = 13;
  int test_boolean_size() const;
  private:
  int _internal_test_boolean_size() const;
  public:
  void clear_test_boolean();
  private:
  bool _internal_test_boolean(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_test_boolean() const;
  void _internal_add_test_boolean(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_test_boolean();
  public:
  bool test_boolean(int index) const;
  void set_test_boolean(int index, bool value);
  void add_test_boolean(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      test_boolean() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_test_boolean();

  // repeated .foo.TestEnumSmall test_enum_small = 14;
  int test_enum_small_size() const;
  private:
  int _internal_test_enum_small_size() const;
  public:
  void clear_test_enum_small();
  private:
  ::foo::TestEnumSmall _internal_test_enum_small(int index) const;
  void _internal_add_test_enum_small(::foo::TestEnumSmall value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_test_enum_small();
  public:
  ::foo::TestEnumSmall test_enum_small(int index) const;
  void set_test_enum_small(int index, ::foo::TestEnumSmall value);
  void add_test_enum_small(::foo::TestEnumSmall value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& test_enum_small() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_test_enum_small();

  // repeated .foo.TestEnum test_enum = 15;
  int test_enum_size() const;
  private:
  int _internal_test_enum_size() const;
  public:
  void clear_test_enum();
  private:
  ::foo::TestEnum _internal_test_enum(int index) const;
  void _internal_add_test_enum(::foo::TestEnum value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_test_enum();
  public:
  ::foo::TestEnum test_enum(int index) const;
  void set_test_enum(int index, ::foo::TestEnum value);
  void add_test_enum(::foo::TestEnum value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& test_enum() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_test_enum();

  // repeated string test_string = 16;
  int test_string_size() const;
  private:
  int _internal_test_string_size() const;
  public:
  void clear_test_string();
  const std::string& test_string(int index) const;
  std::string* mutable_test_string(int index);
  void set_test_string(int index, const std::string& value);
  void set_test_string(int index, std::string&& value);
  void set_test_string(int index, const char* value);
  void set_test_string(int index, const char* value, size_t size);
  std::string* add_test_string();
  void add_test_string(const std::string& value);
  void add_test_string(std::string&& value);
  void add_test_string(const char* value);
  void add_test_string(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& test_string() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_test_string();
  private:
  const std::string& _internal_test_string(int index) const;
  std::string* _internal_add_test_string();
  public:

  // repeated bytes test_bytes = 17;
  int test_bytes_size() const;
  private:
  int _internal_test_bytes_size() const;
  public:
  void clear_test_bytes();
  const std::string& test_bytes(int index) const;
  std::string* mutable_test_bytes(int index);
  void set_test_bytes(int index, const std::string& value);
  void set_test_bytes(int index, std::string&& value);
  void set_test_bytes(int index, const char* value);
  void set_test_bytes(int index, const void* value, size_t size);
  std::string* add_test_bytes();
  void add_test_bytes(const std::string& value);
  void add_test_bytes(std::string&& value);
  void add_test_bytes(const char* value);
  void add_test_bytes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& test_bytes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_test_bytes();
  private:
  const std::string& _internal_test_bytes(int index) const;
  std::string* _internal_add_test_bytes();
  public:

  // repeated .foo.SubMess test_message = 18;
  int test_message_size() const;
  private:
  int _internal_test_message_size() const;
  public:
  void clear_test_message();
  ::foo::SubMess* mutable_test_message(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::SubMess >*
      mutable_test_message();
  private:
  const ::foo::SubMess& _internal_test_message(int index) const;
  ::foo::SubMess* _internal_add_test_message();
  public:
  const ::foo::SubMess& test_message(int index) const;
  ::foo::SubMess* add_test_message();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::SubMess >&
      test_message() const;

  // @@protoc_insertion_point(class_scope:foo.TestMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_int32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_sint32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_sfixed32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_int64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_sint64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_sfixed64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > test_uint32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > test_fixed32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > test_uint64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > test_fixed64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > test_float_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > test_double_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > test_boolean_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> test_enum_small_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> test_enum_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> test_string_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> test_bytes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::SubMess > test_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessPacked final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessPacked) */ {
 public:
  inline TestMessPacked() : TestMessPacked(nullptr) {}
  ~TestMessPacked() override;
  explicit PROTOBUF_CONSTEXPR TestMessPacked(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessPacked(const TestMessPacked& from);
  TestMessPacked(TestMessPacked&& from) noexcept
    : TestMessPacked() {
    *this = ::std::move(from);
  }

  inline TestMessPacked& operator=(const TestMessPacked& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessPacked& operator=(TestMessPacked&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessPacked& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessPacked* internal_default_instance() {
    return reinterpret_cast<const TestMessPacked*>(
               &_TestMessPacked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TestMessPacked& a, TestMessPacked& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessPacked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessPacked* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessPacked* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessPacked>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessPacked& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessPacked& from) {
    TestMessPacked::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessPacked* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessPacked";
  }
  protected:
  explicit TestMessPacked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestInt32FieldNumber = 1,
    kTestSint32FieldNumber = 2,
    kTestSfixed32FieldNumber = 3,
    kTestInt64FieldNumber = 4,
    kTestSint64FieldNumber = 5,
    kTestSfixed64FieldNumber = 6,
    kTestUint32FieldNumber = 7,
    kTestFixed32FieldNumber = 8,
    kTestUint64FieldNumber = 9,
    kTestFixed64FieldNumber = 10,
    kTestFloatFieldNumber = 11,
    kTestDoubleFieldNumber = 12,
    kTestBooleanFieldNumber = 13,
    kTestEnumSmallFieldNumber = 14,
    kTestEnumFieldNumber = 15,
  };
  // repeated int32 test_int32 = 1 [packed = true];
  int test_int32_size() const;
  private:
  int _internal_test_int32_size() const;
  public:
  void clear_test_int32();
  private:
  int32_t _internal_test_int32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_int32() const;
  void _internal_add_test_int32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_int32();
  public:
  int32_t test_int32(int index) const;
  void set_test_int32(int index, int32_t value);
  void add_test_int32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_int32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_int32();

  // repeated sint32 test_sint32 = 2 [packed = true];
  int test_sint32_size() const;
  private:
  int _internal_test_sint32_size() const;
  public:
  void clear_test_sint32();
  private:
  int32_t _internal_test_sint32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_sint32() const;
  void _internal_add_test_sint32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_sint32();
  public:
  int32_t test_sint32(int index) const;
  void set_test_sint32(int index, int32_t value);
  void add_test_sint32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_sint32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_sint32();

  // repeated sfixed32 test_sfixed32 = 3 [packed = true];
  int test_sfixed32_size() const;
  private:
  int _internal_test_sfixed32_size() const;
  public:
  void clear_test_sfixed32();
  private:
  int32_t _internal_test_sfixed32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_test_sfixed32() const;
  void _internal_add_test_sfixed32(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_test_sfixed32();
  public:
  int32_t test_sfixed32(int index) const;
  void set_test_sfixed32(int index, int32_t value);
  void add_test_sfixed32(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      test_sfixed32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_test_sfixed32();

  // repeated int64 test_int64 = 4 [packed = true];
  int test_int64_size() const;
  private:
  int _internal_test_int64_size() const;
  public:
  void clear_test_int64();
  private:
  int64_t _internal_test_int64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_int64() const;
  void _internal_add_test_int64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_int64();
  public:
  int64_t test_int64(int index) const;
  void set_test_int64(int index, int64_t value);
  void add_test_int64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_int64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_int64();

  // repeated sint64 test_sint64 = 5 [packed = true];
  int test_sint64_size() const;
  private:
  int _internal_test_sint64_size() const;
  public:
  void clear_test_sint64();
  private:
  int64_t _internal_test_sint64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_sint64() const;
  void _internal_add_test_sint64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_sint64();
  public:
  int64_t test_sint64(int index) const;
  void set_test_sint64(int index, int64_t value);
  void add_test_sint64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_sint64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_sint64();

  // repeated sfixed64 test_sfixed64 = 6 [packed = true];
  int test_sfixed64_size() const;
  private:
  int _internal_test_sfixed64_size() const;
  public:
  void clear_test_sfixed64();
  private:
  int64_t _internal_test_sfixed64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_test_sfixed64() const;
  void _internal_add_test_sfixed64(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_test_sfixed64();
  public:
  int64_t test_sfixed64(int index) const;
  void set_test_sfixed64(int index, int64_t value);
  void add_test_sfixed64(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      test_sfixed64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_test_sfixed64();

  // repeated uint32 test_uint32 = 7 [packed = true];
  int test_uint32_size() const;
  private:
  int _internal_test_uint32_size() const;
  public:
  void clear_test_uint32();
  private:
  uint32_t _internal_test_uint32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_test_uint32() const;
  void _internal_add_test_uint32(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_test_uint32();
  public:
  uint32_t test_uint32(int index) const;
  void set_test_uint32(int index, uint32_t value);
  void add_test_uint32(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      test_uint32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_test_uint32();

  // repeated fixed32 test_fixed32 = 8 [packed = true];
  int test_fixed32_size() const;
  private:
  int _internal_test_fixed32_size() const;
  public:
  void clear_test_fixed32();
  private:
  uint32_t _internal_test_fixed32(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_test_fixed32() const;
  void _internal_add_test_fixed32(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_test_fixed32();
  public:
  uint32_t test_fixed32(int index) const;
  void set_test_fixed32(int index, uint32_t value);
  void add_test_fixed32(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      test_fixed32() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_test_fixed32();

  // repeated uint64 test_uint64 = 9 [packed = true];
  int test_uint64_size() const;
  private:
  int _internal_test_uint64_size() const;
  public:
  void clear_test_uint64();
  private:
  uint64_t _internal_test_uint64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_test_uint64() const;
  void _internal_add_test_uint64(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_test_uint64();
  public:
  uint64_t test_uint64(int index) const;
  void set_test_uint64(int index, uint64_t value);
  void add_test_uint64(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      test_uint64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_test_uint64();

  // repeated fixed64 test_fixed64 = 10 [packed = true];
  int test_fixed64_size() const;
  private:
  int _internal_test_fixed64_size() const;
  public:
  void clear_test_fixed64();
  private:
  uint64_t _internal_test_fixed64(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_test_fixed64() const;
  void _internal_add_test_fixed64(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_test_fixed64();
  public:
  uint64_t test_fixed64(int index) const;
  void set_test_fixed64(int index, uint64_t value);
  void add_test_fixed64(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      test_fixed64() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_test_fixed64();

  // repeated float test_float = 11 [packed = true];
  int test_float_size() const;
  private:
  int _internal_test_float_size() const;
  public:
  void clear_test_float();
  private:
  float _internal_test_float(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_test_float() const;
  void _internal_add_test_float(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_test_float();
  public:
  float test_float(int index) const;
  void set_test_float(int index, float value);
  void add_test_float(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      test_float() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_test_float();

  // repeated double test_double = 12 [packed = true];
  int test_double_size() const;
  private:
  int _internal_test_double_size() const;
  public:
  void clear_test_double();
  private:
  double _internal_test_double(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_test_double() const;
  void _internal_add_test_double(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_test_double();
  public:
  double test_double(int index) const;
  void set_test_double(int index, double value);
  void add_test_double(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      test_double() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_test_double();

  // repeated bool test_boolean = 13 [packed = true];
  int test_boolean_size() const;
  private:
  int _internal_test_boolean_size() const;
  public:
  void clear_test_boolean();
  private:
  bool _internal_test_boolean(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_test_boolean() const;
  void _internal_add_test_boolean(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_test_boolean();
  public:
  bool test_boolean(int index) const;
  void set_test_boolean(int index, bool value);
  void add_test_boolean(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      test_boolean() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_test_boolean();

  // repeated .foo.TestEnumSmall test_enum_small = 14 [packed = true];
  int test_enum_small_size() const;
  private:
  int _internal_test_enum_small_size() const;
  public:
  void clear_test_enum_small();
  private:
  ::foo::TestEnumSmall _internal_test_enum_small(int index) const;
  void _internal_add_test_enum_small(::foo::TestEnumSmall value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_test_enum_small();
  public:
  ::foo::TestEnumSmall test_enum_small(int index) const;
  void set_test_enum_small(int index, ::foo::TestEnumSmall value);
  void add_test_enum_small(::foo::TestEnumSmall value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& test_enum_small() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_test_enum_small();

  // repeated .foo.TestEnum test_enum = 15 [packed = true];
  int test_enum_size() const;
  private:
  int _internal_test_enum_size() const;
  public:
  void clear_test_enum();
  private:
  ::foo::TestEnum _internal_test_enum(int index) const;
  void _internal_add_test_enum(::foo::TestEnum value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_test_enum();
  public:
  ::foo::TestEnum test_enum(int index) const;
  void set_test_enum(int index, ::foo::TestEnum value);
  void add_test_enum(::foo::TestEnum value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& test_enum() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_test_enum();

  // @@protoc_insertion_point(class_scope:foo.TestMessPacked)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_int32_;
    mutable std::atomic<int> _test_int32_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_sint32_;
    mutable std::atomic<int> _test_sint32_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > test_sfixed32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_int64_;
    mutable std::atomic<int> _test_int64_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_sint64_;
    mutable std::atomic<int> _test_sint64_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > test_sfixed64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > test_uint32_;
    mutable std::atomic<int> _test_uint32_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > test_fixed32_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > test_uint64_;
    mutable std::atomic<int> _test_uint64_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > test_fixed64_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > test_float_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > test_double_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > test_boolean_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> test_enum_small_;
    mutable std::atomic<int> _test_enum_small_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> test_enum_;
    mutable std::atomic<int> _test_enum_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessOptional final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessOptional) */ {
 public:
  inline TestMessOptional() : TestMessOptional(nullptr) {}
  ~TestMessOptional() override;
  explicit PROTOBUF_CONSTEXPR TestMessOptional(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessOptional(const TestMessOptional& from);
  TestMessOptional(TestMessOptional&& from) noexcept
    : TestMessOptional() {
    *this = ::std::move(from);
  }

  inline TestMessOptional& operator=(const TestMessOptional& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessOptional& operator=(TestMessOptional&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessOptional& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessOptional* internal_default_instance() {
    return reinterpret_cast<const TestMessOptional*>(
               &_TestMessOptional_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TestMessOptional& a, TestMessOptional& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessOptional* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessOptional* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessOptional* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessOptional>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessOptional& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessOptional& from) {
    TestMessOptional::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessOptional* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessOptional";
  }
  protected:
  explicit TestMessOptional(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestStringFieldNumber = 16,
    kTestBytesFieldNumber = 17,
    kTestMessageFieldNumber = 18,
    kTestInt32FieldNumber = 1,
    kTestSint32FieldNumber = 2,
    kTestInt64FieldNumber = 4,
    kTestSint64FieldNumber = 5,
    kTestSfixed32FieldNumber = 3,
    kTestUint32FieldNumber = 7,
    kTestSfixed64FieldNumber = 6,
    kTestUint64FieldNumber = 9,
    kTestFixed32FieldNumber = 8,
    kTestFloatFieldNumber = 11,
    kTestFixed64FieldNumber = 10,
    kTestDoubleFieldNumber = 12,
    kTestBooleanFieldNumber = 13,
    kTestEnumSmallFieldNumber = 14,
    kTestEnumFieldNumber = 15,
  };
  // optional string test_string = 16;
  bool has_test_string() const;
  private:
  bool _internal_has_test_string() const;
  public:
  void clear_test_string();
  const std::string& test_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test_string();
  PROTOBUF_NODISCARD std::string* release_test_string();
  void set_allocated_test_string(std::string* test_string);
  private:
  const std::string& _internal_test_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_string(const std::string& value);
  std::string* _internal_mutable_test_string();
  public:

  // optional bytes test_bytes = 17;
  bool has_test_bytes() const;
  private:
  bool _internal_has_test_bytes() const;
  public:
  void clear_test_bytes();
  const std::string& test_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test_bytes();
  PROTOBUF_NODISCARD std::string* release_test_bytes();
  void set_allocated_test_bytes(std::string* test_bytes);
  private:
  const std::string& _internal_test_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_bytes(const std::string& value);
  std::string* _internal_mutable_test_bytes();
  public:

  // optional .foo.SubMess test_message = 18;
  bool has_test_message() const;
  private:
  bool _internal_has_test_message() const;
  public:
  void clear_test_message();
  const ::foo::SubMess& test_message() const;
  PROTOBUF_NODISCARD ::foo::SubMess* release_test_message();
  ::foo::SubMess* mutable_test_message();
  void set_allocated_test_message(::foo::SubMess* test_message);
  private:
  const ::foo::SubMess& _internal_test_message() const;
  ::foo::SubMess* _internal_mutable_test_message();
  public:
  void unsafe_arena_set_allocated_test_message(
      ::foo::SubMess* test_message);
  ::foo::SubMess* unsafe_arena_release_test_message();

  // optional int32 test_int32 = 1;
  bool has_test_int32() const;
  private:
  bool _internal_has_test_int32() const;
  public:
  void clear_test_int32();
  int32_t test_int32() const;
  void set_test_int32(int32_t value);
  private:
  int32_t _internal_test_int32() const;
  void _internal_set_test_int32(int32_t value);
  public:

  // optional sint32 test_sint32 = 2;
  bool has_test_sint32() const;
  private:
  bool _internal_has_test_sint32() const;
  public:
  void clear_test_sint32();
  int32_t test_sint32() const;
  void set_test_sint32(int32_t value);
  private:
  int32_t _internal_test_sint32() const;
  void _internal_set_test_sint32(int32_t value);
  public:

  // optional int64 test_int64 = 4;
  bool has_test_int64() const;
  private:
  bool _internal_has_test_int64() const;
  public:
  void clear_test_int64();
  int64_t test_int64() const;
  void set_test_int64(int64_t value);
  private:
  int64_t _internal_test_int64() const;
  void _internal_set_test_int64(int64_t value);
  public:

  // optional sint64 test_sint64 = 5;
  bool has_test_sint64() const;
  private:
  bool _internal_has_test_sint64() const;
  public:
  void clear_test_sint64();
  int64_t test_sint64() const;
  void set_test_sint64(int64_t value);
  private:
  int64_t _internal_test_sint64() const;
  void _internal_set_test_sint64(int64_t value);
  public:

  // optional sfixed32 test_sfixed32 = 3;
  bool has_test_sfixed32() const;
  private:
  bool _internal_has_test_sfixed32() const;
  public:
  void clear_test_sfixed32();
  int32_t test_sfixed32() const;
  void set_test_sfixed32(int32_t value);
  private:
  int32_t _internal_test_sfixed32() const;
  void _internal_set_test_sfixed32(int32_t value);
  public:

  // optional uint32 test_uint32 = 7;
  bool has_test_uint32() const;
  private:
  bool _internal_has_test_uint32() const;
  public:
  void clear_test_uint32();
  uint32_t test_uint32() const;
  void set_test_uint32(uint32_t value);
  private:
  uint32_t _internal_test_uint32() const;
  void _internal_set_test_uint32(uint32_t value);
  public:

  // optional sfixed64 test_sfixed64 = 6;
  bool has_test_sfixed64() const;
  private:
  bool _internal_has_test_sfixed64() const;
  public:
  void clear_test_sfixed64();
  int64_t test_sfixed64() const;
  void set_test_sfixed64(int64_t value);
  private:
  int64_t _internal_test_sfixed64() const;
  void _internal_set_test_sfixed64(int64_t value);
  public:

  // optional uint64 test_uint64 = 9;
  bool has_test_uint64() const;
  private:
  bool _internal_has_test_uint64() const;
  public:
  void clear_test_uint64();
  uint64_t test_uint64() const;
  void set_test_uint64(uint64_t value);
  private:
  uint64_t _internal_test_uint64() const;
  void _internal_set_test_uint64(uint64_t value);
  public:

  // optional fixed32 test_fixed32 = 8;
  bool has_test_fixed32() const;
  private:
  bool _internal_has_test_fixed32() const;
  public:
  void clear_test_fixed32();
  uint32_t test_fixed32() const;
  void set_test_fixed32(uint32_t value);
  private:
  uint32_t _internal_test_fixed32() const;
  void _internal_set_test_fixed32(uint32_t value);
  public:

  // optional float test_float = 11;
  bool has_test_float() const;
  private:
  bool _internal_has_test_float() const;
  public:
  void clear_test_float();
  float test_float() const;
  void set_test_float(float value);
  private:
  float _internal_test_float() const;
  void _internal_set_test_float(float value);
  public:

  // optional fixed64 test_fixed64 = 10;
  bool has_test_fixed64() const;
  private:
  bool _internal_has_test_fixed64() const;
  public:
  void clear_test_fixed64();
  uint64_t test_fixed64() const;
  void set_test_fixed64(uint64_t value);
  private:
  uint64_t _internal_test_fixed64() const;
  void _internal_set_test_fixed64(uint64_t value);
  public:

  // optional double test_double = 12;
  bool has_test_double() const;
  private:
  bool _internal_has_test_double() const;
  public:
  void clear_test_double();
  double test_double() const;
  void set_test_double(double value);
  private:
  double _internal_test_double() const;
  void _internal_set_test_double(double value);
  public:

  // optional bool test_boolean = 13;
  bool has_test_boolean() const;
  private:
  bool _internal_has_test_boolean() const;
  public:
  void clear_test_boolean();
  bool test_boolean() const;
  void set_test_boolean(bool value);
  private:
  bool _internal_test_boolean() const;
  void _internal_set_test_boolean(bool value);
  public:

  // optional .foo.TestEnumSmall test_enum_small = 14;
  bool has_test_enum_small() const;
  private:
  bool _internal_has_test_enum_small() const;
  public:
  void clear_test_enum_small();
  ::foo::TestEnumSmall test_enum_small() const;
  void set_test_enum_small(::foo::TestEnumSmall value);
  private:
  ::foo::TestEnumSmall _internal_test_enum_small() const;
  void _internal_set_test_enum_small(::foo::TestEnumSmall value);
  public:

  // optional .foo.TestEnum test_enum = 15;
  bool has_test_enum() const;
  private:
  bool _internal_has_test_enum() const;
  public:
  void clear_test_enum();
  ::foo::TestEnum test_enum() const;
  void set_test_enum(::foo::TestEnum value);
  private:
  ::foo::TestEnum _internal_test_enum() const;
  void _internal_set_test_enum(::foo::TestEnum value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessOptional)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_bytes_;
    ::foo::SubMess* test_message_;
    int32_t test_int32_;
    int32_t test_sint32_;
    int64_t test_int64_;
    int64_t test_sint64_;
    int32_t test_sfixed32_;
    uint32_t test_uint32_;
    int64_t test_sfixed64_;
    uint64_t test_uint64_;
    uint32_t test_fixed32_;
    float test_float_;
    uint64_t test_fixed64_;
    double test_double_;
    bool test_boolean_;
    int test_enum_small_;
    int test_enum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessOneof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessOneof) */ {
 public:
  inline TestMessOneof() : TestMessOneof(nullptr) {}
  ~TestMessOneof() override;
  explicit PROTOBUF_CONSTEXPR TestMessOneof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessOneof(const TestMessOneof& from);
  TestMessOneof(TestMessOneof&& from) noexcept
    : TestMessOneof() {
    *this = ::std::move(from);
  }

  inline TestMessOneof& operator=(const TestMessOneof& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessOneof& operator=(TestMessOneof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessOneof& default_instance() {
    return *internal_default_instance();
  }
  enum TestOneofCase {
    kTestInt32 = 1,
    kTestSint32 = 2,
    kTestSfixed32 = 3,
    kTestInt64 = 4,
    kTestSint64 = 5,
    kTestSfixed64 = 6,
    kTestUint32 = 7,
    kTestFixed32 = 8,
    kTestUint64 = 9,
    kTestFixed64 = 10,
    kTestFloat = 11,
    kTestDouble = 12,
    kTestBoolean = 13,
    kTestEnumSmall = 14,
    kTestEnum = 15,
    kTestString = 16,
    kTestBytes = 17,
    kTestMessage = 18,
    TEST_ONEOF_NOT_SET = 0,
  };

  static inline const TestMessOneof* internal_default_instance() {
    return reinterpret_cast<const TestMessOneof*>(
               &_TestMessOneof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TestMessOneof& a, TestMessOneof& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessOneof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessOneof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessOneof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessOneof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessOneof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessOneof& from) {
    TestMessOneof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessOneof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessOneof";
  }
  protected:
  explicit TestMessOneof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptIntFieldNumber = 19,
    kTestInt32FieldNumber = 1,
    kTestSint32FieldNumber = 2,
    kTestSfixed32FieldNumber = 3,
    kTestInt64FieldNumber = 4,
    kTestSint64FieldNumber = 5,
    kTestSfixed64FieldNumber = 6,
    kTestUint32FieldNumber = 7,
    kTestFixed32FieldNumber = 8,
    kTestUint64FieldNumber = 9,
    kTestFixed64FieldNumber = 10,
    kTestFloatFieldNumber = 11,
    kTestDoubleFieldNumber = 12,
    kTestBooleanFieldNumber = 13,
    kTestEnumSmallFieldNumber = 14,
    kTestEnumFieldNumber = 15,
    kTestStringFieldNumber = 16,
    kTestBytesFieldNumber = 17,
    kTestMessageFieldNumber = 18,
  };
  // optional int32 opt_int = 19;
  bool has_opt_int() const;
  private:
  bool _internal_has_opt_int() const;
  public:
  void clear_opt_int();
  int32_t opt_int() const;
  void set_opt_int(int32_t value);
  private:
  int32_t _internal_opt_int() const;
  void _internal_set_opt_int(int32_t value);
  public:

  // int32 test_int32 = 1;
  bool has_test_int32() const;
  private:
  bool _internal_has_test_int32() const;
  public:
  void clear_test_int32();
  int32_t test_int32() const;
  void set_test_int32(int32_t value);
  private:
  int32_t _internal_test_int32() const;
  void _internal_set_test_int32(int32_t value);
  public:

  // sint32 test_sint32 = 2;
  bool has_test_sint32() const;
  private:
  bool _internal_has_test_sint32() const;
  public:
  void clear_test_sint32();
  int32_t test_sint32() const;
  void set_test_sint32(int32_t value);
  private:
  int32_t _internal_test_sint32() const;
  void _internal_set_test_sint32(int32_t value);
  public:

  // sfixed32 test_sfixed32 = 3;
  bool has_test_sfixed32() const;
  private:
  bool _internal_has_test_sfixed32() const;
  public:
  void clear_test_sfixed32();
  int32_t test_sfixed32() const;
  void set_test_sfixed32(int32_t value);
  private:
  int32_t _internal_test_sfixed32() const;
  void _internal_set_test_sfixed32(int32_t value);
  public:

  // int64 test_int64 = 4;
  bool has_test_int64() const;
  private:
  bool _internal_has_test_int64() const;
  public:
  void clear_test_int64();
  int64_t test_int64() const;
  void set_test_int64(int64_t value);
  private:
  int64_t _internal_test_int64() const;
  void _internal_set_test_int64(int64_t value);
  public:

  // sint64 test_sint64 = 5;
  bool has_test_sint64() const;
  private:
  bool _internal_has_test_sint64() const;
  public:
  void clear_test_sint64();
  int64_t test_sint64() const;
  void set_test_sint64(int64_t value);
  private:
  int64_t _internal_test_sint64() const;
  void _internal_set_test_sint64(int64_t value);
  public:

  // sfixed64 test_sfixed64 = 6;
  bool has_test_sfixed64() const;
  private:
  bool _internal_has_test_sfixed64() const;
  public:
  void clear_test_sfixed64();
  int64_t test_sfixed64() const;
  void set_test_sfixed64(int64_t value);
  private:
  int64_t _internal_test_sfixed64() const;
  void _internal_set_test_sfixed64(int64_t value);
  public:

  // uint32 test_uint32 = 7;
  bool has_test_uint32() const;
  private:
  bool _internal_has_test_uint32() const;
  public:
  void clear_test_uint32();
  uint32_t test_uint32() const;
  void set_test_uint32(uint32_t value);
  private:
  uint32_t _internal_test_uint32() const;
  void _internal_set_test_uint32(uint32_t value);
  public:

  // fixed32 test_fixed32 = 8;
  bool has_test_fixed32() const;
  private:
  bool _internal_has_test_fixed32() const;
  public:
  void clear_test_fixed32();
  uint32_t test_fixed32() const;
  void set_test_fixed32(uint32_t value);
  private:
  uint32_t _internal_test_fixed32() const;
  void _internal_set_test_fixed32(uint32_t value);
  public:

  // uint64 test_uint64 = 9;
  bool has_test_uint64() const;
  private:
  bool _internal_has_test_uint64() const;
  public:
  void clear_test_uint64();
  uint64_t test_uint64() const;
  void set_test_uint64(uint64_t value);
  private:
  uint64_t _internal_test_uint64() const;
  void _internal_set_test_uint64(uint64_t value);
  public:

  // fixed64 test_fixed64 = 10;
  bool has_test_fixed64() const;
  private:
  bool _internal_has_test_fixed64() const;
  public:
  void clear_test_fixed64();
  uint64_t test_fixed64() const;
  void set_test_fixed64(uint64_t value);
  private:
  uint64_t _internal_test_fixed64() const;
  void _internal_set_test_fixed64(uint64_t value);
  public:

  // float test_float = 11;
  bool has_test_float() const;
  private:
  bool _internal_has_test_float() const;
  public:
  void clear_test_float();
  float test_float() const;
  void set_test_float(float value);
  private:
  float _internal_test_float() const;
  void _internal_set_test_float(float value);
  public:

  // double test_double = 12;
  bool has_test_double() const;
  private:
  bool _internal_has_test_double() const;
  public:
  void clear_test_double();
  double test_double() const;
  void set_test_double(double value);
  private:
  double _internal_test_double() const;
  void _internal_set_test_double(double value);
  public:

  // bool test_boolean = 13;
  bool has_test_boolean() const;
  private:
  bool _internal_has_test_boolean() const;
  public:
  void clear_test_boolean();
  bool test_boolean() const;
  void set_test_boolean(bool value);
  private:
  bool _internal_test_boolean() const;
  void _internal_set_test_boolean(bool value);
  public:

  // .foo.TestEnumSmall test_enum_small = 14;
  bool has_test_enum_small() const;
  private:
  bool _internal_has_test_enum_small() const;
  public:
  void clear_test_enum_small();
  ::foo::TestEnumSmall test_enum_small() const;
  void set_test_enum_small(::foo::TestEnumSmall value);
  private:
  ::foo::TestEnumSmall _internal_test_enum_small() const;
  void _internal_set_test_enum_small(::foo::TestEnumSmall value);
  public:

  // .foo.TestEnum test_enum = 15;
  bool has_test_enum() const;
  private:
  bool _internal_has_test_enum() const;
  public:
  void clear_test_enum();
  ::foo::TestEnum test_enum() const;
  void set_test_enum(::foo::TestEnum value);
  private:
  ::foo::TestEnum _internal_test_enum() const;
  void _internal_set_test_enum(::foo::TestEnum value);
  public:

  // string test_string = 16;
  bool has_test_string() const;
  private:
  bool _internal_has_test_string() const;
  public:
  void clear_test_string();
  const std::string& test_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test_string();
  PROTOBUF_NODISCARD std::string* release_test_string();
  void set_allocated_test_string(std::string* test_string);
  private:
  const std::string& _internal_test_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_string(const std::string& value);
  std::string* _internal_mutable_test_string();
  public:

  // bytes test_bytes = 17;
  bool has_test_bytes() const;
  private:
  bool _internal_has_test_bytes() const;
  public:
  void clear_test_bytes();
  const std::string& test_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test_bytes();
  PROTOBUF_NODISCARD std::string* release_test_bytes();
  void set_allocated_test_bytes(std::string* test_bytes);
  private:
  const std::string& _internal_test_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test_bytes(const std::string& value);
  std::string* _internal_mutable_test_bytes();
  public:

  // .foo.SubMess test_message = 18;
  bool has_test_message() const;
  private:
  bool _internal_has_test_message() const;
  public:
  void clear_test_message();
  const ::foo::SubMess& test_message() const;
  PROTOBUF_NODISCARD ::foo::SubMess* release_test_message();
  ::foo::SubMess* mutable_test_message();
  void set_allocated_test_message(::foo::SubMess* test_message);
  private:
  const ::foo::SubMess& _internal_test_message() const;
  ::foo::SubMess* _internal_mutable_test_message();
  public:
  void unsafe_arena_set_allocated_test_message(
      ::foo::SubMess* test_message);
  ::foo::SubMess* unsafe_arena_release_test_message();

  void clear_test_oneof();
  TestOneofCase test_oneof_case() const;
  // @@protoc_insertion_point(class_scope:foo.TestMessOneof)
 private:
  class _Internal;
  void set_has_test_int32();
  void set_has_test_sint32();
  void set_has_test_sfixed32();
  void set_has_test_int64();
  void set_has_test_sint64();
  void set_has_test_sfixed64();
  void set_has_test_uint32();
  void set_has_test_fixed32();
  void set_has_test_uint64();
  void set_has_test_fixed64();
  void set_has_test_float();
  void set_has_test_double();
  void set_has_test_boolean();
  void set_has_test_enum_small();
  void set_has_test_enum();
  void set_has_test_string();
  void set_has_test_bytes();
  void set_has_test_message();

  inline bool has_test_oneof() const;
  inline void clear_has_test_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t opt_int_;
    union TestOneofUnion {
      constexpr TestOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t test_int32_;
      int32_t test_sint32_;
      int32_t test_sfixed32_;
      int64_t test_int64_;
      int64_t test_sint64_;
      int64_t test_sfixed64_;
      uint32_t test_uint32_;
      uint32_t test_fixed32_;
      uint64_t test_uint64_;
      uint64_t test_fixed64_;
      float test_float_;
      double test_double_;
      bool test_boolean_;
      int test_enum_small_;
      int test_enum_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_string_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_bytes_;
      ::foo::SubMess* test_message_;
    } test_oneof_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredInt32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredInt32) */ {
 public:
  inline TestMessRequiredInt32() : TestMessRequiredInt32(nullptr) {}
  ~TestMessRequiredInt32() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredInt32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredInt32(const TestMessRequiredInt32& from);
  TestMessRequiredInt32(TestMessRequiredInt32&& from) noexcept
    : TestMessRequiredInt32() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredInt32& operator=(const TestMessRequiredInt32& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredInt32& operator=(TestMessRequiredInt32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredInt32& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredInt32* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredInt32*>(
               &_TestMessRequiredInt32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TestMessRequiredInt32& a, TestMessRequiredInt32& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredInt32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredInt32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredInt32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredInt32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredInt32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredInt32& from) {
    TestMessRequiredInt32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredInt32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredInt32";
  }
  protected:
  explicit TestMessRequiredInt32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 42,
  };
  // required int32 test = 42;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int32_t test() const;
  void set_test(int32_t value);
  private:
  int32_t _internal_test() const;
  void _internal_set_test(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredInt32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredSInt32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredSInt32) */ {
 public:
  inline TestMessRequiredSInt32() : TestMessRequiredSInt32(nullptr) {}
  ~TestMessRequiredSInt32() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredSInt32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredSInt32(const TestMessRequiredSInt32& from);
  TestMessRequiredSInt32(TestMessRequiredSInt32&& from) noexcept
    : TestMessRequiredSInt32() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredSInt32& operator=(const TestMessRequiredSInt32& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredSInt32& operator=(TestMessRequiredSInt32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredSInt32& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredSInt32* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredSInt32*>(
               &_TestMessRequiredSInt32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TestMessRequiredSInt32& a, TestMessRequiredSInt32& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredSInt32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredSInt32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredSInt32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredSInt32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredSInt32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredSInt32& from) {
    TestMessRequiredSInt32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredSInt32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredSInt32";
  }
  protected:
  explicit TestMessRequiredSInt32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 43,
  };
  // required sint32 test = 43;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int32_t test() const;
  void set_test(int32_t value);
  private:
  int32_t _internal_test() const;
  void _internal_set_test(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredSInt32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredSFixed32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredSFixed32) */ {
 public:
  inline TestMessRequiredSFixed32() : TestMessRequiredSFixed32(nullptr) {}
  ~TestMessRequiredSFixed32() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredSFixed32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredSFixed32(const TestMessRequiredSFixed32& from);
  TestMessRequiredSFixed32(TestMessRequiredSFixed32&& from) noexcept
    : TestMessRequiredSFixed32() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredSFixed32& operator=(const TestMessRequiredSFixed32& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredSFixed32& operator=(TestMessRequiredSFixed32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredSFixed32& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredSFixed32* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredSFixed32*>(
               &_TestMessRequiredSFixed32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TestMessRequiredSFixed32& a, TestMessRequiredSFixed32& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredSFixed32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredSFixed32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredSFixed32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredSFixed32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredSFixed32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredSFixed32& from) {
    TestMessRequiredSFixed32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredSFixed32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredSFixed32";
  }
  protected:
  explicit TestMessRequiredSFixed32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 100,
  };
  // required sfixed32 test = 100;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int32_t test() const;
  void set_test(int32_t value);
  private:
  int32_t _internal_test() const;
  void _internal_set_test(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredSFixed32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredInt64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredInt64) */ {
 public:
  inline TestMessRequiredInt64() : TestMessRequiredInt64(nullptr) {}
  ~TestMessRequiredInt64() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredInt64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredInt64(const TestMessRequiredInt64& from);
  TestMessRequiredInt64(TestMessRequiredInt64&& from) noexcept
    : TestMessRequiredInt64() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredInt64& operator=(const TestMessRequiredInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredInt64& operator=(TestMessRequiredInt64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredInt64& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredInt64* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredInt64*>(
               &_TestMessRequiredInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TestMessRequiredInt64& a, TestMessRequiredInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredInt64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredInt64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredInt64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredInt64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredInt64& from) {
    TestMessRequiredInt64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredInt64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredInt64";
  }
  protected:
  explicit TestMessRequiredInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required int64 test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int64_t test() const;
  void set_test(int64_t value);
  private:
  int64_t _internal_test() const;
  void _internal_set_test(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredInt64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredSInt64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredSInt64) */ {
 public:
  inline TestMessRequiredSInt64() : TestMessRequiredSInt64(nullptr) {}
  ~TestMessRequiredSInt64() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredSInt64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredSInt64(const TestMessRequiredSInt64& from);
  TestMessRequiredSInt64(TestMessRequiredSInt64&& from) noexcept
    : TestMessRequiredSInt64() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredSInt64& operator=(const TestMessRequiredSInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredSInt64& operator=(TestMessRequiredSInt64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredSInt64& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredSInt64* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredSInt64*>(
               &_TestMessRequiredSInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TestMessRequiredSInt64& a, TestMessRequiredSInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredSInt64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredSInt64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredSInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredSInt64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredSInt64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredSInt64& from) {
    TestMessRequiredSInt64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredSInt64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredSInt64";
  }
  protected:
  explicit TestMessRequiredSInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 11,
  };
  // required sint64 test = 11;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int64_t test() const;
  void set_test(int64_t value);
  private:
  int64_t _internal_test() const;
  void _internal_set_test(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredSInt64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredSFixed64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredSFixed64) */ {
 public:
  inline TestMessRequiredSFixed64() : TestMessRequiredSFixed64(nullptr) {}
  ~TestMessRequiredSFixed64() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredSFixed64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredSFixed64(const TestMessRequiredSFixed64& from);
  TestMessRequiredSFixed64(TestMessRequiredSFixed64&& from) noexcept
    : TestMessRequiredSFixed64() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredSFixed64& operator=(const TestMessRequiredSFixed64& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredSFixed64& operator=(TestMessRequiredSFixed64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredSFixed64& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredSFixed64* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredSFixed64*>(
               &_TestMessRequiredSFixed64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TestMessRequiredSFixed64& a, TestMessRequiredSFixed64& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredSFixed64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredSFixed64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredSFixed64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredSFixed64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredSFixed64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredSFixed64& from) {
    TestMessRequiredSFixed64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredSFixed64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredSFixed64";
  }
  protected:
  explicit TestMessRequiredSFixed64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 12,
  };
  // required sfixed64 test = 12;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  int64_t test() const;
  void set_test(int64_t value);
  private:
  int64_t _internal_test() const;
  void _internal_set_test(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredSFixed64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredUInt32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredUInt32) */ {
 public:
  inline TestMessRequiredUInt32() : TestMessRequiredUInt32(nullptr) {}
  ~TestMessRequiredUInt32() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredUInt32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredUInt32(const TestMessRequiredUInt32& from);
  TestMessRequiredUInt32(TestMessRequiredUInt32&& from) noexcept
    : TestMessRequiredUInt32() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredUInt32& operator=(const TestMessRequiredUInt32& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredUInt32& operator=(TestMessRequiredUInt32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredUInt32& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredUInt32* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredUInt32*>(
               &_TestMessRequiredUInt32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TestMessRequiredUInt32& a, TestMessRequiredUInt32& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredUInt32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredUInt32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredUInt32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredUInt32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredUInt32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredUInt32& from) {
    TestMessRequiredUInt32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredUInt32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredUInt32";
  }
  protected:
  explicit TestMessRequiredUInt32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required uint32 test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  uint32_t test() const;
  void set_test(uint32_t value);
  private:
  uint32_t _internal_test() const;
  void _internal_set_test(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredUInt32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredFixed32 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredFixed32) */ {
 public:
  inline TestMessRequiredFixed32() : TestMessRequiredFixed32(nullptr) {}
  ~TestMessRequiredFixed32() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredFixed32(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredFixed32(const TestMessRequiredFixed32& from);
  TestMessRequiredFixed32(TestMessRequiredFixed32&& from) noexcept
    : TestMessRequiredFixed32() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredFixed32& operator=(const TestMessRequiredFixed32& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredFixed32& operator=(TestMessRequiredFixed32&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredFixed32& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredFixed32* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredFixed32*>(
               &_TestMessRequiredFixed32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TestMessRequiredFixed32& a, TestMessRequiredFixed32& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredFixed32* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredFixed32* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredFixed32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredFixed32>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredFixed32& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredFixed32& from) {
    TestMessRequiredFixed32::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredFixed32* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredFixed32";
  }
  protected:
  explicit TestMessRequiredFixed32(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required fixed32 test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  uint32_t test() const;
  void set_test(uint32_t value);
  private:
  uint32_t _internal_test() const;
  void _internal_set_test(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredFixed32)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredUInt64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredUInt64) */ {
 public:
  inline TestMessRequiredUInt64() : TestMessRequiredUInt64(nullptr) {}
  ~TestMessRequiredUInt64() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredUInt64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredUInt64(const TestMessRequiredUInt64& from);
  TestMessRequiredUInt64(TestMessRequiredUInt64&& from) noexcept
    : TestMessRequiredUInt64() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredUInt64& operator=(const TestMessRequiredUInt64& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredUInt64& operator=(TestMessRequiredUInt64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredUInt64& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredUInt64* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredUInt64*>(
               &_TestMessRequiredUInt64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TestMessRequiredUInt64& a, TestMessRequiredUInt64& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredUInt64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredUInt64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredUInt64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredUInt64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredUInt64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredUInt64& from) {
    TestMessRequiredUInt64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredUInt64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredUInt64";
  }
  protected:
  explicit TestMessRequiredUInt64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required uint64 test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  uint64_t test() const;
  void set_test(uint64_t value);
  private:
  uint64_t _internal_test() const;
  void _internal_set_test(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredUInt64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredFixed64 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredFixed64) */ {
 public:
  inline TestMessRequiredFixed64() : TestMessRequiredFixed64(nullptr) {}
  ~TestMessRequiredFixed64() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredFixed64(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredFixed64(const TestMessRequiredFixed64& from);
  TestMessRequiredFixed64(TestMessRequiredFixed64&& from) noexcept
    : TestMessRequiredFixed64() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredFixed64& operator=(const TestMessRequiredFixed64& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredFixed64& operator=(TestMessRequiredFixed64&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredFixed64& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredFixed64* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredFixed64*>(
               &_TestMessRequiredFixed64_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TestMessRequiredFixed64& a, TestMessRequiredFixed64& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredFixed64* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredFixed64* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredFixed64* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredFixed64>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredFixed64& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredFixed64& from) {
    TestMessRequiredFixed64::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredFixed64* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredFixed64";
  }
  protected:
  explicit TestMessRequiredFixed64(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required fixed64 test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  uint64_t test() const;
  void set_test(uint64_t value);
  private:
  uint64_t _internal_test() const;
  void _internal_set_test(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredFixed64)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredFloat) */ {
 public:
  inline TestMessRequiredFloat() : TestMessRequiredFloat(nullptr) {}
  ~TestMessRequiredFloat() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredFloat(const TestMessRequiredFloat& from);
  TestMessRequiredFloat(TestMessRequiredFloat&& from) noexcept
    : TestMessRequiredFloat() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredFloat& operator=(const TestMessRequiredFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredFloat& operator=(TestMessRequiredFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredFloat* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredFloat*>(
               &_TestMessRequiredFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TestMessRequiredFloat& a, TestMessRequiredFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredFloat& from) {
    TestMessRequiredFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredFloat";
  }
  protected:
  explicit TestMessRequiredFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required float test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  float test() const;
  void set_test(float value);
  private:
  float _internal_test() const;
  void _internal_set_test(float value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredDouble final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredDouble) */ {
 public:
  inline TestMessRequiredDouble() : TestMessRequiredDouble(nullptr) {}
  ~TestMessRequiredDouble() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredDouble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredDouble(const TestMessRequiredDouble& from);
  TestMessRequiredDouble(TestMessRequiredDouble&& from) noexcept
    : TestMessRequiredDouble() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredDouble& operator=(const TestMessRequiredDouble& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredDouble& operator=(TestMessRequiredDouble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredDouble& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredDouble* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredDouble*>(
               &_TestMessRequiredDouble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TestMessRequiredDouble& a, TestMessRequiredDouble& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredDouble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredDouble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredDouble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredDouble>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredDouble& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredDouble& from) {
    TestMessRequiredDouble::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredDouble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredDouble";
  }
  protected:
  explicit TestMessRequiredDouble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required double test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  double test() const;
  void set_test(double value);
  private:
  double _internal_test() const;
  void _internal_set_test(double value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredDouble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredBool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredBool) */ {
 public:
  inline TestMessRequiredBool() : TestMessRequiredBool(nullptr) {}
  ~TestMessRequiredBool() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredBool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredBool(const TestMessRequiredBool& from);
  TestMessRequiredBool(TestMessRequiredBool&& from) noexcept
    : TestMessRequiredBool() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredBool& operator=(const TestMessRequiredBool& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredBool& operator=(TestMessRequiredBool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredBool& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredBool* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredBool*>(
               &_TestMessRequiredBool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TestMessRequiredBool& a, TestMessRequiredBool& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredBool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredBool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredBool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredBool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredBool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredBool& from) {
    TestMessRequiredBool::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredBool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredBool";
  }
  protected:
  explicit TestMessRequiredBool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required bool test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  bool test() const;
  void set_test(bool value);
  private:
  bool _internal_test() const;
  void _internal_set_test(bool value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredBool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredEnum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredEnum) */ {
 public:
  inline TestMessRequiredEnum() : TestMessRequiredEnum(nullptr) {}
  ~TestMessRequiredEnum() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredEnum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredEnum(const TestMessRequiredEnum& from);
  TestMessRequiredEnum(TestMessRequiredEnum&& from) noexcept
    : TestMessRequiredEnum() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredEnum& operator=(const TestMessRequiredEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredEnum& operator=(TestMessRequiredEnum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredEnum& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredEnum* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredEnum*>(
               &_TestMessRequiredEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TestMessRequiredEnum& a, TestMessRequiredEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredEnum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredEnum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredEnum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredEnum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredEnum& from) {
    TestMessRequiredEnum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredEnum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredEnum";
  }
  protected:
  explicit TestMessRequiredEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required .foo.TestEnum test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  ::foo::TestEnum test() const;
  void set_test(::foo::TestEnum value);
  private:
  ::foo::TestEnum _internal_test() const;
  void _internal_set_test(::foo::TestEnum value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredEnum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredEnumSmall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredEnumSmall) */ {
 public:
  inline TestMessRequiredEnumSmall() : TestMessRequiredEnumSmall(nullptr) {}
  ~TestMessRequiredEnumSmall() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredEnumSmall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredEnumSmall(const TestMessRequiredEnumSmall& from);
  TestMessRequiredEnumSmall(TestMessRequiredEnumSmall&& from) noexcept
    : TestMessRequiredEnumSmall() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredEnumSmall& operator=(const TestMessRequiredEnumSmall& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredEnumSmall& operator=(TestMessRequiredEnumSmall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredEnumSmall& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredEnumSmall* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredEnumSmall*>(
               &_TestMessRequiredEnumSmall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TestMessRequiredEnumSmall& a, TestMessRequiredEnumSmall& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredEnumSmall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredEnumSmall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredEnumSmall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredEnumSmall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredEnumSmall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredEnumSmall& from) {
    TestMessRequiredEnumSmall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredEnumSmall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredEnumSmall";
  }
  protected:
  explicit TestMessRequiredEnumSmall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required .foo.TestEnumSmall test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  ::foo::TestEnumSmall test() const;
  void set_test(::foo::TestEnumSmall value);
  private:
  ::foo::TestEnumSmall _internal_test() const;
  void _internal_set_test(::foo::TestEnumSmall value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredEnumSmall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredString) */ {
 public:
  inline TestMessRequiredString() : TestMessRequiredString(nullptr) {}
  ~TestMessRequiredString() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredString(const TestMessRequiredString& from);
  TestMessRequiredString(TestMessRequiredString&& from) noexcept
    : TestMessRequiredString() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredString& operator=(const TestMessRequiredString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredString& operator=(TestMessRequiredString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredString* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredString*>(
               &_TestMessRequiredString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TestMessRequiredString& a, TestMessRequiredString& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredString& from) {
    TestMessRequiredString::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredString";
  }
  protected:
  explicit TestMessRequiredString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required string test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredBytes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredBytes) */ {
 public:
  inline TestMessRequiredBytes() : TestMessRequiredBytes(nullptr) {}
  ~TestMessRequiredBytes() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredBytes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredBytes(const TestMessRequiredBytes& from);
  TestMessRequiredBytes(TestMessRequiredBytes&& from) noexcept
    : TestMessRequiredBytes() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredBytes& operator=(const TestMessRequiredBytes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredBytes& operator=(TestMessRequiredBytes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredBytes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredBytes* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredBytes*>(
               &_TestMessRequiredBytes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TestMessRequiredBytes& a, TestMessRequiredBytes& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredBytes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredBytes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredBytes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredBytes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredBytes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredBytes& from) {
    TestMessRequiredBytes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredBytes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredBytes";
  }
  protected:
  explicit TestMessRequiredBytes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required bytes test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const std::string& test() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_test(ArgT0&& arg0, ArgT... args);
  std::string* mutable_test();
  PROTOBUF_NODISCARD std::string* release_test();
  void set_allocated_test(std::string* test);
  private:
  const std::string& _internal_test() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_test(const std::string& value);
  std::string* _internal_mutable_test();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredBytes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessRequiredMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessRequiredMessage) */ {
 public:
  inline TestMessRequiredMessage() : TestMessRequiredMessage(nullptr) {}
  ~TestMessRequiredMessage() override;
  explicit PROTOBUF_CONSTEXPR TestMessRequiredMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessRequiredMessage(const TestMessRequiredMessage& from);
  TestMessRequiredMessage(TestMessRequiredMessage&& from) noexcept
    : TestMessRequiredMessage() {
    *this = ::std::move(from);
  }

  inline TestMessRequiredMessage& operator=(const TestMessRequiredMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessRequiredMessage& operator=(TestMessRequiredMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessRequiredMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessRequiredMessage* internal_default_instance() {
    return reinterpret_cast<const TestMessRequiredMessage*>(
               &_TestMessRequiredMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TestMessRequiredMessage& a, TestMessRequiredMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessRequiredMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessRequiredMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessRequiredMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessRequiredMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessRequiredMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessRequiredMessage& from) {
    TestMessRequiredMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessRequiredMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessRequiredMessage";
  }
  protected:
  explicit TestMessRequiredMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestFieldNumber = 1,
  };
  // required .foo.SubMess test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const ::foo::SubMess& test() const;
  PROTOBUF_NODISCARD ::foo::SubMess* release_test();
  ::foo::SubMess* mutable_test();
  void set_allocated_test(::foo::SubMess* test);
  private:
  const ::foo::SubMess& _internal_test() const;
  ::foo::SubMess* _internal_mutable_test();
  public:
  void unsafe_arena_set_allocated_test(
      ::foo::SubMess* test);
  ::foo::SubMess* unsafe_arena_release_test();

  // @@protoc_insertion_point(class_scope:foo.TestMessRequiredMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::foo::SubMess* test_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class EmptyMess final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:foo.EmptyMess) */ {
 public:
  inline EmptyMess() : EmptyMess(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EmptyMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyMess(const EmptyMess& from);
  EmptyMess(EmptyMess&& from) noexcept
    : EmptyMess() {
    *this = ::std::move(from);
  }

  inline EmptyMess& operator=(const EmptyMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMess& operator=(EmptyMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyMess* internal_default_instance() {
    return reinterpret_cast<const EmptyMess*>(
               &_EmptyMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(EmptyMess& a, EmptyMess& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyMess& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyMess& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.EmptyMess";
  }
  protected:
  explicit EmptyMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:foo.EmptyMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class DefaultRequiredValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.DefaultRequiredValues) */ {
 public:
  inline DefaultRequiredValues() : DefaultRequiredValues(nullptr) {}
  ~DefaultRequiredValues() override;
  explicit PROTOBUF_CONSTEXPR DefaultRequiredValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultRequiredValues(const DefaultRequiredValues& from);
  DefaultRequiredValues(DefaultRequiredValues&& from) noexcept
    : DefaultRequiredValues() {
    *this = ::std::move(from);
  }

  inline DefaultRequiredValues& operator=(const DefaultRequiredValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultRequiredValues& operator=(DefaultRequiredValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultRequiredValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultRequiredValues* internal_default_instance() {
    return reinterpret_cast<const DefaultRequiredValues*>(
               &_DefaultRequiredValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DefaultRequiredValues& a, DefaultRequiredValues& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultRequiredValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultRequiredValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultRequiredValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultRequiredValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultRequiredValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultRequiredValues& from) {
    DefaultRequiredValues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultRequiredValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.DefaultRequiredValues";
  }
  protected:
  explicit DefaultRequiredValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVStringFieldNumber = 7,
    kVBytesFieldNumber = 8,
    kVFloatFieldNumber = 5,
    kVInt32FieldNumber = 1,
    kVUint32FieldNumber = 2,
    kVInt64FieldNumber = 3,
    kVUint64FieldNumber = 4,
    kVDoubleFieldNumber = 6,
  };
  // required string v_string = 7 [default = "hi mom\n"];
  bool has_v_string() const;
  private:
  bool _internal_has_v_string() const;
  public:
  void clear_v_string();
  const std::string& v_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v_string();
  PROTOBUF_NODISCARD std::string* release_v_string();
  void set_allocated_v_string(std::string* v_string);
  private:
  const std::string& _internal_v_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v_string(const std::string& value);
  std::string* _internal_mutable_v_string();
  public:

  // required bytes v_bytes = 8 [default = "a \000 character"];
  bool has_v_bytes() const;
  private:
  bool _internal_has_v_bytes() const;
  public:
  void clear_v_bytes();
  const std::string& v_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v_bytes();
  PROTOBUF_NODISCARD std::string* release_v_bytes();
  void set_allocated_v_bytes(std::string* v_bytes);
  private:
  const std::string& _internal_v_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v_bytes(const std::string& value);
  std::string* _internal_mutable_v_bytes();
  public:

  // required float v_float = 5 [default = 2.5];
  bool has_v_float() const;
  private:
  bool _internal_has_v_float() const;
  public:
  void clear_v_float();
  float v_float() const;
  void set_v_float(float value);
  private:
  float _internal_v_float() const;
  void _internal_set_v_float(float value);
  public:

  // required int32 v_int32 = 1 [default = -42];
  bool has_v_int32() const;
  private:
  bool _internal_has_v_int32() const;
  public:
  void clear_v_int32();
  int32_t v_int32() const;
  void set_v_int32(int32_t value);
  private:
  int32_t _internal_v_int32() const;
  void _internal_set_v_int32(int32_t value);
  public:

  // required uint32 v_uint32 = 2 [default = 666];
  bool has_v_uint32() const;
  private:
  bool _internal_has_v_uint32() const;
  public:
  void clear_v_uint32();
  uint32_t v_uint32() const;
  void set_v_uint32(uint32_t value);
  private:
  uint32_t _internal_v_uint32() const;
  void _internal_set_v_uint32(uint32_t value);
  public:

  // required int32 v_int64 = 3 [default = 100000];
  bool has_v_int64() const;
  private:
  bool _internal_has_v_int64() const;
  public:
  void clear_v_int64();
  int32_t v_int64() const;
  void set_v_int64(int32_t value);
  private:
  int32_t _internal_v_int64() const;
  void _internal_set_v_int64(int32_t value);
  public:

  // required uint32 v_uint64 = 4 [default = 100001];
  bool has_v_uint64() const;
  private:
  bool _internal_has_v_uint64() const;
  public:
  void clear_v_uint64();
  uint32_t v_uint64() const;
  void set_v_uint64(uint32_t value);
  private:
  uint32_t _internal_v_uint64() const;
  void _internal_set_v_uint64(uint32_t value);
  public:

  // required double v_double = 6 [default = 4.5];
  bool has_v_double() const;
  private:
  bool _internal_has_v_double() const;
  public:
  void clear_v_double();
  double v_double() const;
  void set_v_double(double value);
  private:
  double _internal_v_double() const;
  void _internal_set_v_double(double value);
  public:

  // @@protoc_insertion_point(class_scope:foo.DefaultRequiredValues)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_v_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_string_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_v_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_bytes_;
    float v_float_;
    int32_t v_int32_;
    uint32_t v_uint32_;
    int32_t v_int64_;
    uint32_t v_uint64_;
    double v_double_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class DefaultOptionalValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.DefaultOptionalValues) */ {
 public:
  inline DefaultOptionalValues() : DefaultOptionalValues(nullptr) {}
  ~DefaultOptionalValues() override;
  explicit PROTOBUF_CONSTEXPR DefaultOptionalValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultOptionalValues(const DefaultOptionalValues& from);
  DefaultOptionalValues(DefaultOptionalValues&& from) noexcept
    : DefaultOptionalValues() {
    *this = ::std::move(from);
  }

  inline DefaultOptionalValues& operator=(const DefaultOptionalValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultOptionalValues& operator=(DefaultOptionalValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultOptionalValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultOptionalValues* internal_default_instance() {
    return reinterpret_cast<const DefaultOptionalValues*>(
               &_DefaultOptionalValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DefaultOptionalValues& a, DefaultOptionalValues& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultOptionalValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultOptionalValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultOptionalValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultOptionalValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultOptionalValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultOptionalValues& from) {
    DefaultOptionalValues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultOptionalValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.DefaultOptionalValues";
  }
  protected:
  explicit DefaultOptionalValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVStringFieldNumber = 7,
    kVBytesFieldNumber = 8,
    kVFloatFieldNumber = 5,
    kVInt32FieldNumber = 1,
    kVUint32FieldNumber = 2,
    kVInt64FieldNumber = 3,
    kVUint64FieldNumber = 4,
    kVDoubleFieldNumber = 6,
  };
  // optional string v_string = 7 [default = "hi mom\n"];
  bool has_v_string() const;
  private:
  bool _internal_has_v_string() const;
  public:
  void clear_v_string();
  const std::string& v_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v_string();
  PROTOBUF_NODISCARD std::string* release_v_string();
  void set_allocated_v_string(std::string* v_string);
  private:
  const std::string& _internal_v_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v_string(const std::string& value);
  std::string* _internal_mutable_v_string();
  public:

  // optional bytes v_bytes = 8 [default = "a \000 character"];
  bool has_v_bytes() const;
  private:
  bool _internal_has_v_bytes() const;
  public:
  void clear_v_bytes();
  const std::string& v_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v_bytes();
  PROTOBUF_NODISCARD std::string* release_v_bytes();
  void set_allocated_v_bytes(std::string* v_bytes);
  private:
  const std::string& _internal_v_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v_bytes(const std::string& value);
  std::string* _internal_mutable_v_bytes();
  public:

  // optional float v_float = 5 [default = 2.5];
  bool has_v_float() const;
  private:
  bool _internal_has_v_float() const;
  public:
  void clear_v_float();
  float v_float() const;
  void set_v_float(float value);
  private:
  float _internal_v_float() const;
  void _internal_set_v_float(float value);
  public:

  // optional int32 v_int32 = 1 [default = -42];
  bool has_v_int32() const;
  private:
  bool _internal_has_v_int32() const;
  public:
  void clear_v_int32();
  int32_t v_int32() const;
  void set_v_int32(int32_t value);
  private:
  int32_t _internal_v_int32() const;
  void _internal_set_v_int32(int32_t value);
  public:

  // optional uint32 v_uint32 = 2 [default = 666];
  bool has_v_uint32() const;
  private:
  bool _internal_has_v_uint32() const;
  public:
  void clear_v_uint32();
  uint32_t v_uint32() const;
  void set_v_uint32(uint32_t value);
  private:
  uint32_t _internal_v_uint32() const;
  void _internal_set_v_uint32(uint32_t value);
  public:

  // optional int32 v_int64 = 3 [default = 100000];
  bool has_v_int64() const;
  private:
  bool _internal_has_v_int64() const;
  public:
  void clear_v_int64();
  int32_t v_int64() const;
  void set_v_int64(int32_t value);
  private:
  int32_t _internal_v_int64() const;
  void _internal_set_v_int64(int32_t value);
  public:

  // optional uint32 v_uint64 = 4 [default = 100001];
  bool has_v_uint64() const;
  private:
  bool _internal_has_v_uint64() const;
  public:
  void clear_v_uint64();
  uint32_t v_uint64() const;
  void set_v_uint64(uint32_t value);
  private:
  uint32_t _internal_v_uint64() const;
  void _internal_set_v_uint64(uint32_t value);
  public:

  // optional double v_double = 6 [default = 4.5];
  bool has_v_double() const;
  private:
  bool _internal_has_v_double() const;
  public:
  void clear_v_double();
  double v_double() const;
  void set_v_double(double value);
  private:
  double _internal_v_double() const;
  void _internal_set_v_double(double value);
  public:

  // @@protoc_insertion_point(class_scope:foo.DefaultOptionalValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_v_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_string_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_v_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_bytes_;
    float v_float_;
    int32_t v_int32_;
    uint32_t v_uint32_;
    int32_t v_int64_;
    uint32_t v_uint64_;
    double v_double_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class LowerCase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.LowerCase) */ {
 public:
  inline LowerCase() : LowerCase(nullptr) {}
  ~LowerCase() override;
  explicit PROTOBUF_CONSTEXPR LowerCase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LowerCase(const LowerCase& from);
  LowerCase(LowerCase&& from) noexcept
    : LowerCase() {
    *this = ::std::move(from);
  }

  inline LowerCase& operator=(const LowerCase& from) {
    CopyFrom(from);
    return *this;
  }
  inline LowerCase& operator=(LowerCase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LowerCase& default_instance() {
    return *internal_default_instance();
  }
  static inline const LowerCase* internal_default_instance() {
    return reinterpret_cast<const LowerCase*>(
               &_LowerCase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(LowerCase& a, LowerCase& b) {
    a.Swap(&b);
  }
  inline void Swap(LowerCase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LowerCase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LowerCase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LowerCase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LowerCase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LowerCase& from) {
    LowerCase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LowerCase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.LowerCase";
  }
  protected:
  explicit LowerCase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LowerCase_CaseEnum CaseEnum;
  static constexpr CaseEnum UPPER =
    LowerCase_CaseEnum_UPPER;
  static constexpr CaseEnum lower =
    LowerCase_CaseEnum_lower;
  static inline bool CaseEnum_IsValid(int value) {
    return LowerCase_CaseEnum_IsValid(value);
  }
  static constexpr CaseEnum CaseEnum_MIN =
    LowerCase_CaseEnum_CaseEnum_MIN;
  static constexpr CaseEnum CaseEnum_MAX =
    LowerCase_CaseEnum_CaseEnum_MAX;
  static constexpr int CaseEnum_ARRAYSIZE =
    LowerCase_CaseEnum_CaseEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CaseEnum_descriptor() {
    return LowerCase_CaseEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& CaseEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CaseEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CaseEnum_Name.");
    return LowerCase_CaseEnum_Name(enum_t_value);
  }
  static inline bool CaseEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CaseEnum* value) {
    return LowerCase_CaseEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .foo.LowerCase.CaseEnum value = 1 [default = lower];
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::foo::LowerCase_CaseEnum value() const;
  void set_value(::foo::LowerCase_CaseEnum value);
  private:
  ::foo::LowerCase_CaseEnum _internal_value() const;
  void _internal_set_value(::foo::LowerCase_CaseEnum value);
  public:

  // @@protoc_insertion_point(class_scope:foo.LowerCase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class AllocValues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.AllocValues) */ {
 public:
  inline AllocValues() : AllocValues(nullptr) {}
  ~AllocValues() override;
  explicit PROTOBUF_CONSTEXPR AllocValues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllocValues(const AllocValues& from);
  AllocValues(AllocValues&& from) noexcept
    : AllocValues() {
    *this = ::std::move(from);
  }

  inline AllocValues& operator=(const AllocValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocValues& operator=(AllocValues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocValues& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocValues* internal_default_instance() {
    return reinterpret_cast<const AllocValues*>(
               &_AllocValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(AllocValues& a, AllocValues& b) {
    a.Swap(&b);
  }
  inline void Swap(AllocValues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllocValues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllocValues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllocValues& from) {
    AllocValues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocValues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.AllocValues";
  }
  protected:
  explicit AllocValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRStringFieldNumber = 2,
    kOBytesFieldNumber = 1,
    kAStringFieldNumber = 3,
    kABytesFieldNumber = 4,
    kAMessFieldNumber = 5,
  };
  // repeated string r_string = 2;
  int r_string_size() const;
  private:
  int _internal_r_string_size() const;
  public:
  void clear_r_string();
  const std::string& r_string(int index) const;
  std::string* mutable_r_string(int index);
  void set_r_string(int index, const std::string& value);
  void set_r_string(int index, std::string&& value);
  void set_r_string(int index, const char* value);
  void set_r_string(int index, const char* value, size_t size);
  std::string* add_r_string();
  void add_r_string(const std::string& value);
  void add_r_string(std::string&& value);
  void add_r_string(const char* value);
  void add_r_string(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& r_string() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_r_string();
  private:
  const std::string& _internal_r_string(int index) const;
  std::string* _internal_add_r_string();
  public:

  // optional bytes o_bytes = 1;
  bool has_o_bytes() const;
  private:
  bool _internal_has_o_bytes() const;
  public:
  void clear_o_bytes();
  const std::string& o_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_o_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_o_bytes();
  PROTOBUF_NODISCARD std::string* release_o_bytes();
  void set_allocated_o_bytes(std::string* o_bytes);
  private:
  const std::string& _internal_o_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_o_bytes(const std::string& value);
  std::string* _internal_mutable_o_bytes();
  public:

  // required string a_string = 3;
  bool has_a_string() const;
  private:
  bool _internal_has_a_string() const;
  public:
  void clear_a_string();
  const std::string& a_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a_string();
  PROTOBUF_NODISCARD std::string* release_a_string();
  void set_allocated_a_string(std::string* a_string);
  private:
  const std::string& _internal_a_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a_string(const std::string& value);
  std::string* _internal_mutable_a_string();
  public:

  // required bytes a_bytes = 4;
  bool has_a_bytes() const;
  private:
  bool _internal_has_a_bytes() const;
  public:
  void clear_a_bytes();
  const std::string& a_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a_bytes();
  PROTOBUF_NODISCARD std::string* release_a_bytes();
  void set_allocated_a_bytes(std::string* a_bytes);
  private:
  const std::string& _internal_a_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a_bytes(const std::string& value);
  std::string* _internal_mutable_a_bytes();
  public:

  // required .foo.DefaultRequiredValues a_mess = 5;
  bool has_a_mess() const;
  private:
  bool _internal_has_a_mess() const;
  public:
  void clear_a_mess();
  const ::foo::DefaultRequiredValues& a_mess() const;
  PROTOBUF_NODISCARD ::foo::DefaultRequiredValues* release_a_mess();
  ::foo::DefaultRequiredValues* mutable_a_mess();
  void set_allocated_a_mess(::foo::DefaultRequiredValues* a_mess);
  private:
  const ::foo::DefaultRequiredValues& _internal_a_mess() const;
  ::foo::DefaultRequiredValues* _internal_mutable_a_mess();
  public:
  void unsafe_arena_set_allocated_a_mess(
      ::foo::DefaultRequiredValues* a_mess);
  ::foo::DefaultRequiredValues* unsafe_arena_release_a_mess();

  // @@protoc_insertion_point(class_scope:foo.AllocValues)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> r_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr o_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_bytes_;
    ::foo::DefaultRequiredValues* a_mess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestRequiredFieldsBitmap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestRequiredFieldsBitmap) */ {
 public:
  inline TestRequiredFieldsBitmap() : TestRequiredFieldsBitmap(nullptr) {}
  ~TestRequiredFieldsBitmap() override;
  explicit PROTOBUF_CONSTEXPR TestRequiredFieldsBitmap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestRequiredFieldsBitmap(const TestRequiredFieldsBitmap& from);
  TestRequiredFieldsBitmap(TestRequiredFieldsBitmap&& from) noexcept
    : TestRequiredFieldsBitmap() {
    *this = ::std::move(from);
  }

  inline TestRequiredFieldsBitmap& operator=(const TestRequiredFieldsBitmap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRequiredFieldsBitmap& operator=(TestRequiredFieldsBitmap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRequiredFieldsBitmap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRequiredFieldsBitmap* internal_default_instance() {
    return reinterpret_cast<const TestRequiredFieldsBitmap*>(
               &_TestRequiredFieldsBitmap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TestRequiredFieldsBitmap& a, TestRequiredFieldsBitmap& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRequiredFieldsBitmap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRequiredFieldsBitmap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRequiredFieldsBitmap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRequiredFieldsBitmap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestRequiredFieldsBitmap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestRequiredFieldsBitmap& from) {
    TestRequiredFieldsBitmap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRequiredFieldsBitmap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestRequiredFieldsBitmap";
  }
  protected:
  explicit TestRequiredFieldsBitmap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kField1FieldNumber = 1,
    kField2FieldNumber = 2,
    kField3FieldNumber = 3,
    kField4FieldNumber = 4,
    kField5FieldNumber = 5,
    kField6FieldNumber = 6,
    kField7FieldNumber = 7,
    kField8FieldNumber = 8,
    kField9FieldNumber = 9,
    kField10FieldNumber = 10,
    kField11FieldNumber = 11,
    kField12FieldNumber = 12,
    kField13FieldNumber = 13,
    kField14FieldNumber = 14,
    kField15FieldNumber = 15,
    kField16FieldNumber = 16,
    kField17FieldNumber = 17,
    kField18FieldNumber = 18,
    kField19FieldNumber = 19,
    kField20FieldNumber = 20,
    kField21FieldNumber = 21,
    kField22FieldNumber = 22,
    kField23FieldNumber = 23,
    kField24FieldNumber = 24,
    kField25FieldNumber = 25,
    kField26FieldNumber = 26,
    kField27FieldNumber = 27,
    kField28FieldNumber = 28,
    kField29FieldNumber = 29,
    kField30FieldNumber = 30,
    kField31FieldNumber = 31,
    kField32FieldNumber = 32,
    kField33FieldNumber = 33,
    kField34FieldNumber = 34,
    kField35FieldNumber = 35,
    kField36FieldNumber = 36,
    kField37FieldNumber = 37,
    kField38FieldNumber = 38,
    kField39FieldNumber = 39,
    kField40FieldNumber = 40,
    kField41FieldNumber = 41,
    kField42FieldNumber = 42,
    kField43FieldNumber = 43,
    kField44FieldNumber = 44,
    kField45FieldNumber = 45,
    kField46FieldNumber = 46,
    kField47FieldNumber = 47,
    kField48FieldNumber = 48,
    kField49FieldNumber = 49,
    kField50FieldNumber = 50,
    kField51FieldNumber = 51,
    kField52FieldNumber = 52,
    kField53FieldNumber = 53,
    kField54FieldNumber = 54,
    kField55FieldNumber = 55,
    kField56FieldNumber = 56,
    kField57FieldNumber = 57,
    kField58FieldNumber = 58,
    kField59FieldNumber = 59,
    kField60FieldNumber = 60,
    kField61FieldNumber = 61,
    kField62FieldNumber = 62,
    kField63FieldNumber = 63,
    kField64FieldNumber = 64,
    kField65FieldNumber = 65,
    kField66FieldNumber = 66,
    kField67FieldNumber = 67,
    kField68FieldNumber = 68,
    kField69FieldNumber = 69,
    kField70FieldNumber = 70,
    kField71FieldNumber = 71,
    kField72FieldNumber = 72,
    kField73FieldNumber = 73,
    kField74FieldNumber = 74,
    kField75FieldNumber = 75,
    kField76FieldNumber = 76,
    kField77FieldNumber = 77,
    kField78FieldNumber = 78,
    kField79FieldNumber = 79,
    kField80FieldNumber = 80,
    kField81FieldNumber = 81,
    kField82FieldNumber = 82,
    kField83FieldNumber = 83,
    kField84FieldNumber = 84,
    kField85FieldNumber = 85,
    kField86FieldNumber = 86,
    kField87FieldNumber = 87,
    kField88FieldNumber = 88,
    kField89FieldNumber = 89,
    kField90FieldNumber = 90,
    kField91FieldNumber = 91,
    kField92FieldNumber = 92,
    kField93FieldNumber = 93,
    kField94FieldNumber = 94,
    kField95FieldNumber = 95,
    kField96FieldNumber = 96,
    kField97FieldNumber = 97,
    kField98FieldNumber = 98,
    kField99FieldNumber = 99,
    kField100FieldNumber = 100,
    kField101FieldNumber = 101,
    kField102FieldNumber = 102,
    kField103FieldNumber = 103,
    kField104FieldNumber = 104,
    kField105FieldNumber = 105,
    kField106FieldNumber = 106,
    kField107FieldNumber = 107,
    kField108FieldNumber = 108,
    kField109FieldNumber = 109,
    kField110FieldNumber = 110,
    kField111FieldNumber = 111,
    kField112FieldNumber = 112,
    kField113FieldNumber = 113,
    kField114FieldNumber = 114,
    kField115FieldNumber = 115,
    kField116FieldNumber = 116,
    kField117FieldNumber = 117,
    kField118FieldNumber = 118,
    kField119FieldNumber = 119,
    kField120FieldNumber = 120,
    kField121FieldNumber = 121,
    kField122FieldNumber = 122,
    kField123FieldNumber = 123,
    kField124FieldNumber = 124,
    kField125FieldNumber = 125,
    kField126FieldNumber = 126,
    kField127FieldNumber = 127,
    kField128FieldNumber = 128,
    kField129FieldNumber = 129,
  };
  // required string field1 = 1;
  bool has_field1() const;
  private:
  bool _internal_has_field1() const;
  public:
  void clear_field1();
  const std::string& field1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field1();
  PROTOBUF_NODISCARD std::string* release_field1();
  void set_allocated_field1(std::string* field1);
  private:
  const std::string& _internal_field1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field1(const std::string& value);
  std::string* _internal_mutable_field1();
  public:

  // optional string field2 = 2;
  bool has_field2() const;
  private:
  bool _internal_has_field2() const;
  public:
  void clear_field2();
  const std::string& field2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field2();
  PROTOBUF_NODISCARD std::string* release_field2();
  void set_allocated_field2(std::string* field2);
  private:
  const std::string& _internal_field2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field2(const std::string& value);
  std::string* _internal_mutable_field2();
  public:

  // optional string field3 = 3;
  bool has_field3() const;
  private:
  bool _internal_has_field3() const;
  public:
  void clear_field3();
  const std::string& field3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field3();
  PROTOBUF_NODISCARD std::string* release_field3();
  void set_allocated_field3(std::string* field3);
  private:
  const std::string& _internal_field3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field3(const std::string& value);
  std::string* _internal_mutable_field3();
  public:

  // optional string field4 = 4;
  bool has_field4() const;
  private:
  bool _internal_has_field4() const;
  public:
  void clear_field4();
  const std::string& field4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field4();
  PROTOBUF_NODISCARD std::string* release_field4();
  void set_allocated_field4(std::string* field4);
  private:
  const std::string& _internal_field4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field4(const std::string& value);
  std::string* _internal_mutable_field4();
  public:

  // optional string field5 = 5;
  bool has_field5() const;
  private:
  bool _internal_has_field5() const;
  public:
  void clear_field5();
  const std::string& field5() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field5(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field5();
  PROTOBUF_NODISCARD std::string* release_field5();
  void set_allocated_field5(std::string* field5);
  private:
  const std::string& _internal_field5() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field5(const std::string& value);
  std::string* _internal_mutable_field5();
  public:

  // optional string field6 = 6;
  bool has_field6() const;
  private:
  bool _internal_has_field6() const;
  public:
  void clear_field6();
  const std::string& field6() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field6(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field6();
  PROTOBUF_NODISCARD std::string* release_field6();
  void set_allocated_field6(std::string* field6);
  private:
  const std::string& _internal_field6() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field6(const std::string& value);
  std::string* _internal_mutable_field6();
  public:

  // optional string field7 = 7;
  bool has_field7() const;
  private:
  bool _internal_has_field7() const;
  public:
  void clear_field7();
  const std::string& field7() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field7(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field7();
  PROTOBUF_NODISCARD std::string* release_field7();
  void set_allocated_field7(std::string* field7);
  private:
  const std::string& _internal_field7() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field7(const std::string& value);
  std::string* _internal_mutable_field7();
  public:

  // optional string field8 = 8;
  bool has_field8() const;
  private:
  bool _internal_has_field8() const;
  public:
  void clear_field8();
  const std::string& field8() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field8(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field8();
  PROTOBUF_NODISCARD std::string* release_field8();
  void set_allocated_field8(std::string* field8);
  private:
  const std::string& _internal_field8() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field8(const std::string& value);
  std::string* _internal_mutable_field8();
  public:

  // optional string field9 = 9;
  bool has_field9() const;
  private:
  bool _internal_has_field9() const;
  public:
  void clear_field9();
  const std::string& field9() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field9(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field9();
  PROTOBUF_NODISCARD std::string* release_field9();
  void set_allocated_field9(std::string* field9);
  private:
  const std::string& _internal_field9() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field9(const std::string& value);
  std::string* _internal_mutable_field9();
  public:

  // optional string field10 = 10;
  bool has_field10() const;
  private:
  bool _internal_has_field10() const;
  public:
  void clear_field10();
  const std::string& field10() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field10(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field10();
  PROTOBUF_NODISCARD std::string* release_field10();
  void set_allocated_field10(std::string* field10);
  private:
  const std::string& _internal_field10() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field10(const std::string& value);
  std::string* _internal_mutable_field10();
  public:

  // optional string field11 = 11;
  bool has_field11() const;
  private:
  bool _internal_has_field11() const;
  public:
  void clear_field11();
  const std::string& field11() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field11(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field11();
  PROTOBUF_NODISCARD std::string* release_field11();
  void set_allocated_field11(std::string* field11);
  private:
  const std::string& _internal_field11() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field11(const std::string& value);
  std::string* _internal_mutable_field11();
  public:

  // optional string field12 = 12;
  bool has_field12() const;
  private:
  bool _internal_has_field12() const;
  public:
  void clear_field12();
  const std::string& field12() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field12(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field12();
  PROTOBUF_NODISCARD std::string* release_field12();
  void set_allocated_field12(std::string* field12);
  private:
  const std::string& _internal_field12() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field12(const std::string& value);
  std::string* _internal_mutable_field12();
  public:

  // optional string field13 = 13;
  bool has_field13() const;
  private:
  bool _internal_has_field13() const;
  public:
  void clear_field13();
  const std::string& field13() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field13(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field13();
  PROTOBUF_NODISCARD std::string* release_field13();
  void set_allocated_field13(std::string* field13);
  private:
  const std::string& _internal_field13() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field13(const std::string& value);
  std::string* _internal_mutable_field13();
  public:

  // optional string field14 = 14;
  bool has_field14() const;
  private:
  bool _internal_has_field14() const;
  public:
  void clear_field14();
  const std::string& field14() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field14(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field14();
  PROTOBUF_NODISCARD std::string* release_field14();
  void set_allocated_field14(std::string* field14);
  private:
  const std::string& _internal_field14() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field14(const std::string& value);
  std::string* _internal_mutable_field14();
  public:

  // optional string field15 = 15;
  bool has_field15() const;
  private:
  bool _internal_has_field15() const;
  public:
  void clear_field15();
  const std::string& field15() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field15(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field15();
  PROTOBUF_NODISCARD std::string* release_field15();
  void set_allocated_field15(std::string* field15);
  private:
  const std::string& _internal_field15() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field15(const std::string& value);
  std::string* _internal_mutable_field15();
  public:

  // optional string field16 = 16;
  bool has_field16() const;
  private:
  bool _internal_has_field16() const;
  public:
  void clear_field16();
  const std::string& field16() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field16(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field16();
  PROTOBUF_NODISCARD std::string* release_field16();
  void set_allocated_field16(std::string* field16);
  private:
  const std::string& _internal_field16() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field16(const std::string& value);
  std::string* _internal_mutable_field16();
  public:

  // optional string field17 = 17;
  bool has_field17() const;
  private:
  bool _internal_has_field17() const;
  public:
  void clear_field17();
  const std::string& field17() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field17(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field17();
  PROTOBUF_NODISCARD std::string* release_field17();
  void set_allocated_field17(std::string* field17);
  private:
  const std::string& _internal_field17() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field17(const std::string& value);
  std::string* _internal_mutable_field17();
  public:

  // optional string field18 = 18;
  bool has_field18() const;
  private:
  bool _internal_has_field18() const;
  public:
  void clear_field18();
  const std::string& field18() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field18(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field18();
  PROTOBUF_NODISCARD std::string* release_field18();
  void set_allocated_field18(std::string* field18);
  private:
  const std::string& _internal_field18() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field18(const std::string& value);
  std::string* _internal_mutable_field18();
  public:

  // optional string field19 = 19;
  bool has_field19() const;
  private:
  bool _internal_has_field19() const;
  public:
  void clear_field19();
  const std::string& field19() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field19(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field19();
  PROTOBUF_NODISCARD std::string* release_field19();
  void set_allocated_field19(std::string* field19);
  private:
  const std::string& _internal_field19() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field19(const std::string& value);
  std::string* _internal_mutable_field19();
  public:

  // optional string field20 = 20;
  bool has_field20() const;
  private:
  bool _internal_has_field20() const;
  public:
  void clear_field20();
  const std::string& field20() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field20(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field20();
  PROTOBUF_NODISCARD std::string* release_field20();
  void set_allocated_field20(std::string* field20);
  private:
  const std::string& _internal_field20() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field20(const std::string& value);
  std::string* _internal_mutable_field20();
  public:

  // optional string field21 = 21;
  bool has_field21() const;
  private:
  bool _internal_has_field21() const;
  public:
  void clear_field21();
  const std::string& field21() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field21(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field21();
  PROTOBUF_NODISCARD std::string* release_field21();
  void set_allocated_field21(std::string* field21);
  private:
  const std::string& _internal_field21() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field21(const std::string& value);
  std::string* _internal_mutable_field21();
  public:

  // optional string field22 = 22;
  bool has_field22() const;
  private:
  bool _internal_has_field22() const;
  public:
  void clear_field22();
  const std::string& field22() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field22(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field22();
  PROTOBUF_NODISCARD std::string* release_field22();
  void set_allocated_field22(std::string* field22);
  private:
  const std::string& _internal_field22() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field22(const std::string& value);
  std::string* _internal_mutable_field22();
  public:

  // optional string field23 = 23;
  bool has_field23() const;
  private:
  bool _internal_has_field23() const;
  public:
  void clear_field23();
  const std::string& field23() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field23(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field23();
  PROTOBUF_NODISCARD std::string* release_field23();
  void set_allocated_field23(std::string* field23);
  private:
  const std::string& _internal_field23() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field23(const std::string& value);
  std::string* _internal_mutable_field23();
  public:

  // optional string field24 = 24;
  bool has_field24() const;
  private:
  bool _internal_has_field24() const;
  public:
  void clear_field24();
  const std::string& field24() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field24(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field24();
  PROTOBUF_NODISCARD std::string* release_field24();
  void set_allocated_field24(std::string* field24);
  private:
  const std::string& _internal_field24() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field24(const std::string& value);
  std::string* _internal_mutable_field24();
  public:

  // optional string field25 = 25;
  bool has_field25() const;
  private:
  bool _internal_has_field25() const;
  public:
  void clear_field25();
  const std::string& field25() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field25(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field25();
  PROTOBUF_NODISCARD std::string* release_field25();
  void set_allocated_field25(std::string* field25);
  private:
  const std::string& _internal_field25() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field25(const std::string& value);
  std::string* _internal_mutable_field25();
  public:

  // optional string field26 = 26;
  bool has_field26() const;
  private:
  bool _internal_has_field26() const;
  public:
  void clear_field26();
  const std::string& field26() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field26(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field26();
  PROTOBUF_NODISCARD std::string* release_field26();
  void set_allocated_field26(std::string* field26);
  private:
  const std::string& _internal_field26() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field26(const std::string& value);
  std::string* _internal_mutable_field26();
  public:

  // optional string field27 = 27;
  bool has_field27() const;
  private:
  bool _internal_has_field27() const;
  public:
  void clear_field27();
  const std::string& field27() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field27(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field27();
  PROTOBUF_NODISCARD std::string* release_field27();
  void set_allocated_field27(std::string* field27);
  private:
  const std::string& _internal_field27() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field27(const std::string& value);
  std::string* _internal_mutable_field27();
  public:

  // optional string field28 = 28;
  bool has_field28() const;
  private:
  bool _internal_has_field28() const;
  public:
  void clear_field28();
  const std::string& field28() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field28(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field28();
  PROTOBUF_NODISCARD std::string* release_field28();
  void set_allocated_field28(std::string* field28);
  private:
  const std::string& _internal_field28() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field28(const std::string& value);
  std::string* _internal_mutable_field28();
  public:

  // optional string field29 = 29;
  bool has_field29() const;
  private:
  bool _internal_has_field29() const;
  public:
  void clear_field29();
  const std::string& field29() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field29(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field29();
  PROTOBUF_NODISCARD std::string* release_field29();
  void set_allocated_field29(std::string* field29);
  private:
  const std::string& _internal_field29() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field29(const std::string& value);
  std::string* _internal_mutable_field29();
  public:

  // optional string field30 = 30;
  bool has_field30() const;
  private:
  bool _internal_has_field30() const;
  public:
  void clear_field30();
  const std::string& field30() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field30(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field30();
  PROTOBUF_NODISCARD std::string* release_field30();
  void set_allocated_field30(std::string* field30);
  private:
  const std::string& _internal_field30() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field30(const std::string& value);
  std::string* _internal_mutable_field30();
  public:

  // optional string field31 = 31;
  bool has_field31() const;
  private:
  bool _internal_has_field31() const;
  public:
  void clear_field31();
  const std::string& field31() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field31(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field31();
  PROTOBUF_NODISCARD std::string* release_field31();
  void set_allocated_field31(std::string* field31);
  private:
  const std::string& _internal_field31() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field31(const std::string& value);
  std::string* _internal_mutable_field31();
  public:

  // optional string field32 = 32;
  bool has_field32() const;
  private:
  bool _internal_has_field32() const;
  public:
  void clear_field32();
  const std::string& field32() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field32(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field32();
  PROTOBUF_NODISCARD std::string* release_field32();
  void set_allocated_field32(std::string* field32);
  private:
  const std::string& _internal_field32() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field32(const std::string& value);
  std::string* _internal_mutable_field32();
  public:

  // optional string field33 = 33;
  bool has_field33() const;
  private:
  bool _internal_has_field33() const;
  public:
  void clear_field33();
  const std::string& field33() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field33(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field33();
  PROTOBUF_NODISCARD std::string* release_field33();
  void set_allocated_field33(std::string* field33);
  private:
  const std::string& _internal_field33() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field33(const std::string& value);
  std::string* _internal_mutable_field33();
  public:

  // optional string field34 = 34;
  bool has_field34() const;
  private:
  bool _internal_has_field34() const;
  public:
  void clear_field34();
  const std::string& field34() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field34(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field34();
  PROTOBUF_NODISCARD std::string* release_field34();
  void set_allocated_field34(std::string* field34);
  private:
  const std::string& _internal_field34() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field34(const std::string& value);
  std::string* _internal_mutable_field34();
  public:

  // optional string field35 = 35;
  bool has_field35() const;
  private:
  bool _internal_has_field35() const;
  public:
  void clear_field35();
  const std::string& field35() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field35(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field35();
  PROTOBUF_NODISCARD std::string* release_field35();
  void set_allocated_field35(std::string* field35);
  private:
  const std::string& _internal_field35() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field35(const std::string& value);
  std::string* _internal_mutable_field35();
  public:

  // optional string field36 = 36;
  bool has_field36() const;
  private:
  bool _internal_has_field36() const;
  public:
  void clear_field36();
  const std::string& field36() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field36(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field36();
  PROTOBUF_NODISCARD std::string* release_field36();
  void set_allocated_field36(std::string* field36);
  private:
  const std::string& _internal_field36() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field36(const std::string& value);
  std::string* _internal_mutable_field36();
  public:

  // optional string field37 = 37;
  bool has_field37() const;
  private:
  bool _internal_has_field37() const;
  public:
  void clear_field37();
  const std::string& field37() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field37(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field37();
  PROTOBUF_NODISCARD std::string* release_field37();
  void set_allocated_field37(std::string* field37);
  private:
  const std::string& _internal_field37() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field37(const std::string& value);
  std::string* _internal_mutable_field37();
  public:

  // optional string field38 = 38;
  bool has_field38() const;
  private:
  bool _internal_has_field38() const;
  public:
  void clear_field38();
  const std::string& field38() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field38(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field38();
  PROTOBUF_NODISCARD std::string* release_field38();
  void set_allocated_field38(std::string* field38);
  private:
  const std::string& _internal_field38() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field38(const std::string& value);
  std::string* _internal_mutable_field38();
  public:

  // optional string field39 = 39;
  bool has_field39() const;
  private:
  bool _internal_has_field39() const;
  public:
  void clear_field39();
  const std::string& field39() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field39(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field39();
  PROTOBUF_NODISCARD std::string* release_field39();
  void set_allocated_field39(std::string* field39);
  private:
  const std::string& _internal_field39() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field39(const std::string& value);
  std::string* _internal_mutable_field39();
  public:

  // optional string field40 = 40;
  bool has_field40() const;
  private:
  bool _internal_has_field40() const;
  public:
  void clear_field40();
  const std::string& field40() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field40(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field40();
  PROTOBUF_NODISCARD std::string* release_field40();
  void set_allocated_field40(std::string* field40);
  private:
  const std::string& _internal_field40() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field40(const std::string& value);
  std::string* _internal_mutable_field40();
  public:

  // optional string field41 = 41;
  bool has_field41() const;
  private:
  bool _internal_has_field41() const;
  public:
  void clear_field41();
  const std::string& field41() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field41(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field41();
  PROTOBUF_NODISCARD std::string* release_field41();
  void set_allocated_field41(std::string* field41);
  private:
  const std::string& _internal_field41() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field41(const std::string& value);
  std::string* _internal_mutable_field41();
  public:

  // optional string field42 = 42;
  bool has_field42() const;
  private:
  bool _internal_has_field42() const;
  public:
  void clear_field42();
  const std::string& field42() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field42(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field42();
  PROTOBUF_NODISCARD std::string* release_field42();
  void set_allocated_field42(std::string* field42);
  private:
  const std::string& _internal_field42() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field42(const std::string& value);
  std::string* _internal_mutable_field42();
  public:

  // optional string field43 = 43;
  bool has_field43() const;
  private:
  bool _internal_has_field43() const;
  public:
  void clear_field43();
  const std::string& field43() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field43(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field43();
  PROTOBUF_NODISCARD std::string* release_field43();
  void set_allocated_field43(std::string* field43);
  private:
  const std::string& _internal_field43() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field43(const std::string& value);
  std::string* _internal_mutable_field43();
  public:

  // optional string field44 = 44;
  bool has_field44() const;
  private:
  bool _internal_has_field44() const;
  public:
  void clear_field44();
  const std::string& field44() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field44(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field44();
  PROTOBUF_NODISCARD std::string* release_field44();
  void set_allocated_field44(std::string* field44);
  private:
  const std::string& _internal_field44() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field44(const std::string& value);
  std::string* _internal_mutable_field44();
  public:

  // optional string field45 = 45;
  bool has_field45() const;
  private:
  bool _internal_has_field45() const;
  public:
  void clear_field45();
  const std::string& field45() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field45(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field45();
  PROTOBUF_NODISCARD std::string* release_field45();
  void set_allocated_field45(std::string* field45);
  private:
  const std::string& _internal_field45() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field45(const std::string& value);
  std::string* _internal_mutable_field45();
  public:

  // optional string field46 = 46;
  bool has_field46() const;
  private:
  bool _internal_has_field46() const;
  public:
  void clear_field46();
  const std::string& field46() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field46(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field46();
  PROTOBUF_NODISCARD std::string* release_field46();
  void set_allocated_field46(std::string* field46);
  private:
  const std::string& _internal_field46() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field46(const std::string& value);
  std::string* _internal_mutable_field46();
  public:

  // optional string field47 = 47;
  bool has_field47() const;
  private:
  bool _internal_has_field47() const;
  public:
  void clear_field47();
  const std::string& field47() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field47(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field47();
  PROTOBUF_NODISCARD std::string* release_field47();
  void set_allocated_field47(std::string* field47);
  private:
  const std::string& _internal_field47() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field47(const std::string& value);
  std::string* _internal_mutable_field47();
  public:

  // optional string field48 = 48;
  bool has_field48() const;
  private:
  bool _internal_has_field48() const;
  public:
  void clear_field48();
  const std::string& field48() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field48(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field48();
  PROTOBUF_NODISCARD std::string* release_field48();
  void set_allocated_field48(std::string* field48);
  private:
  const std::string& _internal_field48() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field48(const std::string& value);
  std::string* _internal_mutable_field48();
  public:

  // optional string field49 = 49;
  bool has_field49() const;
  private:
  bool _internal_has_field49() const;
  public:
  void clear_field49();
  const std::string& field49() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field49(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field49();
  PROTOBUF_NODISCARD std::string* release_field49();
  void set_allocated_field49(std::string* field49);
  private:
  const std::string& _internal_field49() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field49(const std::string& value);
  std::string* _internal_mutable_field49();
  public:

  // optional string field50 = 50;
  bool has_field50() const;
  private:
  bool _internal_has_field50() const;
  public:
  void clear_field50();
  const std::string& field50() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field50(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field50();
  PROTOBUF_NODISCARD std::string* release_field50();
  void set_allocated_field50(std::string* field50);
  private:
  const std::string& _internal_field50() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field50(const std::string& value);
  std::string* _internal_mutable_field50();
  public:

  // optional string field51 = 51;
  bool has_field51() const;
  private:
  bool _internal_has_field51() const;
  public:
  void clear_field51();
  const std::string& field51() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field51(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field51();
  PROTOBUF_NODISCARD std::string* release_field51();
  void set_allocated_field51(std::string* field51);
  private:
  const std::string& _internal_field51() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field51(const std::string& value);
  std::string* _internal_mutable_field51();
  public:

  // optional string field52 = 52;
  bool has_field52() const;
  private:
  bool _internal_has_field52() const;
  public:
  void clear_field52();
  const std::string& field52() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field52(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field52();
  PROTOBUF_NODISCARD std::string* release_field52();
  void set_allocated_field52(std::string* field52);
  private:
  const std::string& _internal_field52() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field52(const std::string& value);
  std::string* _internal_mutable_field52();
  public:

  // optional string field53 = 53;
  bool has_field53() const;
  private:
  bool _internal_has_field53() const;
  public:
  void clear_field53();
  const std::string& field53() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field53(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field53();
  PROTOBUF_NODISCARD std::string* release_field53();
  void set_allocated_field53(std::string* field53);
  private:
  const std::string& _internal_field53() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field53(const std::string& value);
  std::string* _internal_mutable_field53();
  public:

  // optional string field54 = 54;
  bool has_field54() const;
  private:
  bool _internal_has_field54() const;
  public:
  void clear_field54();
  const std::string& field54() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field54(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field54();
  PROTOBUF_NODISCARD std::string* release_field54();
  void set_allocated_field54(std::string* field54);
  private:
  const std::string& _internal_field54() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field54(const std::string& value);
  std::string* _internal_mutable_field54();
  public:

  // optional string field55 = 55;
  bool has_field55() const;
  private:
  bool _internal_has_field55() const;
  public:
  void clear_field55();
  const std::string& field55() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field55(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field55();
  PROTOBUF_NODISCARD std::string* release_field55();
  void set_allocated_field55(std::string* field55);
  private:
  const std::string& _internal_field55() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field55(const std::string& value);
  std::string* _internal_mutable_field55();
  public:

  // optional string field56 = 56;
  bool has_field56() const;
  private:
  bool _internal_has_field56() const;
  public:
  void clear_field56();
  const std::string& field56() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field56(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field56();
  PROTOBUF_NODISCARD std::string* release_field56();
  void set_allocated_field56(std::string* field56);
  private:
  const std::string& _internal_field56() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field56(const std::string& value);
  std::string* _internal_mutable_field56();
  public:

  // optional string field57 = 57;
  bool has_field57() const;
  private:
  bool _internal_has_field57() const;
  public:
  void clear_field57();
  const std::string& field57() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field57(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field57();
  PROTOBUF_NODISCARD std::string* release_field57();
  void set_allocated_field57(std::string* field57);
  private:
  const std::string& _internal_field57() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field57(const std::string& value);
  std::string* _internal_mutable_field57();
  public:

  // optional string field58 = 58;
  bool has_field58() const;
  private:
  bool _internal_has_field58() const;
  public:
  void clear_field58();
  const std::string& field58() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field58(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field58();
  PROTOBUF_NODISCARD std::string* release_field58();
  void set_allocated_field58(std::string* field58);
  private:
  const std::string& _internal_field58() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field58(const std::string& value);
  std::string* _internal_mutable_field58();
  public:

  // optional string field59 = 59;
  bool has_field59() const;
  private:
  bool _internal_has_field59() const;
  public:
  void clear_field59();
  const std::string& field59() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field59(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field59();
  PROTOBUF_NODISCARD std::string* release_field59();
  void set_allocated_field59(std::string* field59);
  private:
  const std::string& _internal_field59() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field59(const std::string& value);
  std::string* _internal_mutable_field59();
  public:

  // optional string field60 = 60;
  bool has_field60() const;
  private:
  bool _internal_has_field60() const;
  public:
  void clear_field60();
  const std::string& field60() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field60(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field60();
  PROTOBUF_NODISCARD std::string* release_field60();
  void set_allocated_field60(std::string* field60);
  private:
  const std::string& _internal_field60() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field60(const std::string& value);
  std::string* _internal_mutable_field60();
  public:

  // optional string field61 = 61;
  bool has_field61() const;
  private:
  bool _internal_has_field61() const;
  public:
  void clear_field61();
  const std::string& field61() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field61(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field61();
  PROTOBUF_NODISCARD std::string* release_field61();
  void set_allocated_field61(std::string* field61);
  private:
  const std::string& _internal_field61() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field61(const std::string& value);
  std::string* _internal_mutable_field61();
  public:

  // optional string field62 = 62;
  bool has_field62() const;
  private:
  bool _internal_has_field62() const;
  public:
  void clear_field62();
  const std::string& field62() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field62(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field62();
  PROTOBUF_NODISCARD std::string* release_field62();
  void set_allocated_field62(std::string* field62);
  private:
  const std::string& _internal_field62() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field62(const std::string& value);
  std::string* _internal_mutable_field62();
  public:

  // optional string field63 = 63;
  bool has_field63() const;
  private:
  bool _internal_has_field63() const;
  public:
  void clear_field63();
  const std::string& field63() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field63(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field63();
  PROTOBUF_NODISCARD std::string* release_field63();
  void set_allocated_field63(std::string* field63);
  private:
  const std::string& _internal_field63() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field63(const std::string& value);
  std::string* _internal_mutable_field63();
  public:

  // optional string field64 = 64;
  bool has_field64() const;
  private:
  bool _internal_has_field64() const;
  public:
  void clear_field64();
  const std::string& field64() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field64(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field64();
  PROTOBUF_NODISCARD std::string* release_field64();
  void set_allocated_field64(std::string* field64);
  private:
  const std::string& _internal_field64() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field64(const std::string& value);
  std::string* _internal_mutable_field64();
  public:

  // optional string field65 = 65;
  bool has_field65() const;
  private:
  bool _internal_has_field65() const;
  public:
  void clear_field65();
  const std::string& field65() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field65(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field65();
  PROTOBUF_NODISCARD std::string* release_field65();
  void set_allocated_field65(std::string* field65);
  private:
  const std::string& _internal_field65() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field65(const std::string& value);
  std::string* _internal_mutable_field65();
  public:

  // optional string field66 = 66;
  bool has_field66() const;
  private:
  bool _internal_has_field66() const;
  public:
  void clear_field66();
  const std::string& field66() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field66(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field66();
  PROTOBUF_NODISCARD std::string* release_field66();
  void set_allocated_field66(std::string* field66);
  private:
  const std::string& _internal_field66() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field66(const std::string& value);
  std::string* _internal_mutable_field66();
  public:

  // optional string field67 = 67;
  bool has_field67() const;
  private:
  bool _internal_has_field67() const;
  public:
  void clear_field67();
  const std::string& field67() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field67(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field67();
  PROTOBUF_NODISCARD std::string* release_field67();
  void set_allocated_field67(std::string* field67);
  private:
  const std::string& _internal_field67() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field67(const std::string& value);
  std::string* _internal_mutable_field67();
  public:

  // optional string field68 = 68;
  bool has_field68() const;
  private:
  bool _internal_has_field68() const;
  public:
  void clear_field68();
  const std::string& field68() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field68(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field68();
  PROTOBUF_NODISCARD std::string* release_field68();
  void set_allocated_field68(std::string* field68);
  private:
  const std::string& _internal_field68() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field68(const std::string& value);
  std::string* _internal_mutable_field68();
  public:

  // optional string field69 = 69;
  bool has_field69() const;
  private:
  bool _internal_has_field69() const;
  public:
  void clear_field69();
  const std::string& field69() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field69(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field69();
  PROTOBUF_NODISCARD std::string* release_field69();
  void set_allocated_field69(std::string* field69);
  private:
  const std::string& _internal_field69() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field69(const std::string& value);
  std::string* _internal_mutable_field69();
  public:

  // optional string field70 = 70;
  bool has_field70() const;
  private:
  bool _internal_has_field70() const;
  public:
  void clear_field70();
  const std::string& field70() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field70(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field70();
  PROTOBUF_NODISCARD std::string* release_field70();
  void set_allocated_field70(std::string* field70);
  private:
  const std::string& _internal_field70() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field70(const std::string& value);
  std::string* _internal_mutable_field70();
  public:

  // optional string field71 = 71;
  bool has_field71() const;
  private:
  bool _internal_has_field71() const;
  public:
  void clear_field71();
  const std::string& field71() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field71(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field71();
  PROTOBUF_NODISCARD std::string* release_field71();
  void set_allocated_field71(std::string* field71);
  private:
  const std::string& _internal_field71() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field71(const std::string& value);
  std::string* _internal_mutable_field71();
  public:

  // optional string field72 = 72;
  bool has_field72() const;
  private:
  bool _internal_has_field72() const;
  public:
  void clear_field72();
  const std::string& field72() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field72(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field72();
  PROTOBUF_NODISCARD std::string* release_field72();
  void set_allocated_field72(std::string* field72);
  private:
  const std::string& _internal_field72() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field72(const std::string& value);
  std::string* _internal_mutable_field72();
  public:

  // optional string field73 = 73;
  bool has_field73() const;
  private:
  bool _internal_has_field73() const;
  public:
  void clear_field73();
  const std::string& field73() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field73(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field73();
  PROTOBUF_NODISCARD std::string* release_field73();
  void set_allocated_field73(std::string* field73);
  private:
  const std::string& _internal_field73() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field73(const std::string& value);
  std::string* _internal_mutable_field73();
  public:

  // optional string field74 = 74;
  bool has_field74() const;
  private:
  bool _internal_has_field74() const;
  public:
  void clear_field74();
  const std::string& field74() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field74(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field74();
  PROTOBUF_NODISCARD std::string* release_field74();
  void set_allocated_field74(std::string* field74);
  private:
  const std::string& _internal_field74() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field74(const std::string& value);
  std::string* _internal_mutable_field74();
  public:

  // optional string field75 = 75;
  bool has_field75() const;
  private:
  bool _internal_has_field75() const;
  public:
  void clear_field75();
  const std::string& field75() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field75(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field75();
  PROTOBUF_NODISCARD std::string* release_field75();
  void set_allocated_field75(std::string* field75);
  private:
  const std::string& _internal_field75() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field75(const std::string& value);
  std::string* _internal_mutable_field75();
  public:

  // optional string field76 = 76;
  bool has_field76() const;
  private:
  bool _internal_has_field76() const;
  public:
  void clear_field76();
  const std::string& field76() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field76(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field76();
  PROTOBUF_NODISCARD std::string* release_field76();
  void set_allocated_field76(std::string* field76);
  private:
  const std::string& _internal_field76() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field76(const std::string& value);
  std::string* _internal_mutable_field76();
  public:

  // optional string field77 = 77;
  bool has_field77() const;
  private:
  bool _internal_has_field77() const;
  public:
  void clear_field77();
  const std::string& field77() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field77(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field77();
  PROTOBUF_NODISCARD std::string* release_field77();
  void set_allocated_field77(std::string* field77);
  private:
  const std::string& _internal_field77() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field77(const std::string& value);
  std::string* _internal_mutable_field77();
  public:

  // optional string field78 = 78;
  bool has_field78() const;
  private:
  bool _internal_has_field78() const;
  public:
  void clear_field78();
  const std::string& field78() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field78(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field78();
  PROTOBUF_NODISCARD std::string* release_field78();
  void set_allocated_field78(std::string* field78);
  private:
  const std::string& _internal_field78() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field78(const std::string& value);
  std::string* _internal_mutable_field78();
  public:

  // optional string field79 = 79;
  bool has_field79() const;
  private:
  bool _internal_has_field79() const;
  public:
  void clear_field79();
  const std::string& field79() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field79(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field79();
  PROTOBUF_NODISCARD std::string* release_field79();
  void set_allocated_field79(std::string* field79);
  private:
  const std::string& _internal_field79() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field79(const std::string& value);
  std::string* _internal_mutable_field79();
  public:

  // optional string field80 = 80;
  bool has_field80() const;
  private:
  bool _internal_has_field80() const;
  public:
  void clear_field80();
  const std::string& field80() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field80(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field80();
  PROTOBUF_NODISCARD std::string* release_field80();
  void set_allocated_field80(std::string* field80);
  private:
  const std::string& _internal_field80() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field80(const std::string& value);
  std::string* _internal_mutable_field80();
  public:

  // optional string field81 = 81;
  bool has_field81() const;
  private:
  bool _internal_has_field81() const;
  public:
  void clear_field81();
  const std::string& field81() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field81(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field81();
  PROTOBUF_NODISCARD std::string* release_field81();
  void set_allocated_field81(std::string* field81);
  private:
  const std::string& _internal_field81() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field81(const std::string& value);
  std::string* _internal_mutable_field81();
  public:

  // optional string field82 = 82;
  bool has_field82() const;
  private:
  bool _internal_has_field82() const;
  public:
  void clear_field82();
  const std::string& field82() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field82(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field82();
  PROTOBUF_NODISCARD std::string* release_field82();
  void set_allocated_field82(std::string* field82);
  private:
  const std::string& _internal_field82() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field82(const std::string& value);
  std::string* _internal_mutable_field82();
  public:

  // optional string field83 = 83;
  bool has_field83() const;
  private:
  bool _internal_has_field83() const;
  public:
  void clear_field83();
  const std::string& field83() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field83(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field83();
  PROTOBUF_NODISCARD std::string* release_field83();
  void set_allocated_field83(std::string* field83);
  private:
  const std::string& _internal_field83() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field83(const std::string& value);
  std::string* _internal_mutable_field83();
  public:

  // optional string field84 = 84;
  bool has_field84() const;
  private:
  bool _internal_has_field84() const;
  public:
  void clear_field84();
  const std::string& field84() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field84(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field84();
  PROTOBUF_NODISCARD std::string* release_field84();
  void set_allocated_field84(std::string* field84);
  private:
  const std::string& _internal_field84() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field84(const std::string& value);
  std::string* _internal_mutable_field84();
  public:

  // optional string field85 = 85;
  bool has_field85() const;
  private:
  bool _internal_has_field85() const;
  public:
  void clear_field85();
  const std::string& field85() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field85(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field85();
  PROTOBUF_NODISCARD std::string* release_field85();
  void set_allocated_field85(std::string* field85);
  private:
  const std::string& _internal_field85() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field85(const std::string& value);
  std::string* _internal_mutable_field85();
  public:

  // optional string field86 = 86;
  bool has_field86() const;
  private:
  bool _internal_has_field86() const;
  public:
  void clear_field86();
  const std::string& field86() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field86(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field86();
  PROTOBUF_NODISCARD std::string* release_field86();
  void set_allocated_field86(std::string* field86);
  private:
  const std::string& _internal_field86() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field86(const std::string& value);
  std::string* _internal_mutable_field86();
  public:

  // optional string field87 = 87;
  bool has_field87() const;
  private:
  bool _internal_has_field87() const;
  public:
  void clear_field87();
  const std::string& field87() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field87(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field87();
  PROTOBUF_NODISCARD std::string* release_field87();
  void set_allocated_field87(std::string* field87);
  private:
  const std::string& _internal_field87() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field87(const std::string& value);
  std::string* _internal_mutable_field87();
  public:

  // optional string field88 = 88;
  bool has_field88() const;
  private:
  bool _internal_has_field88() const;
  public:
  void clear_field88();
  const std::string& field88() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field88(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field88();
  PROTOBUF_NODISCARD std::string* release_field88();
  void set_allocated_field88(std::string* field88);
  private:
  const std::string& _internal_field88() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field88(const std::string& value);
  std::string* _internal_mutable_field88();
  public:

  // optional string field89 = 89;
  bool has_field89() const;
  private:
  bool _internal_has_field89() const;
  public:
  void clear_field89();
  const std::string& field89() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field89(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field89();
  PROTOBUF_NODISCARD std::string* release_field89();
  void set_allocated_field89(std::string* field89);
  private:
  const std::string& _internal_field89() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field89(const std::string& value);
  std::string* _internal_mutable_field89();
  public:

  // optional string field90 = 90;
  bool has_field90() const;
  private:
  bool _internal_has_field90() const;
  public:
  void clear_field90();
  const std::string& field90() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field90(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field90();
  PROTOBUF_NODISCARD std::string* release_field90();
  void set_allocated_field90(std::string* field90);
  private:
  const std::string& _internal_field90() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field90(const std::string& value);
  std::string* _internal_mutable_field90();
  public:

  // optional string field91 = 91;
  bool has_field91() const;
  private:
  bool _internal_has_field91() const;
  public:
  void clear_field91();
  const std::string& field91() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field91(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field91();
  PROTOBUF_NODISCARD std::string* release_field91();
  void set_allocated_field91(std::string* field91);
  private:
  const std::string& _internal_field91() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field91(const std::string& value);
  std::string* _internal_mutable_field91();
  public:

  // optional string field92 = 92;
  bool has_field92() const;
  private:
  bool _internal_has_field92() const;
  public:
  void clear_field92();
  const std::string& field92() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field92(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field92();
  PROTOBUF_NODISCARD std::string* release_field92();
  void set_allocated_field92(std::string* field92);
  private:
  const std::string& _internal_field92() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field92(const std::string& value);
  std::string* _internal_mutable_field92();
  public:

  // optional string field93 = 93;
  bool has_field93() const;
  private:
  bool _internal_has_field93() const;
  public:
  void clear_field93();
  const std::string& field93() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field93(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field93();
  PROTOBUF_NODISCARD std::string* release_field93();
  void set_allocated_field93(std::string* field93);
  private:
  const std::string& _internal_field93() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field93(const std::string& value);
  std::string* _internal_mutable_field93();
  public:

  // optional string field94 = 94;
  bool has_field94() const;
  private:
  bool _internal_has_field94() const;
  public:
  void clear_field94();
  const std::string& field94() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field94(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field94();
  PROTOBUF_NODISCARD std::string* release_field94();
  void set_allocated_field94(std::string* field94);
  private:
  const std::string& _internal_field94() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field94(const std::string& value);
  std::string* _internal_mutable_field94();
  public:

  // optional string field95 = 95;
  bool has_field95() const;
  private:
  bool _internal_has_field95() const;
  public:
  void clear_field95();
  const std::string& field95() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field95(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field95();
  PROTOBUF_NODISCARD std::string* release_field95();
  void set_allocated_field95(std::string* field95);
  private:
  const std::string& _internal_field95() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field95(const std::string& value);
  std::string* _internal_mutable_field95();
  public:

  // optional string field96 = 96;
  bool has_field96() const;
  private:
  bool _internal_has_field96() const;
  public:
  void clear_field96();
  const std::string& field96() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field96(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field96();
  PROTOBUF_NODISCARD std::string* release_field96();
  void set_allocated_field96(std::string* field96);
  private:
  const std::string& _internal_field96() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field96(const std::string& value);
  std::string* _internal_mutable_field96();
  public:

  // optional string field97 = 97;
  bool has_field97() const;
  private:
  bool _internal_has_field97() const;
  public:
  void clear_field97();
  const std::string& field97() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field97(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field97();
  PROTOBUF_NODISCARD std::string* release_field97();
  void set_allocated_field97(std::string* field97);
  private:
  const std::string& _internal_field97() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field97(const std::string& value);
  std::string* _internal_mutable_field97();
  public:

  // optional string field98 = 98;
  bool has_field98() const;
  private:
  bool _internal_has_field98() const;
  public:
  void clear_field98();
  const std::string& field98() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field98(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field98();
  PROTOBUF_NODISCARD std::string* release_field98();
  void set_allocated_field98(std::string* field98);
  private:
  const std::string& _internal_field98() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field98(const std::string& value);
  std::string* _internal_mutable_field98();
  public:

  // optional string field99 = 99;
  bool has_field99() const;
  private:
  bool _internal_has_field99() const;
  public:
  void clear_field99();
  const std::string& field99() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field99(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field99();
  PROTOBUF_NODISCARD std::string* release_field99();
  void set_allocated_field99(std::string* field99);
  private:
  const std::string& _internal_field99() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field99(const std::string& value);
  std::string* _internal_mutable_field99();
  public:

  // optional string field100 = 100;
  bool has_field100() const;
  private:
  bool _internal_has_field100() const;
  public:
  void clear_field100();
  const std::string& field100() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field100(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field100();
  PROTOBUF_NODISCARD std::string* release_field100();
  void set_allocated_field100(std::string* field100);
  private:
  const std::string& _internal_field100() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field100(const std::string& value);
  std::string* _internal_mutable_field100();
  public:

  // optional string field101 = 101;
  bool has_field101() const;
  private:
  bool _internal_has_field101() const;
  public:
  void clear_field101();
  const std::string& field101() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field101(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field101();
  PROTOBUF_NODISCARD std::string* release_field101();
  void set_allocated_field101(std::string* field101);
  private:
  const std::string& _internal_field101() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field101(const std::string& value);
  std::string* _internal_mutable_field101();
  public:

  // optional string field102 = 102;
  bool has_field102() const;
  private:
  bool _internal_has_field102() const;
  public:
  void clear_field102();
  const std::string& field102() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field102(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field102();
  PROTOBUF_NODISCARD std::string* release_field102();
  void set_allocated_field102(std::string* field102);
  private:
  const std::string& _internal_field102() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field102(const std::string& value);
  std::string* _internal_mutable_field102();
  public:

  // optional string field103 = 103;
  bool has_field103() const;
  private:
  bool _internal_has_field103() const;
  public:
  void clear_field103();
  const std::string& field103() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field103(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field103();
  PROTOBUF_NODISCARD std::string* release_field103();
  void set_allocated_field103(std::string* field103);
  private:
  const std::string& _internal_field103() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field103(const std::string& value);
  std::string* _internal_mutable_field103();
  public:

  // optional string field104 = 104;
  bool has_field104() const;
  private:
  bool _internal_has_field104() const;
  public:
  void clear_field104();
  const std::string& field104() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field104(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field104();
  PROTOBUF_NODISCARD std::string* release_field104();
  void set_allocated_field104(std::string* field104);
  private:
  const std::string& _internal_field104() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field104(const std::string& value);
  std::string* _internal_mutable_field104();
  public:

  // optional string field105 = 105;
  bool has_field105() const;
  private:
  bool _internal_has_field105() const;
  public:
  void clear_field105();
  const std::string& field105() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field105(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field105();
  PROTOBUF_NODISCARD std::string* release_field105();
  void set_allocated_field105(std::string* field105);
  private:
  const std::string& _internal_field105() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field105(const std::string& value);
  std::string* _internal_mutable_field105();
  public:

  // optional string field106 = 106;
  bool has_field106() const;
  private:
  bool _internal_has_field106() const;
  public:
  void clear_field106();
  const std::string& field106() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field106(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field106();
  PROTOBUF_NODISCARD std::string* release_field106();
  void set_allocated_field106(std::string* field106);
  private:
  const std::string& _internal_field106() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field106(const std::string& value);
  std::string* _internal_mutable_field106();
  public:

  // optional string field107 = 107;
  bool has_field107() const;
  private:
  bool _internal_has_field107() const;
  public:
  void clear_field107();
  const std::string& field107() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field107(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field107();
  PROTOBUF_NODISCARD std::string* release_field107();
  void set_allocated_field107(std::string* field107);
  private:
  const std::string& _internal_field107() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field107(const std::string& value);
  std::string* _internal_mutable_field107();
  public:

  // optional string field108 = 108;
  bool has_field108() const;
  private:
  bool _internal_has_field108() const;
  public:
  void clear_field108();
  const std::string& field108() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field108(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field108();
  PROTOBUF_NODISCARD std::string* release_field108();
  void set_allocated_field108(std::string* field108);
  private:
  const std::string& _internal_field108() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field108(const std::string& value);
  std::string* _internal_mutable_field108();
  public:

  // optional string field109 = 109;
  bool has_field109() const;
  private:
  bool _internal_has_field109() const;
  public:
  void clear_field109();
  const std::string& field109() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field109(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field109();
  PROTOBUF_NODISCARD std::string* release_field109();
  void set_allocated_field109(std::string* field109);
  private:
  const std::string& _internal_field109() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field109(const std::string& value);
  std::string* _internal_mutable_field109();
  public:

  // optional string field110 = 110;
  bool has_field110() const;
  private:
  bool _internal_has_field110() const;
  public:
  void clear_field110();
  const std::string& field110() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field110(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field110();
  PROTOBUF_NODISCARD std::string* release_field110();
  void set_allocated_field110(std::string* field110);
  private:
  const std::string& _internal_field110() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field110(const std::string& value);
  std::string* _internal_mutable_field110();
  public:

  // optional string field111 = 111;
  bool has_field111() const;
  private:
  bool _internal_has_field111() const;
  public:
  void clear_field111();
  const std::string& field111() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field111(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field111();
  PROTOBUF_NODISCARD std::string* release_field111();
  void set_allocated_field111(std::string* field111);
  private:
  const std::string& _internal_field111() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field111(const std::string& value);
  std::string* _internal_mutable_field111();
  public:

  // optional string field112 = 112;
  bool has_field112() const;
  private:
  bool _internal_has_field112() const;
  public:
  void clear_field112();
  const std::string& field112() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field112(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field112();
  PROTOBUF_NODISCARD std::string* release_field112();
  void set_allocated_field112(std::string* field112);
  private:
  const std::string& _internal_field112() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field112(const std::string& value);
  std::string* _internal_mutable_field112();
  public:

  // optional string field113 = 113;
  bool has_field113() const;
  private:
  bool _internal_has_field113() const;
  public:
  void clear_field113();
  const std::string& field113() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field113(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field113();
  PROTOBUF_NODISCARD std::string* release_field113();
  void set_allocated_field113(std::string* field113);
  private:
  const std::string& _internal_field113() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field113(const std::string& value);
  std::string* _internal_mutable_field113();
  public:

  // optional string field114 = 114;
  bool has_field114() const;
  private:
  bool _internal_has_field114() const;
  public:
  void clear_field114();
  const std::string& field114() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field114(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field114();
  PROTOBUF_NODISCARD std::string* release_field114();
  void set_allocated_field114(std::string* field114);
  private:
  const std::string& _internal_field114() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field114(const std::string& value);
  std::string* _internal_mutable_field114();
  public:

  // optional string field115 = 115;
  bool has_field115() const;
  private:
  bool _internal_has_field115() const;
  public:
  void clear_field115();
  const std::string& field115() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field115(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field115();
  PROTOBUF_NODISCARD std::string* release_field115();
  void set_allocated_field115(std::string* field115);
  private:
  const std::string& _internal_field115() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field115(const std::string& value);
  std::string* _internal_mutable_field115();
  public:

  // optional string field116 = 116;
  bool has_field116() const;
  private:
  bool _internal_has_field116() const;
  public:
  void clear_field116();
  const std::string& field116() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field116(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field116();
  PROTOBUF_NODISCARD std::string* release_field116();
  void set_allocated_field116(std::string* field116);
  private:
  const std::string& _internal_field116() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field116(const std::string& value);
  std::string* _internal_mutable_field116();
  public:

  // optional string field117 = 117;
  bool has_field117() const;
  private:
  bool _internal_has_field117() const;
  public:
  void clear_field117();
  const std::string& field117() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field117(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field117();
  PROTOBUF_NODISCARD std::string* release_field117();
  void set_allocated_field117(std::string* field117);
  private:
  const std::string& _internal_field117() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field117(const std::string& value);
  std::string* _internal_mutable_field117();
  public:

  // optional string field118 = 118;
  bool has_field118() const;
  private:
  bool _internal_has_field118() const;
  public:
  void clear_field118();
  const std::string& field118() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field118(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field118();
  PROTOBUF_NODISCARD std::string* release_field118();
  void set_allocated_field118(std::string* field118);
  private:
  const std::string& _internal_field118() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field118(const std::string& value);
  std::string* _internal_mutable_field118();
  public:

  // optional string field119 = 119;
  bool has_field119() const;
  private:
  bool _internal_has_field119() const;
  public:
  void clear_field119();
  const std::string& field119() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field119(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field119();
  PROTOBUF_NODISCARD std::string* release_field119();
  void set_allocated_field119(std::string* field119);
  private:
  const std::string& _internal_field119() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field119(const std::string& value);
  std::string* _internal_mutable_field119();
  public:

  // optional string field120 = 120;
  bool has_field120() const;
  private:
  bool _internal_has_field120() const;
  public:
  void clear_field120();
  const std::string& field120() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field120(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field120();
  PROTOBUF_NODISCARD std::string* release_field120();
  void set_allocated_field120(std::string* field120);
  private:
  const std::string& _internal_field120() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field120(const std::string& value);
  std::string* _internal_mutable_field120();
  public:

  // optional string field121 = 121;
  bool has_field121() const;
  private:
  bool _internal_has_field121() const;
  public:
  void clear_field121();
  const std::string& field121() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field121(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field121();
  PROTOBUF_NODISCARD std::string* release_field121();
  void set_allocated_field121(std::string* field121);
  private:
  const std::string& _internal_field121() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field121(const std::string& value);
  std::string* _internal_mutable_field121();
  public:

  // optional string field122 = 122;
  bool has_field122() const;
  private:
  bool _internal_has_field122() const;
  public:
  void clear_field122();
  const std::string& field122() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field122(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field122();
  PROTOBUF_NODISCARD std::string* release_field122();
  void set_allocated_field122(std::string* field122);
  private:
  const std::string& _internal_field122() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field122(const std::string& value);
  std::string* _internal_mutable_field122();
  public:

  // optional string field123 = 123;
  bool has_field123() const;
  private:
  bool _internal_has_field123() const;
  public:
  void clear_field123();
  const std::string& field123() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field123(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field123();
  PROTOBUF_NODISCARD std::string* release_field123();
  void set_allocated_field123(std::string* field123);
  private:
  const std::string& _internal_field123() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field123(const std::string& value);
  std::string* _internal_mutable_field123();
  public:

  // optional string field124 = 124;
  bool has_field124() const;
  private:
  bool _internal_has_field124() const;
  public:
  void clear_field124();
  const std::string& field124() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field124(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field124();
  PROTOBUF_NODISCARD std::string* release_field124();
  void set_allocated_field124(std::string* field124);
  private:
  const std::string& _internal_field124() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field124(const std::string& value);
  std::string* _internal_mutable_field124();
  public:

  // optional string field125 = 125;
  bool has_field125() const;
  private:
  bool _internal_has_field125() const;
  public:
  void clear_field125();
  const std::string& field125() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field125(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field125();
  PROTOBUF_NODISCARD std::string* release_field125();
  void set_allocated_field125(std::string* field125);
  private:
  const std::string& _internal_field125() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field125(const std::string& value);
  std::string* _internal_mutable_field125();
  public:

  // optional string field126 = 126;
  bool has_field126() const;
  private:
  bool _internal_has_field126() const;
  public:
  void clear_field126();
  const std::string& field126() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field126(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field126();
  PROTOBUF_NODISCARD std::string* release_field126();
  void set_allocated_field126(std::string* field126);
  private:
  const std::string& _internal_field126() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field126(const std::string& value);
  std::string* _internal_mutable_field126();
  public:

  // optional string field127 = 127;
  bool has_field127() const;
  private:
  bool _internal_has_field127() const;
  public:
  void clear_field127();
  const std::string& field127() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field127(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field127();
  PROTOBUF_NODISCARD std::string* release_field127();
  void set_allocated_field127(std::string* field127);
  private:
  const std::string& _internal_field127() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field127(const std::string& value);
  std::string* _internal_mutable_field127();
  public:

  // optional string field128 = 128;
  bool has_field128() const;
  private:
  bool _internal_has_field128() const;
  public:
  void clear_field128();
  const std::string& field128() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field128(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field128();
  PROTOBUF_NODISCARD std::string* release_field128();
  void set_allocated_field128(std::string* field128);
  private:
  const std::string& _internal_field128() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field128(const std::string& value);
  std::string* _internal_mutable_field128();
  public:

  // required string field129 = 129;
  bool has_field129() const;
  private:
  bool _internal_has_field129() const;
  public:
  void clear_field129();
  const std::string& field129() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field129(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field129();
  PROTOBUF_NODISCARD std::string* release_field129();
  void set_allocated_field129(std::string* field129);
  private:
  const std::string& _internal_field129() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field129(const std::string& value);
  std::string* _internal_mutable_field129();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestRequiredFieldsBitmap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<5> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field3_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field4_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field5_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field6_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field7_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field8_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field9_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field10_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field11_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field12_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field13_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field14_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field15_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field16_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field17_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field18_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field19_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field20_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field21_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field22_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field23_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field24_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field25_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field26_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field27_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field28_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field29_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field30_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field31_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field32_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field33_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field34_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field35_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field36_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field37_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field38_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field39_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field40_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field41_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field42_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field43_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field44_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field45_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field46_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field47_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field48_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field49_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field50_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field51_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field52_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field53_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field54_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field55_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field56_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field57_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field58_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field59_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field60_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field61_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field62_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field63_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field64_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field65_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field66_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field67_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field68_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field69_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field70_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field71_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field72_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field73_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field74_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field75_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field76_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field77_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field78_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field79_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field80_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field81_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field82_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field83_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field84_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field85_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field86_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field87_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field88_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field89_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field90_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field91_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field92_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field93_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field94_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field95_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field96_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field97_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field98_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field99_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field100_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field101_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field102_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field103_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field104_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field105_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field106_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field107_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field108_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field109_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field110_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field111_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field112_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field113_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field114_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field115_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field116_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field117_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field118_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field119_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field120_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field121_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field122_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field123_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field124_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field125_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field126_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field127_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field128_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field129_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestFieldFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestFieldFlags) */ {
 public:
  inline TestFieldFlags() : TestFieldFlags(nullptr) {}
  ~TestFieldFlags() override;
  explicit PROTOBUF_CONSTEXPR TestFieldFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestFieldFlags(const TestFieldFlags& from);
  TestFieldFlags(TestFieldFlags&& from) noexcept
    : TestFieldFlags() {
    *this = ::std::move(from);
  }

  inline TestFieldFlags& operator=(const TestFieldFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestFieldFlags& operator=(TestFieldFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestFieldFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestFieldFlags* internal_default_instance() {
    return reinterpret_cast<const TestFieldFlags*>(
               &_TestFieldFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TestFieldFlags& a, TestFieldFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(TestFieldFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestFieldFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestFieldFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestFieldFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestFieldFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestFieldFlags& from) {
    TestFieldFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestFieldFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestFieldFlags";
  }
  protected:
  explicit TestFieldFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoFlags3FieldNumber = 3,
    kPackedFieldNumber = 4,
    kPackedDeprecatedFieldNumber = 5,
    kDeprecatedFieldNumber = 6,
    kNoFlags1FieldNumber = 1,
    kNoFlags2FieldNumber = 2,
  };
  // repeated int32 no_flags3 = 3;
  int no_flags3_size() const;
  private:
  int _internal_no_flags3_size() const;
  public:
  void clear_no_flags3();
  private:
  int32_t _internal_no_flags3(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_no_flags3() const;
  void _internal_add_no_flags3(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_no_flags3();
  public:
  int32_t no_flags3(int index) const;
  void set_no_flags3(int index, int32_t value);
  void add_no_flags3(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      no_flags3() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_no_flags3();

  // repeated int32 packed = 4 [packed = true];
  int packed_size() const;
  private:
  int _internal_packed_size() const;
  public:
  void clear_packed();
  private:
  int32_t _internal_packed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_packed() const;
  void _internal_add_packed(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_packed();
  public:
  int32_t packed(int index) const;
  void set_packed(int index, int32_t value);
  void add_packed(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      packed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_packed();

  // repeated int32 packed_deprecated = 5 [packed = true, deprecated = true];
  PROTOBUF_DEPRECATED int packed_deprecated_size() const;
  private:
  int _internal_packed_deprecated_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_packed_deprecated();
  private:
  int32_t _internal_packed_deprecated(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_packed_deprecated() const;
  void _internal_add_packed_deprecated(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_packed_deprecated();
  public:
  PROTOBUF_DEPRECATED int32_t packed_deprecated(int index) const;
  PROTOBUF_DEPRECATED void set_packed_deprecated(int index, int32_t value);
  PROTOBUF_DEPRECATED void add_packed_deprecated(int32_t value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      packed_deprecated() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_packed_deprecated();

  // repeated int32 deprecated = 6 [deprecated = true];
  PROTOBUF_DEPRECATED int deprecated_size() const;
  private:
  int _internal_deprecated_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_deprecated();
  private:
  int32_t _internal_deprecated(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_deprecated() const;
  void _internal_add_deprecated(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_deprecated();
  public:
  PROTOBUF_DEPRECATED int32_t deprecated(int index) const;
  PROTOBUF_DEPRECATED void set_deprecated(int index, int32_t value);
  PROTOBUF_DEPRECATED void add_deprecated(int32_t value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      deprecated() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_deprecated();

  // optional int32 no_flags1 = 1;
  bool has_no_flags1() const;
  private:
  bool _internal_has_no_flags1() const;
  public:
  void clear_no_flags1();
  int32_t no_flags1() const;
  void set_no_flags1(int32_t value);
  private:
  int32_t _internal_no_flags1() const;
  void _internal_set_no_flags1(int32_t value);
  public:

  // required int32 no_flags2 = 2;
  bool has_no_flags2() const;
  private:
  bool _internal_has_no_flags2() const;
  public:
  void clear_no_flags2();
  int32_t no_flags2() const;
  void set_no_flags2(int32_t value);
  private:
  int32_t _internal_no_flags2() const;
  void _internal_set_no_flags2(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:foo.TestFieldFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > no_flags3_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > packed_;
    mutable std::atomic<int> _packed_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > packed_deprecated_;
    mutable std::atomic<int> _packed_deprecated_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > deprecated_;
    int32_t no_flags1_;
    int32_t no_flags2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessageCheck_SubMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessageCheck.SubMessage) */ {
 public:
  inline TestMessageCheck_SubMessage() : TestMessageCheck_SubMessage(nullptr) {}
  ~TestMessageCheck_SubMessage() override;
  explicit PROTOBUF_CONSTEXPR TestMessageCheck_SubMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessageCheck_SubMessage(const TestMessageCheck_SubMessage& from);
  TestMessageCheck_SubMessage(TestMessageCheck_SubMessage&& from) noexcept
    : TestMessageCheck_SubMessage() {
    *this = ::std::move(from);
  }

  inline TestMessageCheck_SubMessage& operator=(const TestMessageCheck_SubMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessageCheck_SubMessage& operator=(TestMessageCheck_SubMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessageCheck_SubMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessageCheck_SubMessage* internal_default_instance() {
    return reinterpret_cast<const TestMessageCheck_SubMessage*>(
               &_TestMessageCheck_SubMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TestMessageCheck_SubMessage& a, TestMessageCheck_SubMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessageCheck_SubMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessageCheck_SubMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessageCheck_SubMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessageCheck_SubMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessageCheck_SubMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessageCheck_SubMessage& from) {
    TestMessageCheck_SubMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessageCheck_SubMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessageCheck.SubMessage";
  }
  protected:
  explicit TestMessageCheck_SubMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrFieldNumber = 1,
  };
  // required string str = 1;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // @@protoc_insertion_point(class_scope:foo.TestMessageCheck.SubMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessageCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessageCheck) */ {
 public:
  inline TestMessageCheck() : TestMessageCheck(nullptr) {}
  ~TestMessageCheck() override;
  explicit PROTOBUF_CONSTEXPR TestMessageCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessageCheck(const TestMessageCheck& from);
  TestMessageCheck(TestMessageCheck&& from) noexcept
    : TestMessageCheck() {
    *this = ::std::move(from);
  }

  inline TestMessageCheck& operator=(const TestMessageCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessageCheck& operator=(TestMessageCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessageCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessageCheck* internal_default_instance() {
    return reinterpret_cast<const TestMessageCheck*>(
               &_TestMessageCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TestMessageCheck& a, TestMessageCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessageCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessageCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessageCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessageCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessageCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessageCheck& from) {
    TestMessageCheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessageCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessageCheck";
  }
  protected:
  explicit TestMessageCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TestMessageCheck_SubMessage SubMessage;

  // accessors -------------------------------------------------------

  enum : int {
    kRepeatedMsgFieldNumber = 2,
    kRepeatedStringFieldNumber = 5,
    kRepeatedBytesFieldNumber = 8,
    kRequiredStringFieldNumber = 4,
    kOptionalStringFieldNumber = 6,
    kRequiredBytesFieldNumber = 7,
    kOptionalBytesFieldNumber = 9,
    kRequiredMsgFieldNumber = 1,
    kOptionalMsgFieldNumber = 3,
  };
  // repeated .foo.TestMessageCheck.SubMessage repeated_msg = 2;
  int repeated_msg_size() const;
  private:
  int _internal_repeated_msg_size() const;
  public:
  void clear_repeated_msg();
  ::foo::TestMessageCheck_SubMessage* mutable_repeated_msg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::TestMessageCheck_SubMessage >*
      mutable_repeated_msg();
  private:
  const ::foo::TestMessageCheck_SubMessage& _internal_repeated_msg(int index) const;
  ::foo::TestMessageCheck_SubMessage* _internal_add_repeated_msg();
  public:
  const ::foo::TestMessageCheck_SubMessage& repeated_msg(int index) const;
  ::foo::TestMessageCheck_SubMessage* add_repeated_msg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::TestMessageCheck_SubMessage >&
      repeated_msg() const;

  // repeated string repeated_string = 5;
  int repeated_string_size() const;
  private:
  int _internal_repeated_string_size() const;
  public:
  void clear_repeated_string();
  const std::string& repeated_string(int index) const;
  std::string* mutable_repeated_string(int index);
  void set_repeated_string(int index, const std::string& value);
  void set_repeated_string(int index, std::string&& value);
  void set_repeated_string(int index, const char* value);
  void set_repeated_string(int index, const char* value, size_t size);
  std::string* add_repeated_string();
  void add_repeated_string(const std::string& value);
  void add_repeated_string(std::string&& value);
  void add_repeated_string(const char* value);
  void add_repeated_string(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& repeated_string() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_repeated_string();
  private:
  const std::string& _internal_repeated_string(int index) const;
  std::string* _internal_add_repeated_string();
  public:

  // repeated bytes repeated_bytes = 8;
  int repeated_bytes_size() const;
  private:
  int _internal_repeated_bytes_size() const;
  public:
  void clear_repeated_bytes();
  const std::string& repeated_bytes(int index) const;
  std::string* mutable_repeated_bytes(int index);
  void set_repeated_bytes(int index, const std::string& value);
  void set_repeated_bytes(int index, std::string&& value);
  void set_repeated_bytes(int index, const char* value);
  void set_repeated_bytes(int index, const void* value, size_t size);
  std::string* add_repeated_bytes();
  void add_repeated_bytes(const std::string& value);
  void add_repeated_bytes(std::string&& value);
  void add_repeated_bytes(const char* value);
  void add_repeated_bytes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& repeated_bytes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_repeated_bytes();
  private:
  const std::string& _internal_repeated_bytes(int index) const;
  std::string* _internal_add_repeated_bytes();
  public:

  // required string required_string = 4;
  bool has_required_string() const;
  private:
  bool _internal_has_required_string() const;
  public:
  void clear_required_string();
  const std::string& required_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_string();
  PROTOBUF_NODISCARD std::string* release_required_string();
  void set_allocated_required_string(std::string* required_string);
  private:
  const std::string& _internal_required_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_string(const std::string& value);
  std::string* _internal_mutable_required_string();
  public:

  // optional string optional_string = 6;
  bool has_optional_string() const;
  private:
  bool _internal_has_optional_string() const;
  public:
  void clear_optional_string();
  const std::string& optional_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_string();
  PROTOBUF_NODISCARD std::string* release_optional_string();
  void set_allocated_optional_string(std::string* optional_string);
  private:
  const std::string& _internal_optional_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_string(const std::string& value);
  std::string* _internal_mutable_optional_string();
  public:

  // required bytes required_bytes = 7;
  bool has_required_bytes() const;
  private:
  bool _internal_has_required_bytes() const;
  public:
  void clear_required_bytes();
  const std::string& required_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_bytes();
  PROTOBUF_NODISCARD std::string* release_required_bytes();
  void set_allocated_required_bytes(std::string* required_bytes);
  private:
  const std::string& _internal_required_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_bytes(const std::string& value);
  std::string* _internal_mutable_required_bytes();
  public:

  // optional bytes optional_bytes = 9;
  bool has_optional_bytes() const;
  private:
  bool _internal_has_optional_bytes() const;
  public:
  void clear_optional_bytes();
  const std::string& optional_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_optional_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_optional_bytes();
  PROTOBUF_NODISCARD std::string* release_optional_bytes();
  void set_allocated_optional_bytes(std::string* optional_bytes);
  private:
  const std::string& _internal_optional_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_optional_bytes(const std::string& value);
  std::string* _internal_mutable_optional_bytes();
  public:

  // required .foo.TestMessageCheck.SubMessage required_msg = 1;
  bool has_required_msg() const;
  private:
  bool _internal_has_required_msg() const;
  public:
  void clear_required_msg();
  const ::foo::TestMessageCheck_SubMessage& required_msg() const;
  PROTOBUF_NODISCARD ::foo::TestMessageCheck_SubMessage* release_required_msg();
  ::foo::TestMessageCheck_SubMessage* mutable_required_msg();
  void set_allocated_required_msg(::foo::TestMessageCheck_SubMessage* required_msg);
  private:
  const ::foo::TestMessageCheck_SubMessage& _internal_required_msg() const;
  ::foo::TestMessageCheck_SubMessage* _internal_mutable_required_msg();
  public:
  void unsafe_arena_set_allocated_required_msg(
      ::foo::TestMessageCheck_SubMessage* required_msg);
  ::foo::TestMessageCheck_SubMessage* unsafe_arena_release_required_msg();

  // optional .foo.TestMessageCheck.SubMessage optional_msg = 3;
  bool has_optional_msg() const;
  private:
  bool _internal_has_optional_msg() const;
  public:
  void clear_optional_msg();
  const ::foo::TestMessageCheck_SubMessage& optional_msg() const;
  PROTOBUF_NODISCARD ::foo::TestMessageCheck_SubMessage* release_optional_msg();
  ::foo::TestMessageCheck_SubMessage* mutable_optional_msg();
  void set_allocated_optional_msg(::foo::TestMessageCheck_SubMessage* optional_msg);
  private:
  const ::foo::TestMessageCheck_SubMessage& _internal_optional_msg() const;
  ::foo::TestMessageCheck_SubMessage* _internal_mutable_optional_msg();
  public:
  void unsafe_arena_set_allocated_optional_msg(
      ::foo::TestMessageCheck_SubMessage* optional_msg);
  ::foo::TestMessageCheck_SubMessage* unsafe_arena_release_optional_msg();

  // @@protoc_insertion_point(class_scope:foo.TestMessageCheck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::TestMessageCheck_SubMessage > repeated_msg_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> repeated_string_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> repeated_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr optional_bytes_;
    ::foo::TestMessageCheck_SubMessage* required_msg_;
    ::foo::TestMessageCheck_SubMessage* optional_msg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// -------------------------------------------------------------------

class TestMessSubMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:foo.TestMessSubMess) */ {
 public:
  inline TestMessSubMess() : TestMessSubMess(nullptr) {}
  ~TestMessSubMess() override;
  explicit PROTOBUF_CONSTEXPR TestMessSubMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestMessSubMess(const TestMessSubMess& from);
  TestMessSubMess(TestMessSubMess&& from) noexcept
    : TestMessSubMess() {
    *this = ::std::move(from);
  }

  inline TestMessSubMess& operator=(const TestMessSubMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestMessSubMess& operator=(TestMessSubMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestMessSubMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestMessSubMess* internal_default_instance() {
    return reinterpret_cast<const TestMessSubMess*>(
               &_TestMessSubMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TestMessSubMess& a, TestMessSubMess& b) {
    a.Swap(&b);
  }
  inline void Swap(TestMessSubMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestMessSubMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestMessSubMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestMessSubMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestMessSubMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestMessSubMess& from) {
    TestMessSubMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessSubMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "foo.TestMessSubMess";
  }
  protected:
  explicit TestMessSubMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepMessFieldNumber = 1,
    kOptMessFieldNumber = 2,
    kOneofMessFieldNumber = 3,
    kReqMessFieldNumber = 4,
    kDefMessFieldNumber = 5,
  };
  // required .foo.TestMess rep_mess = 1;
  bool has_rep_mess() const;
  private:
  bool _internal_has_rep_mess() const;
  public:
  void clear_rep_mess();
  const ::foo::TestMess& rep_mess() const;
  PROTOBUF_NODISCARD ::foo::TestMess* release_rep_mess();
  ::foo::TestMess* mutable_rep_mess();
  void set_allocated_rep_mess(::foo::TestMess* rep_mess);
  private:
  const ::foo::TestMess& _internal_rep_mess() const;
  ::foo::TestMess* _internal_mutable_rep_mess();
  public:
  void unsafe_arena_set_allocated_rep_mess(
      ::foo::TestMess* rep_mess);
  ::foo::TestMess* unsafe_arena_release_rep_mess();

  // required .foo.TestMessOptional opt_mess = 2;
  bool has_opt_mess() const;
  private:
  bool _internal_has_opt_mess() const;
  public:
  void clear_opt_mess();
  const ::foo::TestMessOptional& opt_mess() const;
  PROTOBUF_NODISCARD ::foo::TestMessOptional* release_opt_mess();
  ::foo::TestMessOptional* mutable_opt_mess();
  void set_allocated_opt_mess(::foo::TestMessOptional* opt_mess);
  private:
  const ::foo::TestMessOptional& _internal_opt_mess() const;
  ::foo::TestMessOptional* _internal_mutable_opt_mess();
  public:
  void unsafe_arena_set_allocated_opt_mess(
      ::foo::TestMessOptional* opt_mess);
  ::foo::TestMessOptional* unsafe_arena_release_opt_mess();

  // required .foo.TestMessOneof oneof_mess = 3;
  bool has_oneof_mess() const;
  private:
  bool _internal_has_oneof_mess() const;
  public:
  void clear_oneof_mess();
  const ::foo::TestMessOneof& oneof_mess() const;
  PROTOBUF_NODISCARD ::foo::TestMessOneof* release_oneof_mess();
  ::foo::TestMessOneof* mutable_oneof_mess();
  void set_allocated_oneof_mess(::foo::TestMessOneof* oneof_mess);
  private:
  const ::foo::TestMessOneof& _internal_oneof_mess() const;
  ::foo::TestMessOneof* _internal_mutable_oneof_mess();
  public:
  void unsafe_arena_set_allocated_oneof_mess(
      ::foo::TestMessOneof* oneof_mess);
  ::foo::TestMessOneof* unsafe_arena_release_oneof_mess();

  // required .foo.SubMess req_mess = 4;
  bool has_req_mess() const;
  private:
  bool _internal_has_req_mess() const;
  public:
  void clear_req_mess();
  const ::foo::SubMess& req_mess() const;
  PROTOBUF_NODISCARD ::foo::SubMess* release_req_mess();
  ::foo::SubMess* mutable_req_mess();
  void set_allocated_req_mess(::foo::SubMess* req_mess);
  private:
  const ::foo::SubMess& _internal_req_mess() const;
  ::foo::SubMess* _internal_mutable_req_mess();
  public:
  void unsafe_arena_set_allocated_req_mess(
      ::foo::SubMess* req_mess);
  ::foo::SubMess* unsafe_arena_release_req_mess();

  // required .foo.DefaultOptionalValues def_mess = 5;
  bool has_def_mess() const;
  private:
  bool _internal_has_def_mess() const;
  public:
  void clear_def_mess();
  const ::foo::DefaultOptionalValues& def_mess() const;
  PROTOBUF_NODISCARD ::foo::DefaultOptionalValues* release_def_mess();
  ::foo::DefaultOptionalValues* mutable_def_mess();
  void set_allocated_def_mess(::foo::DefaultOptionalValues* def_mess);
  private:
  const ::foo::DefaultOptionalValues& _internal_def_mess() const;
  ::foo::DefaultOptionalValues* _internal_mutable_def_mess();
  public:
  void unsafe_arena_set_allocated_def_mess(
      ::foo::DefaultOptionalValues* def_mess);
  ::foo::DefaultOptionalValues* unsafe_arena_release_def_mess();

  // @@protoc_insertion_point(class_scope:foo.TestMessSubMess)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::foo::TestMess* rep_mess_;
    ::foo::TestMessOptional* opt_mess_;
    ::foo::TestMessOneof* oneof_mess_;
    ::foo::SubMess* req_mess_;
    ::foo::DefaultOptionalValues* def_mess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_t_2ftest_2dfull_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubMess_SubSubMess

// optional int32 val1 = 1 [default = 100];
inline bool SubMess_SubSubMess::_internal_has_val1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubMess_SubSubMess::has_val1() const {
  return _internal_has_val1();
}
inline void SubMess_SubSubMess::clear_val1() {
  _impl_.val1_ = 100;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SubMess_SubSubMess::_internal_val1() const {
  return _impl_.val1_;
}
inline int32_t SubMess_SubSubMess::val1() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.SubSubMess.val1)
  return _internal_val1();
}
inline void SubMess_SubSubMess::_internal_set_val1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.val1_ = value;
}
inline void SubMess_SubSubMess::set_val1(int32_t value) {
  _internal_set_val1(value);
  // @@protoc_insertion_point(field_set:foo.SubMess.SubSubMess.val1)
}

// repeated int32 rep = 4;
inline int SubMess_SubSubMess::_internal_rep_size() const {
  return _impl_.rep_.size();
}
inline int SubMess_SubSubMess::rep_size() const {
  return _internal_rep_size();
}
inline void SubMess_SubSubMess::clear_rep() {
  _impl_.rep_.Clear();
}
inline int32_t SubMess_SubSubMess::_internal_rep(int index) const {
  return _impl_.rep_.Get(index);
}
inline int32_t SubMess_SubSubMess::rep(int index) const {
  // @@protoc_insertion_point(field_get:foo.SubMess.SubSubMess.rep)
  return _internal_rep(index);
}
inline void SubMess_SubSubMess::set_rep(int index, int32_t value) {
  _impl_.rep_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.SubMess.SubSubMess.rep)
}
inline void SubMess_SubSubMess::_internal_add_rep(int32_t value) {
  _impl_.rep_.Add(value);
}
inline void SubMess_SubSubMess::add_rep(int32_t value) {
  _internal_add_rep(value);
  // @@protoc_insertion_point(field_add:foo.SubMess.SubSubMess.rep)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubMess_SubSubMess::_internal_rep() const {
  return _impl_.rep_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubMess_SubSubMess::rep() const {
  // @@protoc_insertion_point(field_list:foo.SubMess.SubSubMess.rep)
  return _internal_rep();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubMess_SubSubMess::_internal_mutable_rep() {
  return &_impl_.rep_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubMess_SubSubMess::mutable_rep() {
  // @@protoc_insertion_point(field_mutable_list:foo.SubMess.SubSubMess.rep)
  return _internal_mutable_rep();
}

// optional bytes bytes1 = 2 [default = "a \000 char"];
inline bool SubMess_SubSubMess::_internal_has_bytes1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubMess_SubSubMess::has_bytes1() const {
  return _internal_has_bytes1();
}
inline void SubMess_SubSubMess::clear_bytes1() {
  _impl_.bytes1_.ClearToDefault(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_bytes1_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubMess_SubSubMess::bytes1() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.SubSubMess.bytes1)
  if (_impl_.bytes1_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_bytes1_.get();
  return _internal_bytes1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubMess_SubSubMess::set_bytes1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.bytes1_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.SubMess.SubSubMess.bytes1)
}
inline std::string* SubMess_SubSubMess::mutable_bytes1() {
  std::string* _s = _internal_mutable_bytes1();
  // @@protoc_insertion_point(field_mutable:foo.SubMess.SubSubMess.bytes1)
  return _s;
}
inline const std::string& SubMess_SubSubMess::_internal_bytes1() const {
  return _impl_.bytes1_.Get();
}
inline void SubMess_SubSubMess::_internal_set_bytes1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bytes1_.Set(value, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::_internal_mutable_bytes1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.bytes1_.Mutable(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_bytes1_, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::release_bytes1() {
  // @@protoc_insertion_point(field_release:foo.SubMess.SubSubMess.bytes1)
  if (!_internal_has_bytes1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.bytes1_.Release();
  return p;
}
inline void SubMess_SubSubMess::set_allocated_bytes1(std::string* bytes1) {
  if (bytes1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bytes1_.SetAllocated(bytes1, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.SubMess.SubSubMess.bytes1)
}

// optional string str1 = 3 [default = "hello world\n"];
inline bool SubMess_SubSubMess::_internal_has_str1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubMess_SubSubMess::has_str1() const {
  return _internal_has_str1();
}
inline void SubMess_SubSubMess::clear_str1() {
  _impl_.str1_.ClearToDefault(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_str1_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubMess_SubSubMess::str1() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.SubSubMess.str1)
  if (_impl_.str1_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_str1_.get();
  return _internal_str1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubMess_SubSubMess::set_str1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.str1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.SubMess.SubSubMess.str1)
}
inline std::string* SubMess_SubSubMess::mutable_str1() {
  std::string* _s = _internal_mutable_str1();
  // @@protoc_insertion_point(field_mutable:foo.SubMess.SubSubMess.str1)
  return _s;
}
inline const std::string& SubMess_SubSubMess::_internal_str1() const {
  return _impl_.str1_.Get();
}
inline void SubMess_SubSubMess::_internal_set_str1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.str1_.Set(value, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::_internal_mutable_str1() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.str1_.Mutable(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_str1_, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::release_str1() {
  // @@protoc_insertion_point(field_release:foo.SubMess.SubSubMess.str1)
  if (!_internal_has_str1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.str1_.Release();
  return p;
}
inline void SubMess_SubSubMess::set_allocated_str1(std::string* str1) {
  if (str1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.str1_.SetAllocated(str1, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.SubMess.SubSubMess.str1)
}

// optional string str2 = 5 [default = "hello\000world\n", (.pb_c_field) = {
inline bool SubMess_SubSubMess::_internal_has_str2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubMess_SubSubMess::has_str2() const {
  return _internal_has_str2();
}
inline void SubMess_SubSubMess::clear_str2() {
  _impl_.str2_.ClearToDefault(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_str2_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SubMess_SubSubMess::str2() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.SubSubMess.str2)
  if (_impl_.str2_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_str2_.get();
  return _internal_str2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubMess_SubSubMess::set_str2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.str2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.SubMess.SubSubMess.str2)
}
inline std::string* SubMess_SubSubMess::mutable_str2() {
  std::string* _s = _internal_mutable_str2();
  // @@protoc_insertion_point(field_mutable:foo.SubMess.SubSubMess.str2)
  return _s;
}
inline const std::string& SubMess_SubSubMess::_internal_str2() const {
  return _impl_.str2_.Get();
}
inline void SubMess_SubSubMess::_internal_set_str2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.str2_.Set(value, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::_internal_mutable_str2() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.str2_.Mutable(::foo::SubMess_SubSubMess::Impl_::_i_give_permission_to_break_this_code_default_str2_, GetArenaForAllocation());
}
inline std::string* SubMess_SubSubMess::release_str2() {
  // @@protoc_insertion_point(field_release:foo.SubMess.SubSubMess.str2)
  if (!_internal_has_str2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.str2_.Release();
  return p;
}
inline void SubMess_SubSubMess::set_allocated_str2(std::string* str2) {
  if (str2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.str2_.SetAllocated(str2, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.SubMess.SubSubMess.str2)
}

// -------------------------------------------------------------------

// SubMess

// required int32 test = 4;
inline bool SubMess::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubMess::has_test() const {
  return _internal_has_test();
}
inline void SubMess::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SubMess::_internal_test() const {
  return _impl_.test_;
}
inline int32_t SubMess::test() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.test)
  return _internal_test();
}
inline void SubMess::_internal_set_test(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.test_ = value;
}
inline void SubMess::set_test(int32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.SubMess.test)
}

// optional int32 val1 = 6;
inline bool SubMess::_internal_has_val1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SubMess::has_val1() const {
  return _internal_has_val1();
}
inline void SubMess::clear_val1() {
  _impl_.val1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SubMess::_internal_val1() const {
  return _impl_.val1_;
}
inline int32_t SubMess::val1() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.val1)
  return _internal_val1();
}
inline void SubMess::_internal_set_val1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.val1_ = value;
}
inline void SubMess::set_val1(int32_t value) {
  _internal_set_val1(value);
  // @@protoc_insertion_point(field_set:foo.SubMess.val1)
}

// optional int32 val2 = 7;
inline bool SubMess::_internal_has_val2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SubMess::has_val2() const {
  return _internal_has_val2();
}
inline void SubMess::clear_val2() {
  _impl_.val2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SubMess::_internal_val2() const {
  return _impl_.val2_;
}
inline int32_t SubMess::val2() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.val2)
  return _internal_val2();
}
inline void SubMess::_internal_set_val2(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.val2_ = value;
}
inline void SubMess::set_val2(int32_t value) {
  _internal_set_val2(value);
  // @@protoc_insertion_point(field_set:foo.SubMess.val2)
}

// repeated int32 rep = 8;
inline int SubMess::_internal_rep_size() const {
  return _impl_.rep_.size();
}
inline int SubMess::rep_size() const {
  return _internal_rep_size();
}
inline void SubMess::clear_rep() {
  _impl_.rep_.Clear();
}
inline int32_t SubMess::_internal_rep(int index) const {
  return _impl_.rep_.Get(index);
}
inline int32_t SubMess::rep(int index) const {
  // @@protoc_insertion_point(field_get:foo.SubMess.rep)
  return _internal_rep(index);
}
inline void SubMess::set_rep(int index, int32_t value) {
  _impl_.rep_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.SubMess.rep)
}
inline void SubMess::_internal_add_rep(int32_t value) {
  _impl_.rep_.Add(value);
}
inline void SubMess::add_rep(int32_t value) {
  _internal_add_rep(value);
  // @@protoc_insertion_point(field_add:foo.SubMess.rep)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubMess::_internal_rep() const {
  return _impl_.rep_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubMess::rep() const {
  // @@protoc_insertion_point(field_list:foo.SubMess.rep)
  return _internal_rep();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubMess::_internal_mutable_rep() {
  return &_impl_.rep_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubMess::mutable_rep() {
  // @@protoc_insertion_point(field_mutable_list:foo.SubMess.rep)
  return _internal_mutable_rep();
}

// optional .foo.SubMess.SubSubMess sub1 = 9;
inline bool SubMess::_internal_has_sub1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sub1_ != nullptr);
  return value;
}
inline bool SubMess::has_sub1() const {
  return _internal_has_sub1();
}
inline void SubMess::clear_sub1() {
  if (_impl_.sub1_ != nullptr) _impl_.sub1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::foo::SubMess_SubSubMess& SubMess::_internal_sub1() const {
  const ::foo::SubMess_SubSubMess* p = _impl_.sub1_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::SubMess_SubSubMess&>(
      ::foo::_SubMess_SubSubMess_default_instance_);
}
inline const ::foo::SubMess_SubSubMess& SubMess::sub1() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.sub1)
  return _internal_sub1();
}
inline void SubMess::unsafe_arena_set_allocated_sub1(
    ::foo::SubMess_SubSubMess* sub1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sub1_);
  }
  _impl_.sub1_ = sub1;
  if (sub1) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.SubMess.sub1)
}
inline ::foo::SubMess_SubSubMess* SubMess::release_sub1() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::SubMess_SubSubMess* temp = _impl_.sub1_;
  _impl_.sub1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::SubMess_SubSubMess* SubMess::unsafe_arena_release_sub1() {
  // @@protoc_insertion_point(field_release:foo.SubMess.sub1)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::SubMess_SubSubMess* temp = _impl_.sub1_;
  _impl_.sub1_ = nullptr;
  return temp;
}
inline ::foo::SubMess_SubSubMess* SubMess::_internal_mutable_sub1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sub1_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::SubMess_SubSubMess>(GetArenaForAllocation());
    _impl_.sub1_ = p;
  }
  return _impl_.sub1_;
}
inline ::foo::SubMess_SubSubMess* SubMess::mutable_sub1() {
  ::foo::SubMess_SubSubMess* _msg = _internal_mutable_sub1();
  // @@protoc_insertion_point(field_mutable:foo.SubMess.sub1)
  return _msg;
}
inline void SubMess::set_allocated_sub1(::foo::SubMess_SubSubMess* sub1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sub1_;
  }
  if (sub1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sub1);
    if (message_arena != submessage_arena) {
      sub1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub1, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sub1_ = sub1;
  // @@protoc_insertion_point(field_set_allocated:foo.SubMess.sub1)
}

// optional .foo.SubMess.SubSubMess sub2 = 10;
inline bool SubMess::_internal_has_sub2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sub2_ != nullptr);
  return value;
}
inline bool SubMess::has_sub2() const {
  return _internal_has_sub2();
}
inline void SubMess::clear_sub2() {
  if (_impl_.sub2_ != nullptr) _impl_.sub2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::foo::SubMess_SubSubMess& SubMess::_internal_sub2() const {
  const ::foo::SubMess_SubSubMess* p = _impl_.sub2_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::SubMess_SubSubMess&>(
      ::foo::_SubMess_SubSubMess_default_instance_);
}
inline const ::foo::SubMess_SubSubMess& SubMess::sub2() const {
  // @@protoc_insertion_point(field_get:foo.SubMess.sub2)
  return _internal_sub2();
}
inline void SubMess::unsafe_arena_set_allocated_sub2(
    ::foo::SubMess_SubSubMess* sub2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sub2_);
  }
  _impl_.sub2_ = sub2;
  if (sub2) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.SubMess.sub2)
}
inline ::foo::SubMess_SubSubMess* SubMess::release_sub2() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foo::SubMess_SubSubMess* temp = _impl_.sub2_;
  _impl_.sub2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::SubMess_SubSubMess* SubMess::unsafe_arena_release_sub2() {
  // @@protoc_insertion_point(field_release:foo.SubMess.sub2)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foo::SubMess_SubSubMess* temp = _impl_.sub2_;
  _impl_.sub2_ = nullptr;
  return temp;
}
inline ::foo::SubMess_SubSubMess* SubMess::_internal_mutable_sub2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.sub2_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::SubMess_SubSubMess>(GetArenaForAllocation());
    _impl_.sub2_ = p;
  }
  return _impl_.sub2_;
}
inline ::foo::SubMess_SubSubMess* SubMess::mutable_sub2() {
  ::foo::SubMess_SubSubMess* _msg = _internal_mutable_sub2();
  // @@protoc_insertion_point(field_mutable:foo.SubMess.sub2)
  return _msg;
}
inline void SubMess::set_allocated_sub2(::foo::SubMess_SubSubMess* sub2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sub2_;
  }
  if (sub2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sub2);
    if (message_arena != submessage_arena) {
      sub2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub2, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sub2_ = sub2;
  // @@protoc_insertion_point(field_set_allocated:foo.SubMess.sub2)
}

// -------------------------------------------------------------------

// TestFieldNo15

// required string test = 15;
inline bool TestFieldNo15::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo15::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo15::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo15::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo15.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo15::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo15.test)
}
inline std::string* TestFieldNo15::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo15.test)
  return _s;
}
inline const std::string& TestFieldNo15::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo15::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo15::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo15::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo15.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo15::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo15.test)
}

// -------------------------------------------------------------------

// TestFieldNo16

// required string test = 16;
inline bool TestFieldNo16::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo16::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo16::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo16::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo16.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo16::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo16.test)
}
inline std::string* TestFieldNo16::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo16.test)
  return _s;
}
inline const std::string& TestFieldNo16::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo16::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo16::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo16::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo16.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo16::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo16.test)
}

// -------------------------------------------------------------------

// TestFieldNo2047

// required string test = 2047;
inline bool TestFieldNo2047::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo2047::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo2047::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo2047::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo2047.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo2047::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo2047.test)
}
inline std::string* TestFieldNo2047::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo2047.test)
  return _s;
}
inline const std::string& TestFieldNo2047::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo2047::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo2047::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo2047::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo2047.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo2047::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo2047.test)
}

// -------------------------------------------------------------------

// TestFieldNo2048

// required string test = 2048;
inline bool TestFieldNo2048::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo2048::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo2048::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo2048::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo2048.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo2048::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo2048.test)
}
inline std::string* TestFieldNo2048::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo2048.test)
  return _s;
}
inline const std::string& TestFieldNo2048::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo2048::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo2048::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo2048::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo2048.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo2048::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo2048.test)
}

// -------------------------------------------------------------------

// TestFieldNo262143

// required string test = 262143;
inline bool TestFieldNo262143::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo262143::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo262143::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo262143::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo262143.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo262143::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo262143.test)
}
inline std::string* TestFieldNo262143::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo262143.test)
  return _s;
}
inline const std::string& TestFieldNo262143::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo262143::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo262143::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo262143::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo262143.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo262143::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo262143.test)
}

// -------------------------------------------------------------------

// TestFieldNo262144

// required string test = 262144;
inline bool TestFieldNo262144::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo262144::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo262144::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo262144::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo262144.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo262144::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo262144.test)
}
inline std::string* TestFieldNo262144::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo262144.test)
  return _s;
}
inline const std::string& TestFieldNo262144::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo262144::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo262144::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo262144::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo262144.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo262144::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo262144.test)
}

// -------------------------------------------------------------------

// TestFieldNo33554431

// required string test = 33554431;
inline bool TestFieldNo33554431::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo33554431::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo33554431::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo33554431::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo33554431.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo33554431::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo33554431.test)
}
inline std::string* TestFieldNo33554431::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo33554431.test)
  return _s;
}
inline const std::string& TestFieldNo33554431::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo33554431::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo33554431::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo33554431::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo33554431.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo33554431::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo33554431.test)
}

// -------------------------------------------------------------------

// TestFieldNo33554432

// required string test = 33554432;
inline bool TestFieldNo33554432::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldNo33554432::has_test() const {
  return _internal_has_test();
}
inline void TestFieldNo33554432::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestFieldNo33554432::test() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldNo33554432.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestFieldNo33554432::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestFieldNo33554432.test)
}
inline std::string* TestFieldNo33554432::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestFieldNo33554432.test)
  return _s;
}
inline const std::string& TestFieldNo33554432::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestFieldNo33554432::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestFieldNo33554432::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestFieldNo33554432::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestFieldNo33554432.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestFieldNo33554432::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestFieldNo33554432.test)
}

// -------------------------------------------------------------------

// TestMess

// repeated int32 test_int32 = 1;
inline int TestMess::_internal_test_int32_size() const {
  return _impl_.test_int32_.size();
}
inline int TestMess::test_int32_size() const {
  return _internal_test_int32_size();
}
inline void TestMess::clear_test_int32() {
  _impl_.test_int32_.Clear();
}
inline int32_t TestMess::_internal_test_int32(int index) const {
  return _impl_.test_int32_.Get(index);
}
inline int32_t TestMess::test_int32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_int32)
  return _internal_test_int32(index);
}
inline void TestMess::set_test_int32(int index, int32_t value) {
  _impl_.test_int32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_int32)
}
inline void TestMess::_internal_add_test_int32(int32_t value) {
  _impl_.test_int32_.Add(value);
}
inline void TestMess::add_test_int32(int32_t value) {
  _internal_add_test_int32(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_int32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::_internal_test_int32() const {
  return _impl_.test_int32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::test_int32() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_int32)
  return _internal_test_int32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::_internal_mutable_test_int32() {
  return &_impl_.test_int32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::mutable_test_int32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_int32)
  return _internal_mutable_test_int32();
}

// repeated sint32 test_sint32 = 2;
inline int TestMess::_internal_test_sint32_size() const {
  return _impl_.test_sint32_.size();
}
inline int TestMess::test_sint32_size() const {
  return _internal_test_sint32_size();
}
inline void TestMess::clear_test_sint32() {
  _impl_.test_sint32_.Clear();
}
inline int32_t TestMess::_internal_test_sint32(int index) const {
  return _impl_.test_sint32_.Get(index);
}
inline int32_t TestMess::test_sint32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_sint32)
  return _internal_test_sint32(index);
}
inline void TestMess::set_test_sint32(int index, int32_t value) {
  _impl_.test_sint32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_sint32)
}
inline void TestMess::_internal_add_test_sint32(int32_t value) {
  _impl_.test_sint32_.Add(value);
}
inline void TestMess::add_test_sint32(int32_t value) {
  _internal_add_test_sint32(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_sint32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::_internal_test_sint32() const {
  return _impl_.test_sint32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::test_sint32() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_sint32)
  return _internal_test_sint32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::_internal_mutable_test_sint32() {
  return &_impl_.test_sint32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::mutable_test_sint32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_sint32)
  return _internal_mutable_test_sint32();
}

// repeated sfixed32 test_sfixed32 = 3;
inline int TestMess::_internal_test_sfixed32_size() const {
  return _impl_.test_sfixed32_.size();
}
inline int TestMess::test_sfixed32_size() const {
  return _internal_test_sfixed32_size();
}
inline void TestMess::clear_test_sfixed32() {
  _impl_.test_sfixed32_.Clear();
}
inline int32_t TestMess::_internal_test_sfixed32(int index) const {
  return _impl_.test_sfixed32_.Get(index);
}
inline int32_t TestMess::test_sfixed32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_sfixed32)
  return _internal_test_sfixed32(index);
}
inline void TestMess::set_test_sfixed32(int index, int32_t value) {
  _impl_.test_sfixed32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_sfixed32)
}
inline void TestMess::_internal_add_test_sfixed32(int32_t value) {
  _impl_.test_sfixed32_.Add(value);
}
inline void TestMess::add_test_sfixed32(int32_t value) {
  _internal_add_test_sfixed32(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_sfixed32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::_internal_test_sfixed32() const {
  return _impl_.test_sfixed32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMess::test_sfixed32() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_sfixed32)
  return _internal_test_sfixed32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::_internal_mutable_test_sfixed32() {
  return &_impl_.test_sfixed32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMess::mutable_test_sfixed32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_sfixed32)
  return _internal_mutable_test_sfixed32();
}

// repeated int64 test_int64 = 4;
inline int TestMess::_internal_test_int64_size() const {
  return _impl_.test_int64_.size();
}
inline int TestMess::test_int64_size() const {
  return _internal_test_int64_size();
}
inline void TestMess::clear_test_int64() {
  _impl_.test_int64_.Clear();
}
inline int64_t TestMess::_internal_test_int64(int index) const {
  return _impl_.test_int64_.Get(index);
}
inline int64_t TestMess::test_int64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_int64)
  return _internal_test_int64(index);
}
inline void TestMess::set_test_int64(int index, int64_t value) {
  _impl_.test_int64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_int64)
}
inline void TestMess::_internal_add_test_int64(int64_t value) {
  _impl_.test_int64_.Add(value);
}
inline void TestMess::add_test_int64(int64_t value) {
  _internal_add_test_int64(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_int64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::_internal_test_int64() const {
  return _impl_.test_int64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::test_int64() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_int64)
  return _internal_test_int64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::_internal_mutable_test_int64() {
  return &_impl_.test_int64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::mutable_test_int64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_int64)
  return _internal_mutable_test_int64();
}

// repeated sint64 test_sint64 = 5;
inline int TestMess::_internal_test_sint64_size() const {
  return _impl_.test_sint64_.size();
}
inline int TestMess::test_sint64_size() const {
  return _internal_test_sint64_size();
}
inline void TestMess::clear_test_sint64() {
  _impl_.test_sint64_.Clear();
}
inline int64_t TestMess::_internal_test_sint64(int index) const {
  return _impl_.test_sint64_.Get(index);
}
inline int64_t TestMess::test_sint64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_sint64)
  return _internal_test_sint64(index);
}
inline void TestMess::set_test_sint64(int index, int64_t value) {
  _impl_.test_sint64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_sint64)
}
inline void TestMess::_internal_add_test_sint64(int64_t value) {
  _impl_.test_sint64_.Add(value);
}
inline void TestMess::add_test_sint64(int64_t value) {
  _internal_add_test_sint64(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_sint64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::_internal_test_sint64() const {
  return _impl_.test_sint64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::test_sint64() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_sint64)
  return _internal_test_sint64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::_internal_mutable_test_sint64() {
  return &_impl_.test_sint64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::mutable_test_sint64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_sint64)
  return _internal_mutable_test_sint64();
}

// repeated sfixed64 test_sfixed64 = 6;
inline int TestMess::_internal_test_sfixed64_size() const {
  return _impl_.test_sfixed64_.size();
}
inline int TestMess::test_sfixed64_size() const {
  return _internal_test_sfixed64_size();
}
inline void TestMess::clear_test_sfixed64() {
  _impl_.test_sfixed64_.Clear();
}
inline int64_t TestMess::_internal_test_sfixed64(int index) const {
  return _impl_.test_sfixed64_.Get(index);
}
inline int64_t TestMess::test_sfixed64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_sfixed64)
  return _internal_test_sfixed64(index);
}
inline void TestMess::set_test_sfixed64(int index, int64_t value) {
  _impl_.test_sfixed64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_sfixed64)
}
inline void TestMess::_internal_add_test_sfixed64(int64_t value) {
  _impl_.test_sfixed64_.Add(value);
}
inline void TestMess::add_test_sfixed64(int64_t value) {
  _internal_add_test_sfixed64(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_sfixed64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::_internal_test_sfixed64() const {
  return _impl_.test_sfixed64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMess::test_sfixed64() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_sfixed64)
  return _internal_test_sfixed64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::_internal_mutable_test_sfixed64() {
  return &_impl_.test_sfixed64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMess::mutable_test_sfixed64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_sfixed64)
  return _internal_mutable_test_sfixed64();
}

// repeated uint32 test_uint32 = 7;
inline int TestMess::_internal_test_uint32_size() const {
  return _impl_.test_uint32_.size();
}
inline int TestMess::test_uint32_size() const {
  return _internal_test_uint32_size();
}
inline void TestMess::clear_test_uint32() {
  _impl_.test_uint32_.Clear();
}
inline uint32_t TestMess::_internal_test_uint32(int index) const {
  return _impl_.test_uint32_.Get(index);
}
inline uint32_t TestMess::test_uint32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_uint32)
  return _internal_test_uint32(index);
}
inline void TestMess::set_test_uint32(int index, uint32_t value) {
  _impl_.test_uint32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_uint32)
}
inline void TestMess::_internal_add_test_uint32(uint32_t value) {
  _impl_.test_uint32_.Add(value);
}
inline void TestMess::add_test_uint32(uint32_t value) {
  _internal_add_test_uint32(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_uint32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMess::_internal_test_uint32() const {
  return _impl_.test_uint32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMess::test_uint32() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_uint32)
  return _internal_test_uint32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMess::_internal_mutable_test_uint32() {
  return &_impl_.test_uint32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMess::mutable_test_uint32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_uint32)
  return _internal_mutable_test_uint32();
}

// repeated fixed32 test_fixed32 = 8;
inline int TestMess::_internal_test_fixed32_size() const {
  return _impl_.test_fixed32_.size();
}
inline int TestMess::test_fixed32_size() const {
  return _internal_test_fixed32_size();
}
inline void TestMess::clear_test_fixed32() {
  _impl_.test_fixed32_.Clear();
}
inline uint32_t TestMess::_internal_test_fixed32(int index) const {
  return _impl_.test_fixed32_.Get(index);
}
inline uint32_t TestMess::test_fixed32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_fixed32)
  return _internal_test_fixed32(index);
}
inline void TestMess::set_test_fixed32(int index, uint32_t value) {
  _impl_.test_fixed32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_fixed32)
}
inline void TestMess::_internal_add_test_fixed32(uint32_t value) {
  _impl_.test_fixed32_.Add(value);
}
inline void TestMess::add_test_fixed32(uint32_t value) {
  _internal_add_test_fixed32(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_fixed32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMess::_internal_test_fixed32() const {
  return _impl_.test_fixed32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMess::test_fixed32() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_fixed32)
  return _internal_test_fixed32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMess::_internal_mutable_test_fixed32() {
  return &_impl_.test_fixed32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMess::mutable_test_fixed32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_fixed32)
  return _internal_mutable_test_fixed32();
}

// repeated uint64 test_uint64 = 9;
inline int TestMess::_internal_test_uint64_size() const {
  return _impl_.test_uint64_.size();
}
inline int TestMess::test_uint64_size() const {
  return _internal_test_uint64_size();
}
inline void TestMess::clear_test_uint64() {
  _impl_.test_uint64_.Clear();
}
inline uint64_t TestMess::_internal_test_uint64(int index) const {
  return _impl_.test_uint64_.Get(index);
}
inline uint64_t TestMess::test_uint64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_uint64)
  return _internal_test_uint64(index);
}
inline void TestMess::set_test_uint64(int index, uint64_t value) {
  _impl_.test_uint64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_uint64)
}
inline void TestMess::_internal_add_test_uint64(uint64_t value) {
  _impl_.test_uint64_.Add(value);
}
inline void TestMess::add_test_uint64(uint64_t value) {
  _internal_add_test_uint64(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_uint64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMess::_internal_test_uint64() const {
  return _impl_.test_uint64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMess::test_uint64() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_uint64)
  return _internal_test_uint64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMess::_internal_mutable_test_uint64() {
  return &_impl_.test_uint64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMess::mutable_test_uint64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_uint64)
  return _internal_mutable_test_uint64();
}

// repeated fixed64 test_fixed64 = 10;
inline int TestMess::_internal_test_fixed64_size() const {
  return _impl_.test_fixed64_.size();
}
inline int TestMess::test_fixed64_size() const {
  return _internal_test_fixed64_size();
}
inline void TestMess::clear_test_fixed64() {
  _impl_.test_fixed64_.Clear();
}
inline uint64_t TestMess::_internal_test_fixed64(int index) const {
  return _impl_.test_fixed64_.Get(index);
}
inline uint64_t TestMess::test_fixed64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_fixed64)
  return _internal_test_fixed64(index);
}
inline void TestMess::set_test_fixed64(int index, uint64_t value) {
  _impl_.test_fixed64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_fixed64)
}
inline void TestMess::_internal_add_test_fixed64(uint64_t value) {
  _impl_.test_fixed64_.Add(value);
}
inline void TestMess::add_test_fixed64(uint64_t value) {
  _internal_add_test_fixed64(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_fixed64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMess::_internal_test_fixed64() const {
  return _impl_.test_fixed64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMess::test_fixed64() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_fixed64)
  return _internal_test_fixed64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMess::_internal_mutable_test_fixed64() {
  return &_impl_.test_fixed64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMess::mutable_test_fixed64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_fixed64)
  return _internal_mutable_test_fixed64();
}

// repeated float test_float = 11;
inline int TestMess::_internal_test_float_size() const {
  return _impl_.test_float_.size();
}
inline int TestMess::test_float_size() const {
  return _internal_test_float_size();
}
inline void TestMess::clear_test_float() {
  _impl_.test_float_.Clear();
}
inline float TestMess::_internal_test_float(int index) const {
  return _impl_.test_float_.Get(index);
}
inline float TestMess::test_float(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_float)
  return _internal_test_float(index);
}
inline void TestMess::set_test_float(int index, float value) {
  _impl_.test_float_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_float)
}
inline void TestMess::_internal_add_test_float(float value) {
  _impl_.test_float_.Add(value);
}
inline void TestMess::add_test_float(float value) {
  _internal_add_test_float(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_float)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestMess::_internal_test_float() const {
  return _impl_.test_float_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestMess::test_float() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_float)
  return _internal_test_float();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestMess::_internal_mutable_test_float() {
  return &_impl_.test_float_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestMess::mutable_test_float() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_float)
  return _internal_mutable_test_float();
}

// repeated double test_double = 12;
inline int TestMess::_internal_test_double_size() const {
  return _impl_.test_double_.size();
}
inline int TestMess::test_double_size() const {
  return _internal_test_double_size();
}
inline void TestMess::clear_test_double() {
  _impl_.test_double_.Clear();
}
inline double TestMess::_internal_test_double(int index) const {
  return _impl_.test_double_.Get(index);
}
inline double TestMess::test_double(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_double)
  return _internal_test_double(index);
}
inline void TestMess::set_test_double(int index, double value) {
  _impl_.test_double_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_double)
}
inline void TestMess::_internal_add_test_double(double value) {
  _impl_.test_double_.Add(value);
}
inline void TestMess::add_test_double(double value) {
  _internal_add_test_double(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_double)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestMess::_internal_test_double() const {
  return _impl_.test_double_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestMess::test_double() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_double)
  return _internal_test_double();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestMess::_internal_mutable_test_double() {
  return &_impl_.test_double_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestMess::mutable_test_double() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_double)
  return _internal_mutable_test_double();
}

// repeated bool test_boolean = 13;
inline int TestMess::_internal_test_boolean_size() const {
  return _impl_.test_boolean_.size();
}
inline int TestMess::test_boolean_size() const {
  return _internal_test_boolean_size();
}
inline void TestMess::clear_test_boolean() {
  _impl_.test_boolean_.Clear();
}
inline bool TestMess::_internal_test_boolean(int index) const {
  return _impl_.test_boolean_.Get(index);
}
inline bool TestMess::test_boolean(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_boolean)
  return _internal_test_boolean(index);
}
inline void TestMess::set_test_boolean(int index, bool value) {
  _impl_.test_boolean_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_boolean)
}
inline void TestMess::_internal_add_test_boolean(bool value) {
  _impl_.test_boolean_.Add(value);
}
inline void TestMess::add_test_boolean(bool value) {
  _internal_add_test_boolean(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_boolean)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestMess::_internal_test_boolean() const {
  return _impl_.test_boolean_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestMess::test_boolean() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_boolean)
  return _internal_test_boolean();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestMess::_internal_mutable_test_boolean() {
  return &_impl_.test_boolean_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestMess::mutable_test_boolean() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_boolean)
  return _internal_mutable_test_boolean();
}

// repeated .foo.TestEnumSmall test_enum_small = 14;
inline int TestMess::_internal_test_enum_small_size() const {
  return _impl_.test_enum_small_.size();
}
inline int TestMess::test_enum_small_size() const {
  return _internal_test_enum_small_size();
}
inline void TestMess::clear_test_enum_small() {
  _impl_.test_enum_small_.Clear();
}
inline ::foo::TestEnumSmall TestMess::_internal_test_enum_small(int index) const {
  return static_cast< ::foo::TestEnumSmall >(_impl_.test_enum_small_.Get(index));
}
inline ::foo::TestEnumSmall TestMess::test_enum_small(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_enum_small)
  return _internal_test_enum_small(index);
}
inline void TestMess::set_test_enum_small(int index, ::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_.test_enum_small_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_enum_small)
}
inline void TestMess::_internal_add_test_enum_small(::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_.test_enum_small_.Add(value);
}
inline void TestMess::add_test_enum_small(::foo::TestEnumSmall value) {
  _internal_add_test_enum_small(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_enum_small)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TestMess::test_enum_small() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_enum_small)
  return _impl_.test_enum_small_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMess::_internal_mutable_test_enum_small() {
  return &_impl_.test_enum_small_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMess::mutable_test_enum_small() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_enum_small)
  return _internal_mutable_test_enum_small();
}

// repeated .foo.TestEnum test_enum = 15;
inline int TestMess::_internal_test_enum_size() const {
  return _impl_.test_enum_.size();
}
inline int TestMess::test_enum_size() const {
  return _internal_test_enum_size();
}
inline void TestMess::clear_test_enum() {
  _impl_.test_enum_.Clear();
}
inline ::foo::TestEnum TestMess::_internal_test_enum(int index) const {
  return static_cast< ::foo::TestEnum >(_impl_.test_enum_.Get(index));
}
inline ::foo::TestEnum TestMess::test_enum(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_enum)
  return _internal_test_enum(index);
}
inline void TestMess::set_test_enum(int index, ::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_.test_enum_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_enum)
}
inline void TestMess::_internal_add_test_enum(::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_.test_enum_.Add(value);
}
inline void TestMess::add_test_enum(::foo::TestEnum value) {
  _internal_add_test_enum(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_enum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TestMess::test_enum() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_enum)
  return _impl_.test_enum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMess::_internal_mutable_test_enum() {
  return &_impl_.test_enum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMess::mutable_test_enum() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_enum)
  return _internal_mutable_test_enum();
}

// repeated string test_string = 16;
inline int TestMess::_internal_test_string_size() const {
  return _impl_.test_string_.size();
}
inline int TestMess::test_string_size() const {
  return _internal_test_string_size();
}
inline void TestMess::clear_test_string() {
  _impl_.test_string_.Clear();
}
inline std::string* TestMess::add_test_string() {
  std::string* _s = _internal_add_test_string();
  // @@protoc_insertion_point(field_add_mutable:foo.TestMess.test_string)
  return _s;
}
inline const std::string& TestMess::_internal_test_string(int index) const {
  return _impl_.test_string_.Get(index);
}
inline const std::string& TestMess::test_string(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_string)
  return _internal_test_string(index);
}
inline std::string* TestMess::mutable_test_string(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMess.test_string)
  return _impl_.test_string_.Mutable(index);
}
inline void TestMess::set_test_string(int index, const std::string& value) {
  _impl_.test_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_string)
}
inline void TestMess::set_test_string(int index, std::string&& value) {
  _impl_.test_string_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:foo.TestMess.test_string)
}
inline void TestMess::set_test_string(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.test_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:foo.TestMess.test_string)
}
inline void TestMess::set_test_string(int index, const char* value, size_t size) {
  _impl_.test_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:foo.TestMess.test_string)
}
inline std::string* TestMess::_internal_add_test_string() {
  return _impl_.test_string_.Add();
}
inline void TestMess::add_test_string(const std::string& value) {
  _impl_.test_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_string)
}
inline void TestMess::add_test_string(std::string&& value) {
  _impl_.test_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:foo.TestMess.test_string)
}
inline void TestMess::add_test_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.test_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:foo.TestMess.test_string)
}
inline void TestMess::add_test_string(const char* value, size_t size) {
  _impl_.test_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:foo.TestMess.test_string)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestMess::test_string() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_string)
  return _impl_.test_string_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestMess::mutable_test_string() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_string)
  return &_impl_.test_string_;
}

// repeated bytes test_bytes = 17;
inline int TestMess::_internal_test_bytes_size() const {
  return _impl_.test_bytes_.size();
}
inline int TestMess::test_bytes_size() const {
  return _internal_test_bytes_size();
}
inline void TestMess::clear_test_bytes() {
  _impl_.test_bytes_.Clear();
}
inline std::string* TestMess::add_test_bytes() {
  std::string* _s = _internal_add_test_bytes();
  // @@protoc_insertion_point(field_add_mutable:foo.TestMess.test_bytes)
  return _s;
}
inline const std::string& TestMess::_internal_test_bytes(int index) const {
  return _impl_.test_bytes_.Get(index);
}
inline const std::string& TestMess::test_bytes(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_bytes)
  return _internal_test_bytes(index);
}
inline std::string* TestMess::mutable_test_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMess.test_bytes)
  return _impl_.test_bytes_.Mutable(index);
}
inline void TestMess::set_test_bytes(int index, const std::string& value) {
  _impl_.test_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:foo.TestMess.test_bytes)
}
inline void TestMess::set_test_bytes(int index, std::string&& value) {
  _impl_.test_bytes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:foo.TestMess.test_bytes)
}
inline void TestMess::set_test_bytes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.test_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:foo.TestMess.test_bytes)
}
inline void TestMess::set_test_bytes(int index, const void* value, size_t size) {
  _impl_.test_bytes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:foo.TestMess.test_bytes)
}
inline std::string* TestMess::_internal_add_test_bytes() {
  return _impl_.test_bytes_.Add();
}
inline void TestMess::add_test_bytes(const std::string& value) {
  _impl_.test_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:foo.TestMess.test_bytes)
}
inline void TestMess::add_test_bytes(std::string&& value) {
  _impl_.test_bytes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:foo.TestMess.test_bytes)
}
inline void TestMess::add_test_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.test_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:foo.TestMess.test_bytes)
}
inline void TestMess::add_test_bytes(const void* value, size_t size) {
  _impl_.test_bytes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:foo.TestMess.test_bytes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestMess::test_bytes() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_bytes)
  return _impl_.test_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestMess::mutable_test_bytes() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_bytes)
  return &_impl_.test_bytes_;
}

// repeated .foo.SubMess test_message = 18;
inline int TestMess::_internal_test_message_size() const {
  return _impl_.test_message_.size();
}
inline int TestMess::test_message_size() const {
  return _internal_test_message_size();
}
inline void TestMess::clear_test_message() {
  _impl_.test_message_.Clear();
}
inline ::foo::SubMess* TestMess::mutable_test_message(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMess.test_message)
  return _impl_.test_message_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::SubMess >*
TestMess::mutable_test_message() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMess.test_message)
  return &_impl_.test_message_;
}
inline const ::foo::SubMess& TestMess::_internal_test_message(int index) const {
  return _impl_.test_message_.Get(index);
}
inline const ::foo::SubMess& TestMess::test_message(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMess.test_message)
  return _internal_test_message(index);
}
inline ::foo::SubMess* TestMess::_internal_add_test_message() {
  return _impl_.test_message_.Add();
}
inline ::foo::SubMess* TestMess::add_test_message() {
  ::foo::SubMess* _add = _internal_add_test_message();
  // @@protoc_insertion_point(field_add:foo.TestMess.test_message)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::SubMess >&
TestMess::test_message() const {
  // @@protoc_insertion_point(field_list:foo.TestMess.test_message)
  return _impl_.test_message_;
}

// -------------------------------------------------------------------

// TestMessPacked

// repeated int32 test_int32 = 1 [packed = true];
inline int TestMessPacked::_internal_test_int32_size() const {
  return _impl_.test_int32_.size();
}
inline int TestMessPacked::test_int32_size() const {
  return _internal_test_int32_size();
}
inline void TestMessPacked::clear_test_int32() {
  _impl_.test_int32_.Clear();
}
inline int32_t TestMessPacked::_internal_test_int32(int index) const {
  return _impl_.test_int32_.Get(index);
}
inline int32_t TestMessPacked::test_int32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_int32)
  return _internal_test_int32(index);
}
inline void TestMessPacked::set_test_int32(int index, int32_t value) {
  _impl_.test_int32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_int32)
}
inline void TestMessPacked::_internal_add_test_int32(int32_t value) {
  _impl_.test_int32_.Add(value);
}
inline void TestMessPacked::add_test_int32(int32_t value) {
  _internal_add_test_int32(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_int32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::_internal_test_int32() const {
  return _impl_.test_int32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::test_int32() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_int32)
  return _internal_test_int32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::_internal_mutable_test_int32() {
  return &_impl_.test_int32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::mutable_test_int32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_int32)
  return _internal_mutable_test_int32();
}

// repeated sint32 test_sint32 = 2 [packed = true];
inline int TestMessPacked::_internal_test_sint32_size() const {
  return _impl_.test_sint32_.size();
}
inline int TestMessPacked::test_sint32_size() const {
  return _internal_test_sint32_size();
}
inline void TestMessPacked::clear_test_sint32() {
  _impl_.test_sint32_.Clear();
}
inline int32_t TestMessPacked::_internal_test_sint32(int index) const {
  return _impl_.test_sint32_.Get(index);
}
inline int32_t TestMessPacked::test_sint32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_sint32)
  return _internal_test_sint32(index);
}
inline void TestMessPacked::set_test_sint32(int index, int32_t value) {
  _impl_.test_sint32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_sint32)
}
inline void TestMessPacked::_internal_add_test_sint32(int32_t value) {
  _impl_.test_sint32_.Add(value);
}
inline void TestMessPacked::add_test_sint32(int32_t value) {
  _internal_add_test_sint32(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_sint32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::_internal_test_sint32() const {
  return _impl_.test_sint32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::test_sint32() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_sint32)
  return _internal_test_sint32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::_internal_mutable_test_sint32() {
  return &_impl_.test_sint32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::mutable_test_sint32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_sint32)
  return _internal_mutable_test_sint32();
}

// repeated sfixed32 test_sfixed32 = 3 [packed = true];
inline int TestMessPacked::_internal_test_sfixed32_size() const {
  return _impl_.test_sfixed32_.size();
}
inline int TestMessPacked::test_sfixed32_size() const {
  return _internal_test_sfixed32_size();
}
inline void TestMessPacked::clear_test_sfixed32() {
  _impl_.test_sfixed32_.Clear();
}
inline int32_t TestMessPacked::_internal_test_sfixed32(int index) const {
  return _impl_.test_sfixed32_.Get(index);
}
inline int32_t TestMessPacked::test_sfixed32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_sfixed32)
  return _internal_test_sfixed32(index);
}
inline void TestMessPacked::set_test_sfixed32(int index, int32_t value) {
  _impl_.test_sfixed32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_sfixed32)
}
inline void TestMessPacked::_internal_add_test_sfixed32(int32_t value) {
  _impl_.test_sfixed32_.Add(value);
}
inline void TestMessPacked::add_test_sfixed32(int32_t value) {
  _internal_add_test_sfixed32(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_sfixed32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::_internal_test_sfixed32() const {
  return _impl_.test_sfixed32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestMessPacked::test_sfixed32() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_sfixed32)
  return _internal_test_sfixed32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::_internal_mutable_test_sfixed32() {
  return &_impl_.test_sfixed32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestMessPacked::mutable_test_sfixed32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_sfixed32)
  return _internal_mutable_test_sfixed32();
}

// repeated int64 test_int64 = 4 [packed = true];
inline int TestMessPacked::_internal_test_int64_size() const {
  return _impl_.test_int64_.size();
}
inline int TestMessPacked::test_int64_size() const {
  return _internal_test_int64_size();
}
inline void TestMessPacked::clear_test_int64() {
  _impl_.test_int64_.Clear();
}
inline int64_t TestMessPacked::_internal_test_int64(int index) const {
  return _impl_.test_int64_.Get(index);
}
inline int64_t TestMessPacked::test_int64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_int64)
  return _internal_test_int64(index);
}
inline void TestMessPacked::set_test_int64(int index, int64_t value) {
  _impl_.test_int64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_int64)
}
inline void TestMessPacked::_internal_add_test_int64(int64_t value) {
  _impl_.test_int64_.Add(value);
}
inline void TestMessPacked::add_test_int64(int64_t value) {
  _internal_add_test_int64(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_int64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::_internal_test_int64() const {
  return _impl_.test_int64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::test_int64() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_int64)
  return _internal_test_int64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::_internal_mutable_test_int64() {
  return &_impl_.test_int64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::mutable_test_int64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_int64)
  return _internal_mutable_test_int64();
}

// repeated sint64 test_sint64 = 5 [packed = true];
inline int TestMessPacked::_internal_test_sint64_size() const {
  return _impl_.test_sint64_.size();
}
inline int TestMessPacked::test_sint64_size() const {
  return _internal_test_sint64_size();
}
inline void TestMessPacked::clear_test_sint64() {
  _impl_.test_sint64_.Clear();
}
inline int64_t TestMessPacked::_internal_test_sint64(int index) const {
  return _impl_.test_sint64_.Get(index);
}
inline int64_t TestMessPacked::test_sint64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_sint64)
  return _internal_test_sint64(index);
}
inline void TestMessPacked::set_test_sint64(int index, int64_t value) {
  _impl_.test_sint64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_sint64)
}
inline void TestMessPacked::_internal_add_test_sint64(int64_t value) {
  _impl_.test_sint64_.Add(value);
}
inline void TestMessPacked::add_test_sint64(int64_t value) {
  _internal_add_test_sint64(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_sint64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::_internal_test_sint64() const {
  return _impl_.test_sint64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::test_sint64() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_sint64)
  return _internal_test_sint64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::_internal_mutable_test_sint64() {
  return &_impl_.test_sint64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::mutable_test_sint64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_sint64)
  return _internal_mutable_test_sint64();
}

// repeated sfixed64 test_sfixed64 = 6 [packed = true];
inline int TestMessPacked::_internal_test_sfixed64_size() const {
  return _impl_.test_sfixed64_.size();
}
inline int TestMessPacked::test_sfixed64_size() const {
  return _internal_test_sfixed64_size();
}
inline void TestMessPacked::clear_test_sfixed64() {
  _impl_.test_sfixed64_.Clear();
}
inline int64_t TestMessPacked::_internal_test_sfixed64(int index) const {
  return _impl_.test_sfixed64_.Get(index);
}
inline int64_t TestMessPacked::test_sfixed64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_sfixed64)
  return _internal_test_sfixed64(index);
}
inline void TestMessPacked::set_test_sfixed64(int index, int64_t value) {
  _impl_.test_sfixed64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_sfixed64)
}
inline void TestMessPacked::_internal_add_test_sfixed64(int64_t value) {
  _impl_.test_sfixed64_.Add(value);
}
inline void TestMessPacked::add_test_sfixed64(int64_t value) {
  _internal_add_test_sfixed64(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_sfixed64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::_internal_test_sfixed64() const {
  return _impl_.test_sfixed64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TestMessPacked::test_sfixed64() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_sfixed64)
  return _internal_test_sfixed64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::_internal_mutable_test_sfixed64() {
  return &_impl_.test_sfixed64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TestMessPacked::mutable_test_sfixed64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_sfixed64)
  return _internal_mutable_test_sfixed64();
}

// repeated uint32 test_uint32 = 7 [packed = true];
inline int TestMessPacked::_internal_test_uint32_size() const {
  return _impl_.test_uint32_.size();
}
inline int TestMessPacked::test_uint32_size() const {
  return _internal_test_uint32_size();
}
inline void TestMessPacked::clear_test_uint32() {
  _impl_.test_uint32_.Clear();
}
inline uint32_t TestMessPacked::_internal_test_uint32(int index) const {
  return _impl_.test_uint32_.Get(index);
}
inline uint32_t TestMessPacked::test_uint32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_uint32)
  return _internal_test_uint32(index);
}
inline void TestMessPacked::set_test_uint32(int index, uint32_t value) {
  _impl_.test_uint32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_uint32)
}
inline void TestMessPacked::_internal_add_test_uint32(uint32_t value) {
  _impl_.test_uint32_.Add(value);
}
inline void TestMessPacked::add_test_uint32(uint32_t value) {
  _internal_add_test_uint32(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_uint32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMessPacked::_internal_test_uint32() const {
  return _impl_.test_uint32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMessPacked::test_uint32() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_uint32)
  return _internal_test_uint32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMessPacked::_internal_mutable_test_uint32() {
  return &_impl_.test_uint32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMessPacked::mutable_test_uint32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_uint32)
  return _internal_mutable_test_uint32();
}

// repeated fixed32 test_fixed32 = 8 [packed = true];
inline int TestMessPacked::_internal_test_fixed32_size() const {
  return _impl_.test_fixed32_.size();
}
inline int TestMessPacked::test_fixed32_size() const {
  return _internal_test_fixed32_size();
}
inline void TestMessPacked::clear_test_fixed32() {
  _impl_.test_fixed32_.Clear();
}
inline uint32_t TestMessPacked::_internal_test_fixed32(int index) const {
  return _impl_.test_fixed32_.Get(index);
}
inline uint32_t TestMessPacked::test_fixed32(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_fixed32)
  return _internal_test_fixed32(index);
}
inline void TestMessPacked::set_test_fixed32(int index, uint32_t value) {
  _impl_.test_fixed32_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_fixed32)
}
inline void TestMessPacked::_internal_add_test_fixed32(uint32_t value) {
  _impl_.test_fixed32_.Add(value);
}
inline void TestMessPacked::add_test_fixed32(uint32_t value) {
  _internal_add_test_fixed32(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_fixed32)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMessPacked::_internal_test_fixed32() const {
  return _impl_.test_fixed32_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
TestMessPacked::test_fixed32() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_fixed32)
  return _internal_test_fixed32();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMessPacked::_internal_mutable_test_fixed32() {
  return &_impl_.test_fixed32_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
TestMessPacked::mutable_test_fixed32() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_fixed32)
  return _internal_mutable_test_fixed32();
}

// repeated uint64 test_uint64 = 9 [packed = true];
inline int TestMessPacked::_internal_test_uint64_size() const {
  return _impl_.test_uint64_.size();
}
inline int TestMessPacked::test_uint64_size() const {
  return _internal_test_uint64_size();
}
inline void TestMessPacked::clear_test_uint64() {
  _impl_.test_uint64_.Clear();
}
inline uint64_t TestMessPacked::_internal_test_uint64(int index) const {
  return _impl_.test_uint64_.Get(index);
}
inline uint64_t TestMessPacked::test_uint64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_uint64)
  return _internal_test_uint64(index);
}
inline void TestMessPacked::set_test_uint64(int index, uint64_t value) {
  _impl_.test_uint64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_uint64)
}
inline void TestMessPacked::_internal_add_test_uint64(uint64_t value) {
  _impl_.test_uint64_.Add(value);
}
inline void TestMessPacked::add_test_uint64(uint64_t value) {
  _internal_add_test_uint64(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_uint64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMessPacked::_internal_test_uint64() const {
  return _impl_.test_uint64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMessPacked::test_uint64() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_uint64)
  return _internal_test_uint64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMessPacked::_internal_mutable_test_uint64() {
  return &_impl_.test_uint64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMessPacked::mutable_test_uint64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_uint64)
  return _internal_mutable_test_uint64();
}

// repeated fixed64 test_fixed64 = 10 [packed = true];
inline int TestMessPacked::_internal_test_fixed64_size() const {
  return _impl_.test_fixed64_.size();
}
inline int TestMessPacked::test_fixed64_size() const {
  return _internal_test_fixed64_size();
}
inline void TestMessPacked::clear_test_fixed64() {
  _impl_.test_fixed64_.Clear();
}
inline uint64_t TestMessPacked::_internal_test_fixed64(int index) const {
  return _impl_.test_fixed64_.Get(index);
}
inline uint64_t TestMessPacked::test_fixed64(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_fixed64)
  return _internal_test_fixed64(index);
}
inline void TestMessPacked::set_test_fixed64(int index, uint64_t value) {
  _impl_.test_fixed64_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_fixed64)
}
inline void TestMessPacked::_internal_add_test_fixed64(uint64_t value) {
  _impl_.test_fixed64_.Add(value);
}
inline void TestMessPacked::add_test_fixed64(uint64_t value) {
  _internal_add_test_fixed64(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_fixed64)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMessPacked::_internal_test_fixed64() const {
  return _impl_.test_fixed64_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TestMessPacked::test_fixed64() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_fixed64)
  return _internal_test_fixed64();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMessPacked::_internal_mutable_test_fixed64() {
  return &_impl_.test_fixed64_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TestMessPacked::mutable_test_fixed64() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_fixed64)
  return _internal_mutable_test_fixed64();
}

// repeated float test_float = 11 [packed = true];
inline int TestMessPacked::_internal_test_float_size() const {
  return _impl_.test_float_.size();
}
inline int TestMessPacked::test_float_size() const {
  return _internal_test_float_size();
}
inline void TestMessPacked::clear_test_float() {
  _impl_.test_float_.Clear();
}
inline float TestMessPacked::_internal_test_float(int index) const {
  return _impl_.test_float_.Get(index);
}
inline float TestMessPacked::test_float(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_float)
  return _internal_test_float(index);
}
inline void TestMessPacked::set_test_float(int index, float value) {
  _impl_.test_float_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_float)
}
inline void TestMessPacked::_internal_add_test_float(float value) {
  _impl_.test_float_.Add(value);
}
inline void TestMessPacked::add_test_float(float value) {
  _internal_add_test_float(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_float)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestMessPacked::_internal_test_float() const {
  return _impl_.test_float_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TestMessPacked::test_float() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_float)
  return _internal_test_float();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestMessPacked::_internal_mutable_test_float() {
  return &_impl_.test_float_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TestMessPacked::mutable_test_float() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_float)
  return _internal_mutable_test_float();
}

// repeated double test_double = 12 [packed = true];
inline int TestMessPacked::_internal_test_double_size() const {
  return _impl_.test_double_.size();
}
inline int TestMessPacked::test_double_size() const {
  return _internal_test_double_size();
}
inline void TestMessPacked::clear_test_double() {
  _impl_.test_double_.Clear();
}
inline double TestMessPacked::_internal_test_double(int index) const {
  return _impl_.test_double_.Get(index);
}
inline double TestMessPacked::test_double(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_double)
  return _internal_test_double(index);
}
inline void TestMessPacked::set_test_double(int index, double value) {
  _impl_.test_double_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_double)
}
inline void TestMessPacked::_internal_add_test_double(double value) {
  _impl_.test_double_.Add(value);
}
inline void TestMessPacked::add_test_double(double value) {
  _internal_add_test_double(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_double)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestMessPacked::_internal_test_double() const {
  return _impl_.test_double_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TestMessPacked::test_double() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_double)
  return _internal_test_double();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestMessPacked::_internal_mutable_test_double() {
  return &_impl_.test_double_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TestMessPacked::mutable_test_double() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_double)
  return _internal_mutable_test_double();
}

// repeated bool test_boolean = 13 [packed = true];
inline int TestMessPacked::_internal_test_boolean_size() const {
  return _impl_.test_boolean_.size();
}
inline int TestMessPacked::test_boolean_size() const {
  return _internal_test_boolean_size();
}
inline void TestMessPacked::clear_test_boolean() {
  _impl_.test_boolean_.Clear();
}
inline bool TestMessPacked::_internal_test_boolean(int index) const {
  return _impl_.test_boolean_.Get(index);
}
inline bool TestMessPacked::test_boolean(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_boolean)
  return _internal_test_boolean(index);
}
inline void TestMessPacked::set_test_boolean(int index, bool value) {
  _impl_.test_boolean_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_boolean)
}
inline void TestMessPacked::_internal_add_test_boolean(bool value) {
  _impl_.test_boolean_.Add(value);
}
inline void TestMessPacked::add_test_boolean(bool value) {
  _internal_add_test_boolean(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_boolean)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestMessPacked::_internal_test_boolean() const {
  return _impl_.test_boolean_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
TestMessPacked::test_boolean() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_boolean)
  return _internal_test_boolean();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestMessPacked::_internal_mutable_test_boolean() {
  return &_impl_.test_boolean_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
TestMessPacked::mutable_test_boolean() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_boolean)
  return _internal_mutable_test_boolean();
}

// repeated .foo.TestEnumSmall test_enum_small = 14 [packed = true];
inline int TestMessPacked::_internal_test_enum_small_size() const {
  return _impl_.test_enum_small_.size();
}
inline int TestMessPacked::test_enum_small_size() const {
  return _internal_test_enum_small_size();
}
inline void TestMessPacked::clear_test_enum_small() {
  _impl_.test_enum_small_.Clear();
}
inline ::foo::TestEnumSmall TestMessPacked::_internal_test_enum_small(int index) const {
  return static_cast< ::foo::TestEnumSmall >(_impl_.test_enum_small_.Get(index));
}
inline ::foo::TestEnumSmall TestMessPacked::test_enum_small(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_enum_small)
  return _internal_test_enum_small(index);
}
inline void TestMessPacked::set_test_enum_small(int index, ::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_.test_enum_small_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_enum_small)
}
inline void TestMessPacked::_internal_add_test_enum_small(::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_.test_enum_small_.Add(value);
}
inline void TestMessPacked::add_test_enum_small(::foo::TestEnumSmall value) {
  _internal_add_test_enum_small(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_enum_small)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TestMessPacked::test_enum_small() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_enum_small)
  return _impl_.test_enum_small_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMessPacked::_internal_mutable_test_enum_small() {
  return &_impl_.test_enum_small_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMessPacked::mutable_test_enum_small() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_enum_small)
  return _internal_mutable_test_enum_small();
}

// repeated .foo.TestEnum test_enum = 15 [packed = true];
inline int TestMessPacked::_internal_test_enum_size() const {
  return _impl_.test_enum_.size();
}
inline int TestMessPacked::test_enum_size() const {
  return _internal_test_enum_size();
}
inline void TestMessPacked::clear_test_enum() {
  _impl_.test_enum_.Clear();
}
inline ::foo::TestEnum TestMessPacked::_internal_test_enum(int index) const {
  return static_cast< ::foo::TestEnum >(_impl_.test_enum_.Get(index));
}
inline ::foo::TestEnum TestMessPacked::test_enum(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessPacked.test_enum)
  return _internal_test_enum(index);
}
inline void TestMessPacked::set_test_enum(int index, ::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_.test_enum_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestMessPacked.test_enum)
}
inline void TestMessPacked::_internal_add_test_enum(::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_.test_enum_.Add(value);
}
inline void TestMessPacked::add_test_enum(::foo::TestEnum value) {
  _internal_add_test_enum(value);
  // @@protoc_insertion_point(field_add:foo.TestMessPacked.test_enum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TestMessPacked::test_enum() const {
  // @@protoc_insertion_point(field_list:foo.TestMessPacked.test_enum)
  return _impl_.test_enum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMessPacked::_internal_mutable_test_enum() {
  return &_impl_.test_enum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TestMessPacked::mutable_test_enum() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessPacked.test_enum)
  return _internal_mutable_test_enum();
}

// -------------------------------------------------------------------

// TestMessOptional

// optional int32 test_int32 = 1;
inline bool TestMessOptional::_internal_has_test_int32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_int32() const {
  return _internal_has_test_int32();
}
inline void TestMessOptional::clear_test_int32() {
  _impl_.test_int32_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TestMessOptional::_internal_test_int32() const {
  return _impl_.test_int32_;
}
inline int32_t TestMessOptional::test_int32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_int32)
  return _internal_test_int32();
}
inline void TestMessOptional::_internal_set_test_int32(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.test_int32_ = value;
}
inline void TestMessOptional::set_test_int32(int32_t value) {
  _internal_set_test_int32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_int32)
}

// optional sint32 test_sint32 = 2;
inline bool TestMessOptional::_internal_has_test_sint32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_sint32() const {
  return _internal_has_test_sint32();
}
inline void TestMessOptional::clear_test_sint32() {
  _impl_.test_sint32_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TestMessOptional::_internal_test_sint32() const {
  return _impl_.test_sint32_;
}
inline int32_t TestMessOptional::test_sint32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_sint32)
  return _internal_test_sint32();
}
inline void TestMessOptional::_internal_set_test_sint32(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.test_sint32_ = value;
}
inline void TestMessOptional::set_test_sint32(int32_t value) {
  _internal_set_test_sint32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_sint32)
}

// optional sfixed32 test_sfixed32 = 3;
inline bool TestMessOptional::_internal_has_test_sfixed32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_sfixed32() const {
  return _internal_has_test_sfixed32();
}
inline void TestMessOptional::clear_test_sfixed32() {
  _impl_.test_sfixed32_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t TestMessOptional::_internal_test_sfixed32() const {
  return _impl_.test_sfixed32_;
}
inline int32_t TestMessOptional::test_sfixed32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_sfixed32)
  return _internal_test_sfixed32();
}
inline void TestMessOptional::_internal_set_test_sfixed32(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.test_sfixed32_ = value;
}
inline void TestMessOptional::set_test_sfixed32(int32_t value) {
  _internal_set_test_sfixed32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_sfixed32)
}

// optional int64 test_int64 = 4;
inline bool TestMessOptional::_internal_has_test_int64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_int64() const {
  return _internal_has_test_int64();
}
inline void TestMessOptional::clear_test_int64() {
  _impl_.test_int64_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t TestMessOptional::_internal_test_int64() const {
  return _impl_.test_int64_;
}
inline int64_t TestMessOptional::test_int64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_int64)
  return _internal_test_int64();
}
inline void TestMessOptional::_internal_set_test_int64(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.test_int64_ = value;
}
inline void TestMessOptional::set_test_int64(int64_t value) {
  _internal_set_test_int64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_int64)
}

// optional sint64 test_sint64 = 5;
inline bool TestMessOptional::_internal_has_test_sint64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_sint64() const {
  return _internal_has_test_sint64();
}
inline void TestMessOptional::clear_test_sint64() {
  _impl_.test_sint64_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t TestMessOptional::_internal_test_sint64() const {
  return _impl_.test_sint64_;
}
inline int64_t TestMessOptional::test_sint64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_sint64)
  return _internal_test_sint64();
}
inline void TestMessOptional::_internal_set_test_sint64(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.test_sint64_ = value;
}
inline void TestMessOptional::set_test_sint64(int64_t value) {
  _internal_set_test_sint64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_sint64)
}

// optional sfixed64 test_sfixed64 = 6;
inline bool TestMessOptional::_internal_has_test_sfixed64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_sfixed64() const {
  return _internal_has_test_sfixed64();
}
inline void TestMessOptional::clear_test_sfixed64() {
  _impl_.test_sfixed64_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t TestMessOptional::_internal_test_sfixed64() const {
  return _impl_.test_sfixed64_;
}
inline int64_t TestMessOptional::test_sfixed64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_sfixed64)
  return _internal_test_sfixed64();
}
inline void TestMessOptional::_internal_set_test_sfixed64(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.test_sfixed64_ = value;
}
inline void TestMessOptional::set_test_sfixed64(int64_t value) {
  _internal_set_test_sfixed64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_sfixed64)
}

// optional uint32 test_uint32 = 7;
inline bool TestMessOptional::_internal_has_test_uint32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_uint32() const {
  return _internal_has_test_uint32();
}
inline void TestMessOptional::clear_test_uint32() {
  _impl_.test_uint32_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TestMessOptional::_internal_test_uint32() const {
  return _impl_.test_uint32_;
}
inline uint32_t TestMessOptional::test_uint32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_uint32)
  return _internal_test_uint32();
}
inline void TestMessOptional::_internal_set_test_uint32(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.test_uint32_ = value;
}
inline void TestMessOptional::set_test_uint32(uint32_t value) {
  _internal_set_test_uint32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_uint32)
}

// optional fixed32 test_fixed32 = 8;
inline bool TestMessOptional::_internal_has_test_fixed32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_fixed32() const {
  return _internal_has_test_fixed32();
}
inline void TestMessOptional::clear_test_fixed32() {
  _impl_.test_fixed32_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t TestMessOptional::_internal_test_fixed32() const {
  return _impl_.test_fixed32_;
}
inline uint32_t TestMessOptional::test_fixed32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_fixed32)
  return _internal_test_fixed32();
}
inline void TestMessOptional::_internal_set_test_fixed32(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.test_fixed32_ = value;
}
inline void TestMessOptional::set_test_fixed32(uint32_t value) {
  _internal_set_test_fixed32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_fixed32)
}

// optional uint64 test_uint64 = 9;
inline bool TestMessOptional::_internal_has_test_uint64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_uint64() const {
  return _internal_has_test_uint64();
}
inline void TestMessOptional::clear_test_uint64() {
  _impl_.test_uint64_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint64_t TestMessOptional::_internal_test_uint64() const {
  return _impl_.test_uint64_;
}
inline uint64_t TestMessOptional::test_uint64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_uint64)
  return _internal_test_uint64();
}
inline void TestMessOptional::_internal_set_test_uint64(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.test_uint64_ = value;
}
inline void TestMessOptional::set_test_uint64(uint64_t value) {
  _internal_set_test_uint64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_uint64)
}

// optional fixed64 test_fixed64 = 10;
inline bool TestMessOptional::_internal_has_test_fixed64() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_fixed64() const {
  return _internal_has_test_fixed64();
}
inline void TestMessOptional::clear_test_fixed64() {
  _impl_.test_fixed64_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint64_t TestMessOptional::_internal_test_fixed64() const {
  return _impl_.test_fixed64_;
}
inline uint64_t TestMessOptional::test_fixed64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_fixed64)
  return _internal_test_fixed64();
}
inline void TestMessOptional::_internal_set_test_fixed64(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.test_fixed64_ = value;
}
inline void TestMessOptional::set_test_fixed64(uint64_t value) {
  _internal_set_test_fixed64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_fixed64)
}

// optional float test_float = 11;
inline bool TestMessOptional::_internal_has_test_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_float() const {
  return _internal_has_test_float();
}
inline void TestMessOptional::clear_test_float() {
  _impl_.test_float_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float TestMessOptional::_internal_test_float() const {
  return _impl_.test_float_;
}
inline float TestMessOptional::test_float() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_float)
  return _internal_test_float();
}
inline void TestMessOptional::_internal_set_test_float(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.test_float_ = value;
}
inline void TestMessOptional::set_test_float(float value) {
  _internal_set_test_float(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_float)
}

// optional double test_double = 12;
inline bool TestMessOptional::_internal_has_test_double() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_double() const {
  return _internal_has_test_double();
}
inline void TestMessOptional::clear_test_double() {
  _impl_.test_double_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline double TestMessOptional::_internal_test_double() const {
  return _impl_.test_double_;
}
inline double TestMessOptional::test_double() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_double)
  return _internal_test_double();
}
inline void TestMessOptional::_internal_set_test_double(double value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.test_double_ = value;
}
inline void TestMessOptional::set_test_double(double value) {
  _internal_set_test_double(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_double)
}

// optional bool test_boolean = 13;
inline bool TestMessOptional::_internal_has_test_boolean() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_boolean() const {
  return _internal_has_test_boolean();
}
inline void TestMessOptional::clear_test_boolean() {
  _impl_.test_boolean_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool TestMessOptional::_internal_test_boolean() const {
  return _impl_.test_boolean_;
}
inline bool TestMessOptional::test_boolean() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_boolean)
  return _internal_test_boolean();
}
inline void TestMessOptional::_internal_set_test_boolean(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.test_boolean_ = value;
}
inline void TestMessOptional::set_test_boolean(bool value) {
  _internal_set_test_boolean(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_boolean)
}

// optional .foo.TestEnumSmall test_enum_small = 14;
inline bool TestMessOptional::_internal_has_test_enum_small() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_enum_small() const {
  return _internal_has_test_enum_small();
}
inline void TestMessOptional::clear_test_enum_small() {
  _impl_.test_enum_small_ = -1;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::foo::TestEnumSmall TestMessOptional::_internal_test_enum_small() const {
  return static_cast< ::foo::TestEnumSmall >(_impl_.test_enum_small_);
}
inline ::foo::TestEnumSmall TestMessOptional::test_enum_small() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_enum_small)
  return _internal_test_enum_small();
}
inline void TestMessOptional::_internal_set_test_enum_small(::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.test_enum_small_ = value;
}
inline void TestMessOptional::set_test_enum_small(::foo::TestEnumSmall value) {
  _internal_set_test_enum_small(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_enum_small)
}

// optional .foo.TestEnum test_enum = 15;
inline bool TestMessOptional::_internal_has_test_enum() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_enum() const {
  return _internal_has_test_enum();
}
inline void TestMessOptional::clear_test_enum() {
  _impl_.test_enum_ = -123456;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::foo::TestEnum TestMessOptional::_internal_test_enum() const {
  return static_cast< ::foo::TestEnum >(_impl_.test_enum_);
}
inline ::foo::TestEnum TestMessOptional::test_enum() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_enum)
  return _internal_test_enum();
}
inline void TestMessOptional::_internal_set_test_enum(::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.test_enum_ = value;
}
inline void TestMessOptional::set_test_enum(::foo::TestEnum value) {
  _internal_set_test_enum(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_enum)
}

// optional string test_string = 16;
inline bool TestMessOptional::_internal_has_test_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_string() const {
  return _internal_has_test_string();
}
inline void TestMessOptional::clear_test_string() {
  _impl_.test_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestMessOptional::test_string() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_string)
  return _internal_test_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessOptional::set_test_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_string)
}
inline std::string* TestMessOptional::mutable_test_string() {
  std::string* _s = _internal_mutable_test_string();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOptional.test_string)
  return _s;
}
inline const std::string& TestMessOptional::_internal_test_string() const {
  return _impl_.test_string_.Get();
}
inline void TestMessOptional::_internal_set_test_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_string_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessOptional::_internal_mutable_test_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_string_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessOptional::release_test_string() {
  // @@protoc_insertion_point(field_release:foo.TestMessOptional.test_string)
  if (!_internal_has_test_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_string_.IsDefault()) {
    _impl_.test_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessOptional::set_allocated_test_string(std::string* test_string) {
  if (test_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_string_.SetAllocated(test_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_string_.IsDefault()) {
    _impl_.test_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessOptional.test_string)
}

// optional bytes test_bytes = 17;
inline bool TestMessOptional::_internal_has_test_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestMessOptional::has_test_bytes() const {
  return _internal_has_test_bytes();
}
inline void TestMessOptional::clear_test_bytes() {
  _impl_.test_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TestMessOptional::test_bytes() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_bytes)
  return _internal_test_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessOptional::set_test_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.test_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessOptional.test_bytes)
}
inline std::string* TestMessOptional::mutable_test_bytes() {
  std::string* _s = _internal_mutable_test_bytes();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOptional.test_bytes)
  return _s;
}
inline const std::string& TestMessOptional::_internal_test_bytes() const {
  return _impl_.test_bytes_.Get();
}
inline void TestMessOptional::_internal_set_test_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.test_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessOptional::_internal_mutable_test_bytes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.test_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessOptional::release_test_bytes() {
  // @@protoc_insertion_point(field_release:foo.TestMessOptional.test_bytes)
  if (!_internal_has_test_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.test_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_bytes_.IsDefault()) {
    _impl_.test_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessOptional::set_allocated_test_bytes(std::string* test_bytes) {
  if (test_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.test_bytes_.SetAllocated(test_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_bytes_.IsDefault()) {
    _impl_.test_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessOptional.test_bytes)
}

// optional .foo.SubMess test_message = 18;
inline bool TestMessOptional::_internal_has_test_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_message_ != nullptr);
  return value;
}
inline bool TestMessOptional::has_test_message() const {
  return _internal_has_test_message();
}
inline void TestMessOptional::clear_test_message() {
  if (_impl_.test_message_ != nullptr) _impl_.test_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::foo::SubMess& TestMessOptional::_internal_test_message() const {
  const ::foo::SubMess* p = _impl_.test_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::SubMess&>(
      ::foo::_SubMess_default_instance_);
}
inline const ::foo::SubMess& TestMessOptional::test_message() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOptional.test_message)
  return _internal_test_message();
}
inline void TestMessOptional::unsafe_arena_set_allocated_test_message(
    ::foo::SubMess* test_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.test_message_);
  }
  _impl_.test_message_ = test_message;
  if (test_message) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessOptional.test_message)
}
inline ::foo::SubMess* TestMessOptional::release_test_message() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::foo::SubMess* temp = _impl_.test_message_;
  _impl_.test_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::SubMess* TestMessOptional::unsafe_arena_release_test_message() {
  // @@protoc_insertion_point(field_release:foo.TestMessOptional.test_message)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::foo::SubMess* temp = _impl_.test_message_;
  _impl_.test_message_ = nullptr;
  return temp;
}
inline ::foo::SubMess* TestMessOptional::_internal_mutable_test_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.test_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::SubMess>(GetArenaForAllocation());
    _impl_.test_message_ = p;
  }
  return _impl_.test_message_;
}
inline ::foo::SubMess* TestMessOptional::mutable_test_message() {
  ::foo::SubMess* _msg = _internal_mutable_test_message();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOptional.test_message)
  return _msg;
}
inline void TestMessOptional::set_allocated_test_message(::foo::SubMess* test_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.test_message_;
  }
  if (test_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test_message);
    if (message_arena != submessage_arena) {
      test_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.test_message_ = test_message;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessOptional.test_message)
}

// -------------------------------------------------------------------

// TestMessOneof

// int32 test_int32 = 1;
inline bool TestMessOneof::_internal_has_test_int32() const {
  return test_oneof_case() == kTestInt32;
}
inline bool TestMessOneof::has_test_int32() const {
  return _internal_has_test_int32();
}
inline void TestMessOneof::set_has_test_int32() {
  _impl_._oneof_case_[0] = kTestInt32;
}
inline void TestMessOneof::clear_test_int32() {
  if (_internal_has_test_int32()) {
    _impl_.test_oneof_.test_int32_ = 0;
    clear_has_test_oneof();
  }
}
inline int32_t TestMessOneof::_internal_test_int32() const {
  if (_internal_has_test_int32()) {
    return _impl_.test_oneof_.test_int32_;
  }
  return 0;
}
inline void TestMessOneof::_internal_set_test_int32(int32_t value) {
  if (!_internal_has_test_int32()) {
    clear_test_oneof();
    set_has_test_int32();
  }
  _impl_.test_oneof_.test_int32_ = value;
}
inline int32_t TestMessOneof::test_int32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_int32)
  return _internal_test_int32();
}
inline void TestMessOneof::set_test_int32(int32_t value) {
  _internal_set_test_int32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_int32)
}

// sint32 test_sint32 = 2;
inline bool TestMessOneof::_internal_has_test_sint32() const {
  return test_oneof_case() == kTestSint32;
}
inline bool TestMessOneof::has_test_sint32() const {
  return _internal_has_test_sint32();
}
inline void TestMessOneof::set_has_test_sint32() {
  _impl_._oneof_case_[0] = kTestSint32;
}
inline void TestMessOneof::clear_test_sint32() {
  if (_internal_has_test_sint32()) {
    _impl_.test_oneof_.test_sint32_ = 0;
    clear_has_test_oneof();
  }
}
inline int32_t TestMessOneof::_internal_test_sint32() const {
  if (_internal_has_test_sint32()) {
    return _impl_.test_oneof_.test_sint32_;
  }
  return 0;
}
inline void TestMessOneof::_internal_set_test_sint32(int32_t value) {
  if (!_internal_has_test_sint32()) {
    clear_test_oneof();
    set_has_test_sint32();
  }
  _impl_.test_oneof_.test_sint32_ = value;
}
inline int32_t TestMessOneof::test_sint32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_sint32)
  return _internal_test_sint32();
}
inline void TestMessOneof::set_test_sint32(int32_t value) {
  _internal_set_test_sint32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_sint32)
}

// sfixed32 test_sfixed32 = 3;
inline bool TestMessOneof::_internal_has_test_sfixed32() const {
  return test_oneof_case() == kTestSfixed32;
}
inline bool TestMessOneof::has_test_sfixed32() const {
  return _internal_has_test_sfixed32();
}
inline void TestMessOneof::set_has_test_sfixed32() {
  _impl_._oneof_case_[0] = kTestSfixed32;
}
inline void TestMessOneof::clear_test_sfixed32() {
  if (_internal_has_test_sfixed32()) {
    _impl_.test_oneof_.test_sfixed32_ = 0;
    clear_has_test_oneof();
  }
}
inline int32_t TestMessOneof::_internal_test_sfixed32() const {
  if (_internal_has_test_sfixed32()) {
    return _impl_.test_oneof_.test_sfixed32_;
  }
  return 0;
}
inline void TestMessOneof::_internal_set_test_sfixed32(int32_t value) {
  if (!_internal_has_test_sfixed32()) {
    clear_test_oneof();
    set_has_test_sfixed32();
  }
  _impl_.test_oneof_.test_sfixed32_ = value;
}
inline int32_t TestMessOneof::test_sfixed32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_sfixed32)
  return _internal_test_sfixed32();
}
inline void TestMessOneof::set_test_sfixed32(int32_t value) {
  _internal_set_test_sfixed32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_sfixed32)
}

// int64 test_int64 = 4;
inline bool TestMessOneof::_internal_has_test_int64() const {
  return test_oneof_case() == kTestInt64;
}
inline bool TestMessOneof::has_test_int64() const {
  return _internal_has_test_int64();
}
inline void TestMessOneof::set_has_test_int64() {
  _impl_._oneof_case_[0] = kTestInt64;
}
inline void TestMessOneof::clear_test_int64() {
  if (_internal_has_test_int64()) {
    _impl_.test_oneof_.test_int64_ = int64_t{0};
    clear_has_test_oneof();
  }
}
inline int64_t TestMessOneof::_internal_test_int64() const {
  if (_internal_has_test_int64()) {
    return _impl_.test_oneof_.test_int64_;
  }
  return int64_t{0};
}
inline void TestMessOneof::_internal_set_test_int64(int64_t value) {
  if (!_internal_has_test_int64()) {
    clear_test_oneof();
    set_has_test_int64();
  }
  _impl_.test_oneof_.test_int64_ = value;
}
inline int64_t TestMessOneof::test_int64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_int64)
  return _internal_test_int64();
}
inline void TestMessOneof::set_test_int64(int64_t value) {
  _internal_set_test_int64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_int64)
}

// sint64 test_sint64 = 5;
inline bool TestMessOneof::_internal_has_test_sint64() const {
  return test_oneof_case() == kTestSint64;
}
inline bool TestMessOneof::has_test_sint64() const {
  return _internal_has_test_sint64();
}
inline void TestMessOneof::set_has_test_sint64() {
  _impl_._oneof_case_[0] = kTestSint64;
}
inline void TestMessOneof::clear_test_sint64() {
  if (_internal_has_test_sint64()) {
    _impl_.test_oneof_.test_sint64_ = int64_t{0};
    clear_has_test_oneof();
  }
}
inline int64_t TestMessOneof::_internal_test_sint64() const {
  if (_internal_has_test_sint64()) {
    return _impl_.test_oneof_.test_sint64_;
  }
  return int64_t{0};
}
inline void TestMessOneof::_internal_set_test_sint64(int64_t value) {
  if (!_internal_has_test_sint64()) {
    clear_test_oneof();
    set_has_test_sint64();
  }
  _impl_.test_oneof_.test_sint64_ = value;
}
inline int64_t TestMessOneof::test_sint64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_sint64)
  return _internal_test_sint64();
}
inline void TestMessOneof::set_test_sint64(int64_t value) {
  _internal_set_test_sint64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_sint64)
}

// sfixed64 test_sfixed64 = 6;
inline bool TestMessOneof::_internal_has_test_sfixed64() const {
  return test_oneof_case() == kTestSfixed64;
}
inline bool TestMessOneof::has_test_sfixed64() const {
  return _internal_has_test_sfixed64();
}
inline void TestMessOneof::set_has_test_sfixed64() {
  _impl_._oneof_case_[0] = kTestSfixed64;
}
inline void TestMessOneof::clear_test_sfixed64() {
  if (_internal_has_test_sfixed64()) {
    _impl_.test_oneof_.test_sfixed64_ = int64_t{0};
    clear_has_test_oneof();
  }
}
inline int64_t TestMessOneof::_internal_test_sfixed64() const {
  if (_internal_has_test_sfixed64()) {
    return _impl_.test_oneof_.test_sfixed64_;
  }
  return int64_t{0};
}
inline void TestMessOneof::_internal_set_test_sfixed64(int64_t value) {
  if (!_internal_has_test_sfixed64()) {
    clear_test_oneof();
    set_has_test_sfixed64();
  }
  _impl_.test_oneof_.test_sfixed64_ = value;
}
inline int64_t TestMessOneof::test_sfixed64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_sfixed64)
  return _internal_test_sfixed64();
}
inline void TestMessOneof::set_test_sfixed64(int64_t value) {
  _internal_set_test_sfixed64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_sfixed64)
}

// uint32 test_uint32 = 7;
inline bool TestMessOneof::_internal_has_test_uint32() const {
  return test_oneof_case() == kTestUint32;
}
inline bool TestMessOneof::has_test_uint32() const {
  return _internal_has_test_uint32();
}
inline void TestMessOneof::set_has_test_uint32() {
  _impl_._oneof_case_[0] = kTestUint32;
}
inline void TestMessOneof::clear_test_uint32() {
  if (_internal_has_test_uint32()) {
    _impl_.test_oneof_.test_uint32_ = 0u;
    clear_has_test_oneof();
  }
}
inline uint32_t TestMessOneof::_internal_test_uint32() const {
  if (_internal_has_test_uint32()) {
    return _impl_.test_oneof_.test_uint32_;
  }
  return 0u;
}
inline void TestMessOneof::_internal_set_test_uint32(uint32_t value) {
  if (!_internal_has_test_uint32()) {
    clear_test_oneof();
    set_has_test_uint32();
  }
  _impl_.test_oneof_.test_uint32_ = value;
}
inline uint32_t TestMessOneof::test_uint32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_uint32)
  return _internal_test_uint32();
}
inline void TestMessOneof::set_test_uint32(uint32_t value) {
  _internal_set_test_uint32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_uint32)
}

// fixed32 test_fixed32 = 8;
inline bool TestMessOneof::_internal_has_test_fixed32() const {
  return test_oneof_case() == kTestFixed32;
}
inline bool TestMessOneof::has_test_fixed32() const {
  return _internal_has_test_fixed32();
}
inline void TestMessOneof::set_has_test_fixed32() {
  _impl_._oneof_case_[0] = kTestFixed32;
}
inline void TestMessOneof::clear_test_fixed32() {
  if (_internal_has_test_fixed32()) {
    _impl_.test_oneof_.test_fixed32_ = 0u;
    clear_has_test_oneof();
  }
}
inline uint32_t TestMessOneof::_internal_test_fixed32() const {
  if (_internal_has_test_fixed32()) {
    return _impl_.test_oneof_.test_fixed32_;
  }
  return 0u;
}
inline void TestMessOneof::_internal_set_test_fixed32(uint32_t value) {
  if (!_internal_has_test_fixed32()) {
    clear_test_oneof();
    set_has_test_fixed32();
  }
  _impl_.test_oneof_.test_fixed32_ = value;
}
inline uint32_t TestMessOneof::test_fixed32() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_fixed32)
  return _internal_test_fixed32();
}
inline void TestMessOneof::set_test_fixed32(uint32_t value) {
  _internal_set_test_fixed32(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_fixed32)
}

// uint64 test_uint64 = 9;
inline bool TestMessOneof::_internal_has_test_uint64() const {
  return test_oneof_case() == kTestUint64;
}
inline bool TestMessOneof::has_test_uint64() const {
  return _internal_has_test_uint64();
}
inline void TestMessOneof::set_has_test_uint64() {
  _impl_._oneof_case_[0] = kTestUint64;
}
inline void TestMessOneof::clear_test_uint64() {
  if (_internal_has_test_uint64()) {
    _impl_.test_oneof_.test_uint64_ = uint64_t{0u};
    clear_has_test_oneof();
  }
}
inline uint64_t TestMessOneof::_internal_test_uint64() const {
  if (_internal_has_test_uint64()) {
    return _impl_.test_oneof_.test_uint64_;
  }
  return uint64_t{0u};
}
inline void TestMessOneof::_internal_set_test_uint64(uint64_t value) {
  if (!_internal_has_test_uint64()) {
    clear_test_oneof();
    set_has_test_uint64();
  }
  _impl_.test_oneof_.test_uint64_ = value;
}
inline uint64_t TestMessOneof::test_uint64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_uint64)
  return _internal_test_uint64();
}
inline void TestMessOneof::set_test_uint64(uint64_t value) {
  _internal_set_test_uint64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_uint64)
}

// fixed64 test_fixed64 = 10;
inline bool TestMessOneof::_internal_has_test_fixed64() const {
  return test_oneof_case() == kTestFixed64;
}
inline bool TestMessOneof::has_test_fixed64() const {
  return _internal_has_test_fixed64();
}
inline void TestMessOneof::set_has_test_fixed64() {
  _impl_._oneof_case_[0] = kTestFixed64;
}
inline void TestMessOneof::clear_test_fixed64() {
  if (_internal_has_test_fixed64()) {
    _impl_.test_oneof_.test_fixed64_ = uint64_t{0u};
    clear_has_test_oneof();
  }
}
inline uint64_t TestMessOneof::_internal_test_fixed64() const {
  if (_internal_has_test_fixed64()) {
    return _impl_.test_oneof_.test_fixed64_;
  }
  return uint64_t{0u};
}
inline void TestMessOneof::_internal_set_test_fixed64(uint64_t value) {
  if (!_internal_has_test_fixed64()) {
    clear_test_oneof();
    set_has_test_fixed64();
  }
  _impl_.test_oneof_.test_fixed64_ = value;
}
inline uint64_t TestMessOneof::test_fixed64() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_fixed64)
  return _internal_test_fixed64();
}
inline void TestMessOneof::set_test_fixed64(uint64_t value) {
  _internal_set_test_fixed64(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_fixed64)
}

// float test_float = 11;
inline bool TestMessOneof::_internal_has_test_float() const {
  return test_oneof_case() == kTestFloat;
}
inline bool TestMessOneof::has_test_float() const {
  return _internal_has_test_float();
}
inline void TestMessOneof::set_has_test_float() {
  _impl_._oneof_case_[0] = kTestFloat;
}
inline void TestMessOneof::clear_test_float() {
  if (_internal_has_test_float()) {
    _impl_.test_oneof_.test_float_ = 0;
    clear_has_test_oneof();
  }
}
inline float TestMessOneof::_internal_test_float() const {
  if (_internal_has_test_float()) {
    return _impl_.test_oneof_.test_float_;
  }
  return 0;
}
inline void TestMessOneof::_internal_set_test_float(float value) {
  if (!_internal_has_test_float()) {
    clear_test_oneof();
    set_has_test_float();
  }
  _impl_.test_oneof_.test_float_ = value;
}
inline float TestMessOneof::test_float() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_float)
  return _internal_test_float();
}
inline void TestMessOneof::set_test_float(float value) {
  _internal_set_test_float(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_float)
}

// double test_double = 12;
inline bool TestMessOneof::_internal_has_test_double() const {
  return test_oneof_case() == kTestDouble;
}
inline bool TestMessOneof::has_test_double() const {
  return _internal_has_test_double();
}
inline void TestMessOneof::set_has_test_double() {
  _impl_._oneof_case_[0] = kTestDouble;
}
inline void TestMessOneof::clear_test_double() {
  if (_internal_has_test_double()) {
    _impl_.test_oneof_.test_double_ = 0;
    clear_has_test_oneof();
  }
}
inline double TestMessOneof::_internal_test_double() const {
  if (_internal_has_test_double()) {
    return _impl_.test_oneof_.test_double_;
  }
  return 0;
}
inline void TestMessOneof::_internal_set_test_double(double value) {
  if (!_internal_has_test_double()) {
    clear_test_oneof();
    set_has_test_double();
  }
  _impl_.test_oneof_.test_double_ = value;
}
inline double TestMessOneof::test_double() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_double)
  return _internal_test_double();
}
inline void TestMessOneof::set_test_double(double value) {
  _internal_set_test_double(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_double)
}

// bool test_boolean = 13;
inline bool TestMessOneof::_internal_has_test_boolean() const {
  return test_oneof_case() == kTestBoolean;
}
inline bool TestMessOneof::has_test_boolean() const {
  return _internal_has_test_boolean();
}
inline void TestMessOneof::set_has_test_boolean() {
  _impl_._oneof_case_[0] = kTestBoolean;
}
inline void TestMessOneof::clear_test_boolean() {
  if (_internal_has_test_boolean()) {
    _impl_.test_oneof_.test_boolean_ = false;
    clear_has_test_oneof();
  }
}
inline bool TestMessOneof::_internal_test_boolean() const {
  if (_internal_has_test_boolean()) {
    return _impl_.test_oneof_.test_boolean_;
  }
  return false;
}
inline void TestMessOneof::_internal_set_test_boolean(bool value) {
  if (!_internal_has_test_boolean()) {
    clear_test_oneof();
    set_has_test_boolean();
  }
  _impl_.test_oneof_.test_boolean_ = value;
}
inline bool TestMessOneof::test_boolean() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_boolean)
  return _internal_test_boolean();
}
inline void TestMessOneof::set_test_boolean(bool value) {
  _internal_set_test_boolean(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_boolean)
}

// .foo.TestEnumSmall test_enum_small = 14;
inline bool TestMessOneof::_internal_has_test_enum_small() const {
  return test_oneof_case() == kTestEnumSmall;
}
inline bool TestMessOneof::has_test_enum_small() const {
  return _internal_has_test_enum_small();
}
inline void TestMessOneof::set_has_test_enum_small() {
  _impl_._oneof_case_[0] = kTestEnumSmall;
}
inline void TestMessOneof::clear_test_enum_small() {
  if (_internal_has_test_enum_small()) {
    _impl_.test_oneof_.test_enum_small_ = -1;
    clear_has_test_oneof();
  }
}
inline ::foo::TestEnumSmall TestMessOneof::_internal_test_enum_small() const {
  if (_internal_has_test_enum_small()) {
    return static_cast< ::foo::TestEnumSmall >(_impl_.test_oneof_.test_enum_small_);
  }
  return static_cast< ::foo::TestEnumSmall >(-1);
}
inline ::foo::TestEnumSmall TestMessOneof::test_enum_small() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_enum_small)
  return _internal_test_enum_small();
}
inline void TestMessOneof::_internal_set_test_enum_small(::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  if (!_internal_has_test_enum_small()) {
    clear_test_oneof();
    set_has_test_enum_small();
  }
  _impl_.test_oneof_.test_enum_small_ = value;
}
inline void TestMessOneof::set_test_enum_small(::foo::TestEnumSmall value) {
  _internal_set_test_enum_small(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_enum_small)
}

// .foo.TestEnum test_enum = 15;
inline bool TestMessOneof::_internal_has_test_enum() const {
  return test_oneof_case() == kTestEnum;
}
inline bool TestMessOneof::has_test_enum() const {
  return _internal_has_test_enum();
}
inline void TestMessOneof::set_has_test_enum() {
  _impl_._oneof_case_[0] = kTestEnum;
}
inline void TestMessOneof::clear_test_enum() {
  if (_internal_has_test_enum()) {
    _impl_.test_oneof_.test_enum_ = -123456;
    clear_has_test_oneof();
  }
}
inline ::foo::TestEnum TestMessOneof::_internal_test_enum() const {
  if (_internal_has_test_enum()) {
    return static_cast< ::foo::TestEnum >(_impl_.test_oneof_.test_enum_);
  }
  return static_cast< ::foo::TestEnum >(-123456);
}
inline ::foo::TestEnum TestMessOneof::test_enum() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_enum)
  return _internal_test_enum();
}
inline void TestMessOneof::_internal_set_test_enum(::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  if (!_internal_has_test_enum()) {
    clear_test_oneof();
    set_has_test_enum();
  }
  _impl_.test_oneof_.test_enum_ = value;
}
inline void TestMessOneof::set_test_enum(::foo::TestEnum value) {
  _internal_set_test_enum(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_enum)
}

// string test_string = 16;
inline bool TestMessOneof::_internal_has_test_string() const {
  return test_oneof_case() == kTestString;
}
inline bool TestMessOneof::has_test_string() const {
  return _internal_has_test_string();
}
inline void TestMessOneof::set_has_test_string() {
  _impl_._oneof_case_[0] = kTestString;
}
inline void TestMessOneof::clear_test_string() {
  if (_internal_has_test_string()) {
    _impl_.test_oneof_.test_string_.Destroy();
    clear_has_test_oneof();
  }
}
inline const std::string& TestMessOneof::test_string() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_string)
  return _internal_test_string();
}
template <typename ArgT0, typename... ArgT>
inline void TestMessOneof::set_test_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_test_string()) {
    clear_test_oneof();
    set_has_test_string();
    _impl_.test_oneof_.test_string_.InitDefault();
  }
  _impl_.test_oneof_.test_string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_string)
}
inline std::string* TestMessOneof::mutable_test_string() {
  std::string* _s = _internal_mutable_test_string();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOneof.test_string)
  return _s;
}
inline const std::string& TestMessOneof::_internal_test_string() const {
  if (_internal_has_test_string()) {
    return _impl_.test_oneof_.test_string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TestMessOneof::_internal_set_test_string(const std::string& value) {
  if (!_internal_has_test_string()) {
    clear_test_oneof();
    set_has_test_string();
    _impl_.test_oneof_.test_string_.InitDefault();
  }
  _impl_.test_oneof_.test_string_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessOneof::_internal_mutable_test_string() {
  if (!_internal_has_test_string()) {
    clear_test_oneof();
    set_has_test_string();
    _impl_.test_oneof_.test_string_.InitDefault();
  }
  return _impl_.test_oneof_.test_string_.Mutable(      GetArenaForAllocation());
}
inline std::string* TestMessOneof::release_test_string() {
  // @@protoc_insertion_point(field_release:foo.TestMessOneof.test_string)
  if (_internal_has_test_string()) {
    clear_has_test_oneof();
    return _impl_.test_oneof_.test_string_.Release();
  } else {
    return nullptr;
  }
}
inline void TestMessOneof::set_allocated_test_string(std::string* test_string) {
  if (has_test_oneof()) {
    clear_test_oneof();
  }
  if (test_string != nullptr) {
    set_has_test_string();
    _impl_.test_oneof_.test_string_.InitAllocated(test_string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessOneof.test_string)
}

// bytes test_bytes = 17;
inline bool TestMessOneof::_internal_has_test_bytes() const {
  return test_oneof_case() == kTestBytes;
}
inline bool TestMessOneof::has_test_bytes() const {
  return _internal_has_test_bytes();
}
inline void TestMessOneof::set_has_test_bytes() {
  _impl_._oneof_case_[0] = kTestBytes;
}
inline void TestMessOneof::clear_test_bytes() {
  if (_internal_has_test_bytes()) {
    _impl_.test_oneof_.test_bytes_.Destroy();
    clear_has_test_oneof();
  }
}
inline const std::string& TestMessOneof::test_bytes() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_bytes)
  return _internal_test_bytes();
}
template <typename ArgT0, typename... ArgT>
inline void TestMessOneof::set_test_bytes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_test_bytes()) {
    clear_test_oneof();
    set_has_test_bytes();
    _impl_.test_oneof_.test_bytes_.InitDefault();
  }
  _impl_.test_oneof_.test_bytes_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.test_bytes)
}
inline std::string* TestMessOneof::mutable_test_bytes() {
  std::string* _s = _internal_mutable_test_bytes();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOneof.test_bytes)
  return _s;
}
inline const std::string& TestMessOneof::_internal_test_bytes() const {
  if (_internal_has_test_bytes()) {
    return _impl_.test_oneof_.test_bytes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TestMessOneof::_internal_set_test_bytes(const std::string& value) {
  if (!_internal_has_test_bytes()) {
    clear_test_oneof();
    set_has_test_bytes();
    _impl_.test_oneof_.test_bytes_.InitDefault();
  }
  _impl_.test_oneof_.test_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessOneof::_internal_mutable_test_bytes() {
  if (!_internal_has_test_bytes()) {
    clear_test_oneof();
    set_has_test_bytes();
    _impl_.test_oneof_.test_bytes_.InitDefault();
  }
  return _impl_.test_oneof_.test_bytes_.Mutable(      GetArenaForAllocation());
}
inline std::string* TestMessOneof::release_test_bytes() {
  // @@protoc_insertion_point(field_release:foo.TestMessOneof.test_bytes)
  if (_internal_has_test_bytes()) {
    clear_has_test_oneof();
    return _impl_.test_oneof_.test_bytes_.Release();
  } else {
    return nullptr;
  }
}
inline void TestMessOneof::set_allocated_test_bytes(std::string* test_bytes) {
  if (has_test_oneof()) {
    clear_test_oneof();
  }
  if (test_bytes != nullptr) {
    set_has_test_bytes();
    _impl_.test_oneof_.test_bytes_.InitAllocated(test_bytes, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessOneof.test_bytes)
}

// .foo.SubMess test_message = 18;
inline bool TestMessOneof::_internal_has_test_message() const {
  return test_oneof_case() == kTestMessage;
}
inline bool TestMessOneof::has_test_message() const {
  return _internal_has_test_message();
}
inline void TestMessOneof::set_has_test_message() {
  _impl_._oneof_case_[0] = kTestMessage;
}
inline void TestMessOneof::clear_test_message() {
  if (_internal_has_test_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.test_oneof_.test_message_;
    }
    clear_has_test_oneof();
  }
}
inline ::foo::SubMess* TestMessOneof::release_test_message() {
  // @@protoc_insertion_point(field_release:foo.TestMessOneof.test_message)
  if (_internal_has_test_message()) {
    clear_has_test_oneof();
    ::foo::SubMess* temp = _impl_.test_oneof_.test_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.test_oneof_.test_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::foo::SubMess& TestMessOneof::_internal_test_message() const {
  return _internal_has_test_message()
      ? *_impl_.test_oneof_.test_message_
      : reinterpret_cast< ::foo::SubMess&>(::foo::_SubMess_default_instance_);
}
inline const ::foo::SubMess& TestMessOneof::test_message() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.test_message)
  return _internal_test_message();
}
inline ::foo::SubMess* TestMessOneof::unsafe_arena_release_test_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:foo.TestMessOneof.test_message)
  if (_internal_has_test_message()) {
    clear_has_test_oneof();
    ::foo::SubMess* temp = _impl_.test_oneof_.test_message_;
    _impl_.test_oneof_.test_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TestMessOneof::unsafe_arena_set_allocated_test_message(::foo::SubMess* test_message) {
  clear_test_oneof();
  if (test_message) {
    set_has_test_message();
    _impl_.test_oneof_.test_message_ = test_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessOneof.test_message)
}
inline ::foo::SubMess* TestMessOneof::_internal_mutable_test_message() {
  if (!_internal_has_test_message()) {
    clear_test_oneof();
    set_has_test_message();
    _impl_.test_oneof_.test_message_ = CreateMaybeMessage< ::foo::SubMess >(GetArenaForAllocation());
  }
  return _impl_.test_oneof_.test_message_;
}
inline ::foo::SubMess* TestMessOneof::mutable_test_message() {
  ::foo::SubMess* _msg = _internal_mutable_test_message();
  // @@protoc_insertion_point(field_mutable:foo.TestMessOneof.test_message)
  return _msg;
}

// optional int32 opt_int = 19;
inline bool TestMessOneof::_internal_has_opt_int() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessOneof::has_opt_int() const {
  return _internal_has_opt_int();
}
inline void TestMessOneof::clear_opt_int() {
  _impl_.opt_int_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestMessOneof::_internal_opt_int() const {
  return _impl_.opt_int_;
}
inline int32_t TestMessOneof::opt_int() const {
  // @@protoc_insertion_point(field_get:foo.TestMessOneof.opt_int)
  return _internal_opt_int();
}
inline void TestMessOneof::_internal_set_opt_int(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.opt_int_ = value;
}
inline void TestMessOneof::set_opt_int(int32_t value) {
  _internal_set_opt_int(value);
  // @@protoc_insertion_point(field_set:foo.TestMessOneof.opt_int)
}

inline bool TestMessOneof::has_test_oneof() const {
  return test_oneof_case() != TEST_ONEOF_NOT_SET;
}
inline void TestMessOneof::clear_has_test_oneof() {
  _impl_._oneof_case_[0] = TEST_ONEOF_NOT_SET;
}
inline TestMessOneof::TestOneofCase TestMessOneof::test_oneof_case() const {
  return TestMessOneof::TestOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestMessRequiredInt32

// required int32 test = 42;
inline bool TestMessRequiredInt32::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredInt32::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredInt32::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestMessRequiredInt32::_internal_test() const {
  return _impl_.test_;
}
inline int32_t TestMessRequiredInt32::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredInt32.test)
  return _internal_test();
}
inline void TestMessRequiredInt32::_internal_set_test(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredInt32::set_test(int32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredInt32.test)
}

// -------------------------------------------------------------------

// TestMessRequiredSInt32

// required sint32 test = 43;
inline bool TestMessRequiredSInt32::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredSInt32::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredSInt32::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestMessRequiredSInt32::_internal_test() const {
  return _impl_.test_;
}
inline int32_t TestMessRequiredSInt32::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredSInt32.test)
  return _internal_test();
}
inline void TestMessRequiredSInt32::_internal_set_test(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredSInt32::set_test(int32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredSInt32.test)
}

// -------------------------------------------------------------------

// TestMessRequiredSFixed32

// required sfixed32 test = 100;
inline bool TestMessRequiredSFixed32::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredSFixed32::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredSFixed32::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestMessRequiredSFixed32::_internal_test() const {
  return _impl_.test_;
}
inline int32_t TestMessRequiredSFixed32::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredSFixed32.test)
  return _internal_test();
}
inline void TestMessRequiredSFixed32::_internal_set_test(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredSFixed32::set_test(int32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredSFixed32.test)
}

// -------------------------------------------------------------------

// TestMessRequiredInt64

// required int64 test = 1;
inline bool TestMessRequiredInt64::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredInt64::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredInt64::clear_test() {
  _impl_.test_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TestMessRequiredInt64::_internal_test() const {
  return _impl_.test_;
}
inline int64_t TestMessRequiredInt64::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredInt64.test)
  return _internal_test();
}
inline void TestMessRequiredInt64::_internal_set_test(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredInt64::set_test(int64_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredInt64.test)
}

// -------------------------------------------------------------------

// TestMessRequiredSInt64

// required sint64 test = 11;
inline bool TestMessRequiredSInt64::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredSInt64::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredSInt64::clear_test() {
  _impl_.test_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TestMessRequiredSInt64::_internal_test() const {
  return _impl_.test_;
}
inline int64_t TestMessRequiredSInt64::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredSInt64.test)
  return _internal_test();
}
inline void TestMessRequiredSInt64::_internal_set_test(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredSInt64::set_test(int64_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredSInt64.test)
}

// -------------------------------------------------------------------

// TestMessRequiredSFixed64

// required sfixed64 test = 12;
inline bool TestMessRequiredSFixed64::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredSFixed64::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredSFixed64::clear_test() {
  _impl_.test_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TestMessRequiredSFixed64::_internal_test() const {
  return _impl_.test_;
}
inline int64_t TestMessRequiredSFixed64::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredSFixed64.test)
  return _internal_test();
}
inline void TestMessRequiredSFixed64::_internal_set_test(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredSFixed64::set_test(int64_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredSFixed64.test)
}

// -------------------------------------------------------------------

// TestMessRequiredUInt32

// required uint32 test = 1;
inline bool TestMessRequiredUInt32::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredUInt32::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredUInt32::clear_test() {
  _impl_.test_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TestMessRequiredUInt32::_internal_test() const {
  return _impl_.test_;
}
inline uint32_t TestMessRequiredUInt32::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredUInt32.test)
  return _internal_test();
}
inline void TestMessRequiredUInt32::_internal_set_test(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredUInt32::set_test(uint32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredUInt32.test)
}

// -------------------------------------------------------------------

// TestMessRequiredFixed32

// required fixed32 test = 1;
inline bool TestMessRequiredFixed32::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredFixed32::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredFixed32::clear_test() {
  _impl_.test_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TestMessRequiredFixed32::_internal_test() const {
  return _impl_.test_;
}
inline uint32_t TestMessRequiredFixed32::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredFixed32.test)
  return _internal_test();
}
inline void TestMessRequiredFixed32::_internal_set_test(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredFixed32::set_test(uint32_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredFixed32.test)
}

// -------------------------------------------------------------------

// TestMessRequiredUInt64

// required uint64 test = 1;
inline bool TestMessRequiredUInt64::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredUInt64::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredUInt64::clear_test() {
  _impl_.test_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TestMessRequiredUInt64::_internal_test() const {
  return _impl_.test_;
}
inline uint64_t TestMessRequiredUInt64::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredUInt64.test)
  return _internal_test();
}
inline void TestMessRequiredUInt64::_internal_set_test(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredUInt64::set_test(uint64_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredUInt64.test)
}

// -------------------------------------------------------------------

// TestMessRequiredFixed64

// required fixed64 test = 1;
inline bool TestMessRequiredFixed64::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredFixed64::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredFixed64::clear_test() {
  _impl_.test_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TestMessRequiredFixed64::_internal_test() const {
  return _impl_.test_;
}
inline uint64_t TestMessRequiredFixed64::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredFixed64.test)
  return _internal_test();
}
inline void TestMessRequiredFixed64::_internal_set_test(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredFixed64::set_test(uint64_t value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredFixed64.test)
}

// -------------------------------------------------------------------

// TestMessRequiredFloat

// required float test = 1;
inline bool TestMessRequiredFloat::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredFloat::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredFloat::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TestMessRequiredFloat::_internal_test() const {
  return _impl_.test_;
}
inline float TestMessRequiredFloat::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredFloat.test)
  return _internal_test();
}
inline void TestMessRequiredFloat::_internal_set_test(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredFloat::set_test(float value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredFloat.test)
}

// -------------------------------------------------------------------

// TestMessRequiredDouble

// required double test = 1;
inline bool TestMessRequiredDouble::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredDouble::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredDouble::clear_test() {
  _impl_.test_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double TestMessRequiredDouble::_internal_test() const {
  return _impl_.test_;
}
inline double TestMessRequiredDouble::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredDouble.test)
  return _internal_test();
}
inline void TestMessRequiredDouble::_internal_set_test(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredDouble::set_test(double value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredDouble.test)
}

// -------------------------------------------------------------------

// TestMessRequiredBool

// required bool test = 1;
inline bool TestMessRequiredBool::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredBool::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredBool::clear_test() {
  _impl_.test_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TestMessRequiredBool::_internal_test() const {
  return _impl_.test_;
}
inline bool TestMessRequiredBool::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredBool.test)
  return _internal_test();
}
inline void TestMessRequiredBool::_internal_set_test(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredBool::set_test(bool value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredBool.test)
}

// -------------------------------------------------------------------

// TestMessRequiredEnum

// required .foo.TestEnum test = 1;
inline bool TestMessRequiredEnum::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredEnum::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredEnum::clear_test() {
  _impl_.test_ = -123456;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::foo::TestEnum TestMessRequiredEnum::_internal_test() const {
  return static_cast< ::foo::TestEnum >(_impl_.test_);
}
inline ::foo::TestEnum TestMessRequiredEnum::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredEnum.test)
  return _internal_test();
}
inline void TestMessRequiredEnum::_internal_set_test(::foo::TestEnum value) {
  assert(::foo::TestEnum_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredEnum::set_test(::foo::TestEnum value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredEnum.test)
}

// -------------------------------------------------------------------

// TestMessRequiredEnumSmall

// required .foo.TestEnumSmall test = 1;
inline bool TestMessRequiredEnumSmall::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredEnumSmall::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredEnumSmall::clear_test() {
  _impl_.test_ = -1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::foo::TestEnumSmall TestMessRequiredEnumSmall::_internal_test() const {
  return static_cast< ::foo::TestEnumSmall >(_impl_.test_);
}
inline ::foo::TestEnumSmall TestMessRequiredEnumSmall::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredEnumSmall.test)
  return _internal_test();
}
inline void TestMessRequiredEnumSmall::_internal_set_test(::foo::TestEnumSmall value) {
  assert(::foo::TestEnumSmall_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_ = value;
}
inline void TestMessRequiredEnumSmall::set_test(::foo::TestEnumSmall value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredEnumSmall.test)
}

// -------------------------------------------------------------------

// TestMessRequiredString

// required string test = 1;
inline bool TestMessRequiredString::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredString::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredString::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestMessRequiredString::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredString.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessRequiredString::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredString.test)
}
inline std::string* TestMessRequiredString::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestMessRequiredString.test)
  return _s;
}
inline const std::string& TestMessRequiredString::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestMessRequiredString::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessRequiredString::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessRequiredString::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestMessRequiredString.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessRequiredString::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessRequiredString.test)
}

// -------------------------------------------------------------------

// TestMessRequiredBytes

// required bytes test = 1;
inline bool TestMessRequiredBytes::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessRequiredBytes::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredBytes::clear_test() {
  _impl_.test_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestMessRequiredBytes::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredBytes.test)
  return _internal_test();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessRequiredBytes::set_test(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.test_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessRequiredBytes.test)
}
inline std::string* TestMessRequiredBytes::mutable_test() {
  std::string* _s = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestMessRequiredBytes.test)
  return _s;
}
inline const std::string& TestMessRequiredBytes::_internal_test() const {
  return _impl_.test_.Get();
}
inline void TestMessRequiredBytes::_internal_set_test(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.test_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessRequiredBytes::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.test_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessRequiredBytes::release_test() {
  // @@protoc_insertion_point(field_release:foo.TestMessRequiredBytes.test)
  if (!_internal_has_test()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.test_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessRequiredBytes::set_allocated_test(std::string* test) {
  if (test != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_.SetAllocated(test, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.test_.IsDefault()) {
    _impl_.test_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessRequiredBytes.test)
}

// -------------------------------------------------------------------

// TestMessRequiredMessage

// required .foo.SubMess test = 1;
inline bool TestMessRequiredMessage::_internal_has_test() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.test_ != nullptr);
  return value;
}
inline bool TestMessRequiredMessage::has_test() const {
  return _internal_has_test();
}
inline void TestMessRequiredMessage::clear_test() {
  if (_impl_.test_ != nullptr) _impl_.test_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::foo::SubMess& TestMessRequiredMessage::_internal_test() const {
  const ::foo::SubMess* p = _impl_.test_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::SubMess&>(
      ::foo::_SubMess_default_instance_);
}
inline const ::foo::SubMess& TestMessRequiredMessage::test() const {
  // @@protoc_insertion_point(field_get:foo.TestMessRequiredMessage.test)
  return _internal_test();
}
inline void TestMessRequiredMessage::unsafe_arena_set_allocated_test(
    ::foo::SubMess* test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.test_);
  }
  _impl_.test_ = test;
  if (test) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessRequiredMessage.test)
}
inline ::foo::SubMess* TestMessRequiredMessage::release_test() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::SubMess* temp = _impl_.test_;
  _impl_.test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::SubMess* TestMessRequiredMessage::unsafe_arena_release_test() {
  // @@protoc_insertion_point(field_release:foo.TestMessRequiredMessage.test)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::SubMess* temp = _impl_.test_;
  _impl_.test_ = nullptr;
  return temp;
}
inline ::foo::SubMess* TestMessRequiredMessage::_internal_mutable_test() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.test_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::SubMess>(GetArenaForAllocation());
    _impl_.test_ = p;
  }
  return _impl_.test_;
}
inline ::foo::SubMess* TestMessRequiredMessage::mutable_test() {
  ::foo::SubMess* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:foo.TestMessRequiredMessage.test)
  return _msg;
}
inline void TestMessRequiredMessage::set_allocated_test(::foo::SubMess* test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.test_;
  }
  if (test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test);
    if (message_arena != submessage_arena) {
      test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.test_ = test;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessRequiredMessage.test)
}

// -------------------------------------------------------------------

// EmptyMess

// -------------------------------------------------------------------

// DefaultRequiredValues

// required int32 v_int32 = 1 [default = -42];
inline bool DefaultRequiredValues::_internal_has_v_int32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_int32() const {
  return _internal_has_v_int32();
}
inline void DefaultRequiredValues::clear_v_int32() {
  _impl_.v_int32_ = -42;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DefaultRequiredValues::_internal_v_int32() const {
  return _impl_.v_int32_;
}
inline int32_t DefaultRequiredValues::v_int32() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_int32)
  return _internal_v_int32();
}
inline void DefaultRequiredValues::_internal_set_v_int32(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.v_int32_ = value;
}
inline void DefaultRequiredValues::set_v_int32(int32_t value) {
  _internal_set_v_int32(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_int32)
}

// required uint32 v_uint32 = 2 [default = 666];
inline bool DefaultRequiredValues::_internal_has_v_uint32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_uint32() const {
  return _internal_has_v_uint32();
}
inline void DefaultRequiredValues::clear_v_uint32() {
  _impl_.v_uint32_ = 666u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DefaultRequiredValues::_internal_v_uint32() const {
  return _impl_.v_uint32_;
}
inline uint32_t DefaultRequiredValues::v_uint32() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_uint32)
  return _internal_v_uint32();
}
inline void DefaultRequiredValues::_internal_set_v_uint32(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.v_uint32_ = value;
}
inline void DefaultRequiredValues::set_v_uint32(uint32_t value) {
  _internal_set_v_uint32(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_uint32)
}

// required int32 v_int64 = 3 [default = 100000];
inline bool DefaultRequiredValues::_internal_has_v_int64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_int64() const {
  return _internal_has_v_int64();
}
inline void DefaultRequiredValues::clear_v_int64() {
  _impl_.v_int64_ = 100000;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t DefaultRequiredValues::_internal_v_int64() const {
  return _impl_.v_int64_;
}
inline int32_t DefaultRequiredValues::v_int64() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_int64)
  return _internal_v_int64();
}
inline void DefaultRequiredValues::_internal_set_v_int64(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.v_int64_ = value;
}
inline void DefaultRequiredValues::set_v_int64(int32_t value) {
  _internal_set_v_int64(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_int64)
}

// required uint32 v_uint64 = 4 [default = 100001];
inline bool DefaultRequiredValues::_internal_has_v_uint64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_uint64() const {
  return _internal_has_v_uint64();
}
inline void DefaultRequiredValues::clear_v_uint64() {
  _impl_.v_uint64_ = 100001u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t DefaultRequiredValues::_internal_v_uint64() const {
  return _impl_.v_uint64_;
}
inline uint32_t DefaultRequiredValues::v_uint64() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_uint64)
  return _internal_v_uint64();
}
inline void DefaultRequiredValues::_internal_set_v_uint64(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.v_uint64_ = value;
}
inline void DefaultRequiredValues::set_v_uint64(uint32_t value) {
  _internal_set_v_uint64(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_uint64)
}

// required float v_float = 5 [default = 2.5];
inline bool DefaultRequiredValues::_internal_has_v_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_float() const {
  return _internal_has_v_float();
}
inline void DefaultRequiredValues::clear_v_float() {
  _impl_.v_float_ = 2.5f;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float DefaultRequiredValues::_internal_v_float() const {
  return _impl_.v_float_;
}
inline float DefaultRequiredValues::v_float() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_float)
  return _internal_v_float();
}
inline void DefaultRequiredValues::_internal_set_v_float(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v_float_ = value;
}
inline void DefaultRequiredValues::set_v_float(float value) {
  _internal_set_v_float(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_float)
}

// required double v_double = 6 [default = 4.5];
inline bool DefaultRequiredValues::_internal_has_v_double() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_double() const {
  return _internal_has_v_double();
}
inline void DefaultRequiredValues::clear_v_double() {
  _impl_.v_double_ = 4.5;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double DefaultRequiredValues::_internal_v_double() const {
  return _impl_.v_double_;
}
inline double DefaultRequiredValues::v_double() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_double)
  return _internal_v_double();
}
inline void DefaultRequiredValues::_internal_set_v_double(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.v_double_ = value;
}
inline void DefaultRequiredValues::set_v_double(double value) {
  _internal_set_v_double(value);
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_double)
}

// required string v_string = 7 [default = "hi mom\n"];
inline bool DefaultRequiredValues::_internal_has_v_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_string() const {
  return _internal_has_v_string();
}
inline void DefaultRequiredValues::clear_v_string() {
  _impl_.v_string_.ClearToDefault(::foo::DefaultRequiredValues::Impl_::_i_give_permission_to_break_this_code_default_v_string_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultRequiredValues::v_string() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_string)
  if (_impl_.v_string_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_v_string_.get();
  return _internal_v_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultRequiredValues::set_v_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.v_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_string)
}
inline std::string* DefaultRequiredValues::mutable_v_string() {
  std::string* _s = _internal_mutable_v_string();
  // @@protoc_insertion_point(field_mutable:foo.DefaultRequiredValues.v_string)
  return _s;
}
inline const std::string& DefaultRequiredValues::_internal_v_string() const {
  return _impl_.v_string_.Get();
}
inline void DefaultRequiredValues::_internal_set_v_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.v_string_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultRequiredValues::_internal_mutable_v_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.v_string_.Mutable(::foo::DefaultRequiredValues::Impl_::_i_give_permission_to_break_this_code_default_v_string_, GetArenaForAllocation());
}
inline std::string* DefaultRequiredValues::release_v_string() {
  // @@protoc_insertion_point(field_release:foo.DefaultRequiredValues.v_string)
  if (!_internal_has_v_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.v_string_.Release();
  return p;
}
inline void DefaultRequiredValues::set_allocated_v_string(std::string* v_string) {
  if (v_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.v_string_.SetAllocated(v_string, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.DefaultRequiredValues.v_string)
}

// required bytes v_bytes = 8 [default = "a \000 character"];
inline bool DefaultRequiredValues::_internal_has_v_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultRequiredValues::has_v_bytes() const {
  return _internal_has_v_bytes();
}
inline void DefaultRequiredValues::clear_v_bytes() {
  _impl_.v_bytes_.ClearToDefault(::foo::DefaultRequiredValues::Impl_::_i_give_permission_to_break_this_code_default_v_bytes_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultRequiredValues::v_bytes() const {
  // @@protoc_insertion_point(field_get:foo.DefaultRequiredValues.v_bytes)
  if (_impl_.v_bytes_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_v_bytes_.get();
  return _internal_v_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultRequiredValues::set_v_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.v_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.DefaultRequiredValues.v_bytes)
}
inline std::string* DefaultRequiredValues::mutable_v_bytes() {
  std::string* _s = _internal_mutable_v_bytes();
  // @@protoc_insertion_point(field_mutable:foo.DefaultRequiredValues.v_bytes)
  return _s;
}
inline const std::string& DefaultRequiredValues::_internal_v_bytes() const {
  return _impl_.v_bytes_.Get();
}
inline void DefaultRequiredValues::_internal_set_v_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.v_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultRequiredValues::_internal_mutable_v_bytes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.v_bytes_.Mutable(::foo::DefaultRequiredValues::Impl_::_i_give_permission_to_break_this_code_default_v_bytes_, GetArenaForAllocation());
}
inline std::string* DefaultRequiredValues::release_v_bytes() {
  // @@protoc_insertion_point(field_release:foo.DefaultRequiredValues.v_bytes)
  if (!_internal_has_v_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.v_bytes_.Release();
  return p;
}
inline void DefaultRequiredValues::set_allocated_v_bytes(std::string* v_bytes) {
  if (v_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.v_bytes_.SetAllocated(v_bytes, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.DefaultRequiredValues.v_bytes)
}

// -------------------------------------------------------------------

// DefaultOptionalValues

// optional int32 v_int32 = 1 [default = -42];
inline bool DefaultOptionalValues::_internal_has_v_int32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_int32() const {
  return _internal_has_v_int32();
}
inline void DefaultOptionalValues::clear_v_int32() {
  _impl_.v_int32_ = -42;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DefaultOptionalValues::_internal_v_int32() const {
  return _impl_.v_int32_;
}
inline int32_t DefaultOptionalValues::v_int32() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_int32)
  return _internal_v_int32();
}
inline void DefaultOptionalValues::_internal_set_v_int32(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.v_int32_ = value;
}
inline void DefaultOptionalValues::set_v_int32(int32_t value) {
  _internal_set_v_int32(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_int32)
}

// optional uint32 v_uint32 = 2 [default = 666];
inline bool DefaultOptionalValues::_internal_has_v_uint32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_uint32() const {
  return _internal_has_v_uint32();
}
inline void DefaultOptionalValues::clear_v_uint32() {
  _impl_.v_uint32_ = 666u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DefaultOptionalValues::_internal_v_uint32() const {
  return _impl_.v_uint32_;
}
inline uint32_t DefaultOptionalValues::v_uint32() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_uint32)
  return _internal_v_uint32();
}
inline void DefaultOptionalValues::_internal_set_v_uint32(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.v_uint32_ = value;
}
inline void DefaultOptionalValues::set_v_uint32(uint32_t value) {
  _internal_set_v_uint32(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_uint32)
}

// optional int32 v_int64 = 3 [default = 100000];
inline bool DefaultOptionalValues::_internal_has_v_int64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_int64() const {
  return _internal_has_v_int64();
}
inline void DefaultOptionalValues::clear_v_int64() {
  _impl_.v_int64_ = 100000;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t DefaultOptionalValues::_internal_v_int64() const {
  return _impl_.v_int64_;
}
inline int32_t DefaultOptionalValues::v_int64() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_int64)
  return _internal_v_int64();
}
inline void DefaultOptionalValues::_internal_set_v_int64(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.v_int64_ = value;
}
inline void DefaultOptionalValues::set_v_int64(int32_t value) {
  _internal_set_v_int64(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_int64)
}

// optional uint32 v_uint64 = 4 [default = 100001];
inline bool DefaultOptionalValues::_internal_has_v_uint64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_uint64() const {
  return _internal_has_v_uint64();
}
inline void DefaultOptionalValues::clear_v_uint64() {
  _impl_.v_uint64_ = 100001u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t DefaultOptionalValues::_internal_v_uint64() const {
  return _impl_.v_uint64_;
}
inline uint32_t DefaultOptionalValues::v_uint64() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_uint64)
  return _internal_v_uint64();
}
inline void DefaultOptionalValues::_internal_set_v_uint64(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.v_uint64_ = value;
}
inline void DefaultOptionalValues::set_v_uint64(uint32_t value) {
  _internal_set_v_uint64(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_uint64)
}

// optional float v_float = 5 [default = 2.5];
inline bool DefaultOptionalValues::_internal_has_v_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_float() const {
  return _internal_has_v_float();
}
inline void DefaultOptionalValues::clear_v_float() {
  _impl_.v_float_ = 2.5f;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float DefaultOptionalValues::_internal_v_float() const {
  return _impl_.v_float_;
}
inline float DefaultOptionalValues::v_float() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_float)
  return _internal_v_float();
}
inline void DefaultOptionalValues::_internal_set_v_float(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v_float_ = value;
}
inline void DefaultOptionalValues::set_v_float(float value) {
  _internal_set_v_float(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_float)
}

// optional double v_double = 6 [default = 4.5];
inline bool DefaultOptionalValues::_internal_has_v_double() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_double() const {
  return _internal_has_v_double();
}
inline void DefaultOptionalValues::clear_v_double() {
  _impl_.v_double_ = 4.5;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double DefaultOptionalValues::_internal_v_double() const {
  return _impl_.v_double_;
}
inline double DefaultOptionalValues::v_double() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_double)
  return _internal_v_double();
}
inline void DefaultOptionalValues::_internal_set_v_double(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.v_double_ = value;
}
inline void DefaultOptionalValues::set_v_double(double value) {
  _internal_set_v_double(value);
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_double)
}

// optional string v_string = 7 [default = "hi mom\n"];
inline bool DefaultOptionalValues::_internal_has_v_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_string() const {
  return _internal_has_v_string();
}
inline void DefaultOptionalValues::clear_v_string() {
  _impl_.v_string_.ClearToDefault(::foo::DefaultOptionalValues::Impl_::_i_give_permission_to_break_this_code_default_v_string_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultOptionalValues::v_string() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_string)
  if (_impl_.v_string_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_v_string_.get();
  return _internal_v_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultOptionalValues::set_v_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.v_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_string)
}
inline std::string* DefaultOptionalValues::mutable_v_string() {
  std::string* _s = _internal_mutable_v_string();
  // @@protoc_insertion_point(field_mutable:foo.DefaultOptionalValues.v_string)
  return _s;
}
inline const std::string& DefaultOptionalValues::_internal_v_string() const {
  return _impl_.v_string_.Get();
}
inline void DefaultOptionalValues::_internal_set_v_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.v_string_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultOptionalValues::_internal_mutable_v_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.v_string_.Mutable(::foo::DefaultOptionalValues::Impl_::_i_give_permission_to_break_this_code_default_v_string_, GetArenaForAllocation());
}
inline std::string* DefaultOptionalValues::release_v_string() {
  // @@protoc_insertion_point(field_release:foo.DefaultOptionalValues.v_string)
  if (!_internal_has_v_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.v_string_.Release();
  return p;
}
inline void DefaultOptionalValues::set_allocated_v_string(std::string* v_string) {
  if (v_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.v_string_.SetAllocated(v_string, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.DefaultOptionalValues.v_string)
}

// optional bytes v_bytes = 8 [default = "a \000 character"];
inline bool DefaultOptionalValues::_internal_has_v_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultOptionalValues::has_v_bytes() const {
  return _internal_has_v_bytes();
}
inline void DefaultOptionalValues::clear_v_bytes() {
  _impl_.v_bytes_.ClearToDefault(::foo::DefaultOptionalValues::Impl_::_i_give_permission_to_break_this_code_default_v_bytes_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultOptionalValues::v_bytes() const {
  // @@protoc_insertion_point(field_get:foo.DefaultOptionalValues.v_bytes)
  if (_impl_.v_bytes_.IsDefault()) return Impl_::_i_give_permission_to_break_this_code_default_v_bytes_.get();
  return _internal_v_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultOptionalValues::set_v_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.v_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.DefaultOptionalValues.v_bytes)
}
inline std::string* DefaultOptionalValues::mutable_v_bytes() {
  std::string* _s = _internal_mutable_v_bytes();
  // @@protoc_insertion_point(field_mutable:foo.DefaultOptionalValues.v_bytes)
  return _s;
}
inline const std::string& DefaultOptionalValues::_internal_v_bytes() const {
  return _impl_.v_bytes_.Get();
}
inline void DefaultOptionalValues::_internal_set_v_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.v_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultOptionalValues::_internal_mutable_v_bytes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.v_bytes_.Mutable(::foo::DefaultOptionalValues::Impl_::_i_give_permission_to_break_this_code_default_v_bytes_, GetArenaForAllocation());
}
inline std::string* DefaultOptionalValues::release_v_bytes() {
  // @@protoc_insertion_point(field_release:foo.DefaultOptionalValues.v_bytes)
  if (!_internal_has_v_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.v_bytes_.Release();
  return p;
}
inline void DefaultOptionalValues::set_allocated_v_bytes(std::string* v_bytes) {
  if (v_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.v_bytes_.SetAllocated(v_bytes, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:foo.DefaultOptionalValues.v_bytes)
}

// -------------------------------------------------------------------

// LowerCase

// optional .foo.LowerCase.CaseEnum value = 1 [default = lower];
inline bool LowerCase::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LowerCase::has_value() const {
  return _internal_has_value();
}
inline void LowerCase::clear_value() {
  _impl_.value_ = 2;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::foo::LowerCase_CaseEnum LowerCase::_internal_value() const {
  return static_cast< ::foo::LowerCase_CaseEnum >(_impl_.value_);
}
inline ::foo::LowerCase_CaseEnum LowerCase::value() const {
  // @@protoc_insertion_point(field_get:foo.LowerCase.value)
  return _internal_value();
}
inline void LowerCase::_internal_set_value(::foo::LowerCase_CaseEnum value) {
  assert(::foo::LowerCase_CaseEnum_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}
inline void LowerCase::set_value(::foo::LowerCase_CaseEnum value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:foo.LowerCase.value)
}

// -------------------------------------------------------------------

// AllocValues

// optional bytes o_bytes = 1;
inline bool AllocValues::_internal_has_o_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AllocValues::has_o_bytes() const {
  return _internal_has_o_bytes();
}
inline void AllocValues::clear_o_bytes() {
  _impl_.o_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AllocValues::o_bytes() const {
  // @@protoc_insertion_point(field_get:foo.AllocValues.o_bytes)
  return _internal_o_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllocValues::set_o_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.o_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.AllocValues.o_bytes)
}
inline std::string* AllocValues::mutable_o_bytes() {
  std::string* _s = _internal_mutable_o_bytes();
  // @@protoc_insertion_point(field_mutable:foo.AllocValues.o_bytes)
  return _s;
}
inline const std::string& AllocValues::_internal_o_bytes() const {
  return _impl_.o_bytes_.Get();
}
inline void AllocValues::_internal_set_o_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.o_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* AllocValues::_internal_mutable_o_bytes() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.o_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* AllocValues::release_o_bytes() {
  // @@protoc_insertion_point(field_release:foo.AllocValues.o_bytes)
  if (!_internal_has_o_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.o_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.o_bytes_.IsDefault()) {
    _impl_.o_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllocValues::set_allocated_o_bytes(std::string* o_bytes) {
  if (o_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.o_bytes_.SetAllocated(o_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.o_bytes_.IsDefault()) {
    _impl_.o_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.AllocValues.o_bytes)
}

// repeated string r_string = 2;
inline int AllocValues::_internal_r_string_size() const {
  return _impl_.r_string_.size();
}
inline int AllocValues::r_string_size() const {
  return _internal_r_string_size();
}
inline void AllocValues::clear_r_string() {
  _impl_.r_string_.Clear();
}
inline std::string* AllocValues::add_r_string() {
  std::string* _s = _internal_add_r_string();
  // @@protoc_insertion_point(field_add_mutable:foo.AllocValues.r_string)
  return _s;
}
inline const std::string& AllocValues::_internal_r_string(int index) const {
  return _impl_.r_string_.Get(index);
}
inline const std::string& AllocValues::r_string(int index) const {
  // @@protoc_insertion_point(field_get:foo.AllocValues.r_string)
  return _internal_r_string(index);
}
inline std::string* AllocValues::mutable_r_string(int index) {
  // @@protoc_insertion_point(field_mutable:foo.AllocValues.r_string)
  return _impl_.r_string_.Mutable(index);
}
inline void AllocValues::set_r_string(int index, const std::string& value) {
  _impl_.r_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:foo.AllocValues.r_string)
}
inline void AllocValues::set_r_string(int index, std::string&& value) {
  _impl_.r_string_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:foo.AllocValues.r_string)
}
inline void AllocValues::set_r_string(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.r_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:foo.AllocValues.r_string)
}
inline void AllocValues::set_r_string(int index, const char* value, size_t size) {
  _impl_.r_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:foo.AllocValues.r_string)
}
inline std::string* AllocValues::_internal_add_r_string() {
  return _impl_.r_string_.Add();
}
inline void AllocValues::add_r_string(const std::string& value) {
  _impl_.r_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:foo.AllocValues.r_string)
}
inline void AllocValues::add_r_string(std::string&& value) {
  _impl_.r_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:foo.AllocValues.r_string)
}
inline void AllocValues::add_r_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.r_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:foo.AllocValues.r_string)
}
inline void AllocValues::add_r_string(const char* value, size_t size) {
  _impl_.r_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:foo.AllocValues.r_string)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AllocValues::r_string() const {
  // @@protoc_insertion_point(field_list:foo.AllocValues.r_string)
  return _impl_.r_string_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AllocValues::mutable_r_string() {
  // @@protoc_insertion_point(field_mutable_list:foo.AllocValues.r_string)
  return &_impl_.r_string_;
}

// required string a_string = 3;
inline bool AllocValues::_internal_has_a_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AllocValues::has_a_string() const {
  return _internal_has_a_string();
}
inline void AllocValues::clear_a_string() {
  _impl_.a_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AllocValues::a_string() const {
  // @@protoc_insertion_point(field_get:foo.AllocValues.a_string)
  return _internal_a_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllocValues::set_a_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.a_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.AllocValues.a_string)
}
inline std::string* AllocValues::mutable_a_string() {
  std::string* _s = _internal_mutable_a_string();
  // @@protoc_insertion_point(field_mutable:foo.AllocValues.a_string)
  return _s;
}
inline const std::string& AllocValues::_internal_a_string() const {
  return _impl_.a_string_.Get();
}
inline void AllocValues::_internal_set_a_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.a_string_.Set(value, GetArenaForAllocation());
}
inline std::string* AllocValues::_internal_mutable_a_string() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.a_string_.Mutable(GetArenaForAllocation());
}
inline std::string* AllocValues::release_a_string() {
  // @@protoc_insertion_point(field_release:foo.AllocValues.a_string)
  if (!_internal_has_a_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.a_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.a_string_.IsDefault()) {
    _impl_.a_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllocValues::set_allocated_a_string(std::string* a_string) {
  if (a_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.a_string_.SetAllocated(a_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.a_string_.IsDefault()) {
    _impl_.a_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.AllocValues.a_string)
}

// required bytes a_bytes = 4;
inline bool AllocValues::_internal_has_a_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AllocValues::has_a_bytes() const {
  return _internal_has_a_bytes();
}
inline void AllocValues::clear_a_bytes() {
  _impl_.a_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AllocValues::a_bytes() const {
  // @@protoc_insertion_point(field_get:foo.AllocValues.a_bytes)
  return _internal_a_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllocValues::set_a_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.a_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.AllocValues.a_bytes)
}
inline std::string* AllocValues::mutable_a_bytes() {
  std::string* _s = _internal_mutable_a_bytes();
  // @@protoc_insertion_point(field_mutable:foo.AllocValues.a_bytes)
  return _s;
}
inline const std::string& AllocValues::_internal_a_bytes() const {
  return _impl_.a_bytes_.Get();
}
inline void AllocValues::_internal_set_a_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.a_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* AllocValues::_internal_mutable_a_bytes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.a_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* AllocValues::release_a_bytes() {
  // @@protoc_insertion_point(field_release:foo.AllocValues.a_bytes)
  if (!_internal_has_a_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.a_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.a_bytes_.IsDefault()) {
    _impl_.a_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AllocValues::set_allocated_a_bytes(std::string* a_bytes) {
  if (a_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.a_bytes_.SetAllocated(a_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.a_bytes_.IsDefault()) {
    _impl_.a_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.AllocValues.a_bytes)
}

// required .foo.DefaultRequiredValues a_mess = 5;
inline bool AllocValues::_internal_has_a_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.a_mess_ != nullptr);
  return value;
}
inline bool AllocValues::has_a_mess() const {
  return _internal_has_a_mess();
}
inline void AllocValues::clear_a_mess() {
  if (_impl_.a_mess_ != nullptr) _impl_.a_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::foo::DefaultRequiredValues& AllocValues::_internal_a_mess() const {
  const ::foo::DefaultRequiredValues* p = _impl_.a_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::DefaultRequiredValues&>(
      ::foo::_DefaultRequiredValues_default_instance_);
}
inline const ::foo::DefaultRequiredValues& AllocValues::a_mess() const {
  // @@protoc_insertion_point(field_get:foo.AllocValues.a_mess)
  return _internal_a_mess();
}
inline void AllocValues::unsafe_arena_set_allocated_a_mess(
    ::foo::DefaultRequiredValues* a_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.a_mess_);
  }
  _impl_.a_mess_ = a_mess;
  if (a_mess) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.AllocValues.a_mess)
}
inline ::foo::DefaultRequiredValues* AllocValues::release_a_mess() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::foo::DefaultRequiredValues* temp = _impl_.a_mess_;
  _impl_.a_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::DefaultRequiredValues* AllocValues::unsafe_arena_release_a_mess() {
  // @@protoc_insertion_point(field_release:foo.AllocValues.a_mess)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::foo::DefaultRequiredValues* temp = _impl_.a_mess_;
  _impl_.a_mess_ = nullptr;
  return temp;
}
inline ::foo::DefaultRequiredValues* AllocValues::_internal_mutable_a_mess() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.a_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::DefaultRequiredValues>(GetArenaForAllocation());
    _impl_.a_mess_ = p;
  }
  return _impl_.a_mess_;
}
inline ::foo::DefaultRequiredValues* AllocValues::mutable_a_mess() {
  ::foo::DefaultRequiredValues* _msg = _internal_mutable_a_mess();
  // @@protoc_insertion_point(field_mutable:foo.AllocValues.a_mess)
  return _msg;
}
inline void AllocValues::set_allocated_a_mess(::foo::DefaultRequiredValues* a_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.a_mess_;
  }
  if (a_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(a_mess);
    if (message_arena != submessage_arena) {
      a_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.a_mess_ = a_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.AllocValues.a_mess)
}

// -------------------------------------------------------------------

// TestRequiredFieldsBitmap

// required string field1 = 1;
inline bool TestRequiredFieldsBitmap::_internal_has_field1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field1() const {
  return _internal_has_field1();
}
inline void TestRequiredFieldsBitmap::clear_field1() {
  _impl_.field1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestRequiredFieldsBitmap::field1() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field1)
  return _internal_field1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.field1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field1)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field1() {
  std::string* _s = _internal_mutable_field1();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field1)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field1() const {
  return _impl_.field1_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.field1_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.field1_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field1() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field1)
  if (!_internal_has_field1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.field1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field1_.IsDefault()) {
    _impl_.field1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field1(std::string* field1) {
  if (field1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.field1_.SetAllocated(field1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field1_.IsDefault()) {
    _impl_.field1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field1)
}

// optional string field2 = 2;
inline bool TestRequiredFieldsBitmap::_internal_has_field2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field2() const {
  return _internal_has_field2();
}
inline void TestRequiredFieldsBitmap::clear_field2() {
  _impl_.field2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TestRequiredFieldsBitmap::field2() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field2)
  return _internal_field2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.field2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field2)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field2() {
  std::string* _s = _internal_mutable_field2();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field2)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field2() const {
  return _impl_.field2_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.field2_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.field2_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field2() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field2)
  if (!_internal_has_field2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.field2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field2_.IsDefault()) {
    _impl_.field2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field2(std::string* field2) {
  if (field2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.field2_.SetAllocated(field2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field2_.IsDefault()) {
    _impl_.field2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field2)
}

// optional string field3 = 3;
inline bool TestRequiredFieldsBitmap::_internal_has_field3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field3() const {
  return _internal_has_field3();
}
inline void TestRequiredFieldsBitmap::clear_field3() {
  _impl_.field3_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TestRequiredFieldsBitmap::field3() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field3)
  return _internal_field3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field3(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.field3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field3)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field3() {
  std::string* _s = _internal_mutable_field3();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field3)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field3() const {
  return _impl_.field3_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field3(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.field3_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field3() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.field3_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field3() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field3)
  if (!_internal_has_field3()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.field3_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field3_.IsDefault()) {
    _impl_.field3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field3(std::string* field3) {
  if (field3 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.field3_.SetAllocated(field3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field3_.IsDefault()) {
    _impl_.field3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field3)
}

// optional string field4 = 4;
inline bool TestRequiredFieldsBitmap::_internal_has_field4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field4() const {
  return _internal_has_field4();
}
inline void TestRequiredFieldsBitmap::clear_field4() {
  _impl_.field4_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TestRequiredFieldsBitmap::field4() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field4)
  return _internal_field4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field4(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.field4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field4)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field4() {
  std::string* _s = _internal_mutable_field4();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field4)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field4() const {
  return _impl_.field4_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field4(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.field4_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field4() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.field4_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field4() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field4)
  if (!_internal_has_field4()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.field4_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field4_.IsDefault()) {
    _impl_.field4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field4(std::string* field4) {
  if (field4 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.field4_.SetAllocated(field4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field4_.IsDefault()) {
    _impl_.field4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field4)
}

// optional string field5 = 5;
inline bool TestRequiredFieldsBitmap::_internal_has_field5() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field5() const {
  return _internal_has_field5();
}
inline void TestRequiredFieldsBitmap::clear_field5() {
  _impl_.field5_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TestRequiredFieldsBitmap::field5() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field5)
  return _internal_field5();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field5(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.field5_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field5)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field5() {
  std::string* _s = _internal_mutable_field5();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field5)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field5() const {
  return _impl_.field5_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field5(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.field5_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field5() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.field5_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field5() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field5)
  if (!_internal_has_field5()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.field5_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field5_.IsDefault()) {
    _impl_.field5_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field5(std::string* field5) {
  if (field5 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.field5_.SetAllocated(field5, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field5_.IsDefault()) {
    _impl_.field5_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field5)
}

// optional string field6 = 6;
inline bool TestRequiredFieldsBitmap::_internal_has_field6() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field6() const {
  return _internal_has_field6();
}
inline void TestRequiredFieldsBitmap::clear_field6() {
  _impl_.field6_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TestRequiredFieldsBitmap::field6() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field6)
  return _internal_field6();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field6(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.field6_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field6)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field6() {
  std::string* _s = _internal_mutable_field6();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field6)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field6() const {
  return _impl_.field6_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field6(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.field6_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field6() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.field6_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field6() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field6)
  if (!_internal_has_field6()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.field6_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field6_.IsDefault()) {
    _impl_.field6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field6(std::string* field6) {
  if (field6 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.field6_.SetAllocated(field6, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field6_.IsDefault()) {
    _impl_.field6_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field6)
}

// optional string field7 = 7;
inline bool TestRequiredFieldsBitmap::_internal_has_field7() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field7() const {
  return _internal_has_field7();
}
inline void TestRequiredFieldsBitmap::clear_field7() {
  _impl_.field7_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& TestRequiredFieldsBitmap::field7() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field7)
  return _internal_field7();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field7(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.field7_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field7)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field7() {
  std::string* _s = _internal_mutable_field7();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field7)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field7() const {
  return _impl_.field7_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field7(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.field7_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field7() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.field7_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field7() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field7)
  if (!_internal_has_field7()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.field7_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field7_.IsDefault()) {
    _impl_.field7_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field7(std::string* field7) {
  if (field7 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.field7_.SetAllocated(field7, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field7_.IsDefault()) {
    _impl_.field7_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field7)
}

// optional string field8 = 8;
inline bool TestRequiredFieldsBitmap::_internal_has_field8() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field8() const {
  return _internal_has_field8();
}
inline void TestRequiredFieldsBitmap::clear_field8() {
  _impl_.field8_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& TestRequiredFieldsBitmap::field8() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field8)
  return _internal_field8();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field8(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.field8_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field8)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field8() {
  std::string* _s = _internal_mutable_field8();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field8)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field8() const {
  return _impl_.field8_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field8(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.field8_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field8() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.field8_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field8() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field8)
  if (!_internal_has_field8()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.field8_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field8_.IsDefault()) {
    _impl_.field8_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field8(std::string* field8) {
  if (field8 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.field8_.SetAllocated(field8, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field8_.IsDefault()) {
    _impl_.field8_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field8)
}

// optional string field9 = 9;
inline bool TestRequiredFieldsBitmap::_internal_has_field9() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field9() const {
  return _internal_has_field9();
}
inline void TestRequiredFieldsBitmap::clear_field9() {
  _impl_.field9_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& TestRequiredFieldsBitmap::field9() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field9)
  return _internal_field9();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field9(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.field9_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field9)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field9() {
  std::string* _s = _internal_mutable_field9();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field9)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field9() const {
  return _impl_.field9_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field9(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.field9_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field9() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.field9_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field9() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field9)
  if (!_internal_has_field9()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.field9_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field9_.IsDefault()) {
    _impl_.field9_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field9(std::string* field9) {
  if (field9 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.field9_.SetAllocated(field9, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field9_.IsDefault()) {
    _impl_.field9_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field9)
}

// optional string field10 = 10;
inline bool TestRequiredFieldsBitmap::_internal_has_field10() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field10() const {
  return _internal_has_field10();
}
inline void TestRequiredFieldsBitmap::clear_field10() {
  _impl_.field10_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& TestRequiredFieldsBitmap::field10() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field10)
  return _internal_field10();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field10(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.field10_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field10)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field10() {
  std::string* _s = _internal_mutable_field10();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field10)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field10() const {
  return _impl_.field10_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field10(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.field10_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field10() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.field10_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field10() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field10)
  if (!_internal_has_field10()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.field10_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field10_.IsDefault()) {
    _impl_.field10_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field10(std::string* field10) {
  if (field10 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.field10_.SetAllocated(field10, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field10_.IsDefault()) {
    _impl_.field10_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field10)
}

// optional string field11 = 11;
inline bool TestRequiredFieldsBitmap::_internal_has_field11() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field11() const {
  return _internal_has_field11();
}
inline void TestRequiredFieldsBitmap::clear_field11() {
  _impl_.field11_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& TestRequiredFieldsBitmap::field11() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field11)
  return _internal_field11();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field11(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.field11_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field11)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field11() {
  std::string* _s = _internal_mutable_field11();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field11)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field11() const {
  return _impl_.field11_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field11(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.field11_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field11() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.field11_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field11() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field11)
  if (!_internal_has_field11()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.field11_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field11_.IsDefault()) {
    _impl_.field11_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field11(std::string* field11) {
  if (field11 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.field11_.SetAllocated(field11, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field11_.IsDefault()) {
    _impl_.field11_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field11)
}

// optional string field12 = 12;
inline bool TestRequiredFieldsBitmap::_internal_has_field12() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field12() const {
  return _internal_has_field12();
}
inline void TestRequiredFieldsBitmap::clear_field12() {
  _impl_.field12_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& TestRequiredFieldsBitmap::field12() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field12)
  return _internal_field12();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field12(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.field12_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field12)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field12() {
  std::string* _s = _internal_mutable_field12();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field12)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field12() const {
  return _impl_.field12_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field12(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.field12_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field12() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.field12_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field12() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field12)
  if (!_internal_has_field12()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.field12_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field12_.IsDefault()) {
    _impl_.field12_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field12(std::string* field12) {
  if (field12 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.field12_.SetAllocated(field12, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field12_.IsDefault()) {
    _impl_.field12_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field12)
}

// optional string field13 = 13;
inline bool TestRequiredFieldsBitmap::_internal_has_field13() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field13() const {
  return _internal_has_field13();
}
inline void TestRequiredFieldsBitmap::clear_field13() {
  _impl_.field13_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& TestRequiredFieldsBitmap::field13() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field13)
  return _internal_field13();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field13(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.field13_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field13)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field13() {
  std::string* _s = _internal_mutable_field13();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field13)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field13() const {
  return _impl_.field13_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field13(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.field13_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field13() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.field13_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field13() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field13)
  if (!_internal_has_field13()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.field13_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field13_.IsDefault()) {
    _impl_.field13_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field13(std::string* field13) {
  if (field13 != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.field13_.SetAllocated(field13, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field13_.IsDefault()) {
    _impl_.field13_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field13)
}

// optional string field14 = 14;
inline bool TestRequiredFieldsBitmap::_internal_has_field14() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field14() const {
  return _internal_has_field14();
}
inline void TestRequiredFieldsBitmap::clear_field14() {
  _impl_.field14_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& TestRequiredFieldsBitmap::field14() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field14)
  return _internal_field14();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field14(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.field14_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field14)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field14() {
  std::string* _s = _internal_mutable_field14();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field14)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field14() const {
  return _impl_.field14_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field14(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.field14_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field14() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.field14_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field14() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field14)
  if (!_internal_has_field14()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.field14_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field14_.IsDefault()) {
    _impl_.field14_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field14(std::string* field14) {
  if (field14 != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.field14_.SetAllocated(field14, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field14_.IsDefault()) {
    _impl_.field14_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field14)
}

// optional string field15 = 15;
inline bool TestRequiredFieldsBitmap::_internal_has_field15() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field15() const {
  return _internal_has_field15();
}
inline void TestRequiredFieldsBitmap::clear_field15() {
  _impl_.field15_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& TestRequiredFieldsBitmap::field15() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field15)
  return _internal_field15();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field15(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.field15_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field15)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field15() {
  std::string* _s = _internal_mutable_field15();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field15)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field15() const {
  return _impl_.field15_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field15(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.field15_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field15() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.field15_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field15() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field15)
  if (!_internal_has_field15()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.field15_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field15_.IsDefault()) {
    _impl_.field15_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field15(std::string* field15) {
  if (field15 != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.field15_.SetAllocated(field15, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field15_.IsDefault()) {
    _impl_.field15_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field15)
}

// optional string field16 = 16;
inline bool TestRequiredFieldsBitmap::_internal_has_field16() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field16() const {
  return _internal_has_field16();
}
inline void TestRequiredFieldsBitmap::clear_field16() {
  _impl_.field16_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const std::string& TestRequiredFieldsBitmap::field16() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field16)
  return _internal_field16();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field16(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00008000u;
 _impl_.field16_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field16)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field16() {
  std::string* _s = _internal_mutable_field16();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field16)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field16() const {
  return _impl_.field16_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field16(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.field16_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field16() {
  _impl_._has_bits_[0] |= 0x00008000u;
  return _impl_.field16_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field16() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field16)
  if (!_internal_has_field16()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00008000u;
  auto* p = _impl_.field16_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field16_.IsDefault()) {
    _impl_.field16_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field16(std::string* field16) {
  if (field16 != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.field16_.SetAllocated(field16, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field16_.IsDefault()) {
    _impl_.field16_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field16)
}

// optional string field17 = 17;
inline bool TestRequiredFieldsBitmap::_internal_has_field17() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field17() const {
  return _internal_has_field17();
}
inline void TestRequiredFieldsBitmap::clear_field17() {
  _impl_.field17_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const std::string& TestRequiredFieldsBitmap::field17() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field17)
  return _internal_field17();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field17(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00010000u;
 _impl_.field17_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field17)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field17() {
  std::string* _s = _internal_mutable_field17();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field17)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field17() const {
  return _impl_.field17_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field17(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.field17_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field17() {
  _impl_._has_bits_[0] |= 0x00010000u;
  return _impl_.field17_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field17() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field17)
  if (!_internal_has_field17()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00010000u;
  auto* p = _impl_.field17_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field17_.IsDefault()) {
    _impl_.field17_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field17(std::string* field17) {
  if (field17 != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.field17_.SetAllocated(field17, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field17_.IsDefault()) {
    _impl_.field17_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field17)
}

// optional string field18 = 18;
inline bool TestRequiredFieldsBitmap::_internal_has_field18() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field18() const {
  return _internal_has_field18();
}
inline void TestRequiredFieldsBitmap::clear_field18() {
  _impl_.field18_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const std::string& TestRequiredFieldsBitmap::field18() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field18)
  return _internal_field18();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field18(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00020000u;
 _impl_.field18_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field18)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field18() {
  std::string* _s = _internal_mutable_field18();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field18)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field18() const {
  return _impl_.field18_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field18(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.field18_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field18() {
  _impl_._has_bits_[0] |= 0x00020000u;
  return _impl_.field18_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field18() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field18)
  if (!_internal_has_field18()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00020000u;
  auto* p = _impl_.field18_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field18_.IsDefault()) {
    _impl_.field18_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field18(std::string* field18) {
  if (field18 != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.field18_.SetAllocated(field18, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field18_.IsDefault()) {
    _impl_.field18_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field18)
}

// optional string field19 = 19;
inline bool TestRequiredFieldsBitmap::_internal_has_field19() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field19() const {
  return _internal_has_field19();
}
inline void TestRequiredFieldsBitmap::clear_field19() {
  _impl_.field19_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const std::string& TestRequiredFieldsBitmap::field19() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field19)
  return _internal_field19();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field19(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00040000u;
 _impl_.field19_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field19)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field19() {
  std::string* _s = _internal_mutable_field19();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field19)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field19() const {
  return _impl_.field19_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field19(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.field19_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field19() {
  _impl_._has_bits_[0] |= 0x00040000u;
  return _impl_.field19_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field19() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field19)
  if (!_internal_has_field19()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00040000u;
  auto* p = _impl_.field19_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field19_.IsDefault()) {
    _impl_.field19_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field19(std::string* field19) {
  if (field19 != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.field19_.SetAllocated(field19, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field19_.IsDefault()) {
    _impl_.field19_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field19)
}

// optional string field20 = 20;
inline bool TestRequiredFieldsBitmap::_internal_has_field20() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field20() const {
  return _internal_has_field20();
}
inline void TestRequiredFieldsBitmap::clear_field20() {
  _impl_.field20_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const std::string& TestRequiredFieldsBitmap::field20() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field20)
  return _internal_field20();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field20(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00080000u;
 _impl_.field20_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field20)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field20() {
  std::string* _s = _internal_mutable_field20();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field20)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field20() const {
  return _impl_.field20_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field20(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.field20_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field20() {
  _impl_._has_bits_[0] |= 0x00080000u;
  return _impl_.field20_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field20() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field20)
  if (!_internal_has_field20()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00080000u;
  auto* p = _impl_.field20_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field20_.IsDefault()) {
    _impl_.field20_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field20(std::string* field20) {
  if (field20 != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.field20_.SetAllocated(field20, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field20_.IsDefault()) {
    _impl_.field20_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field20)
}

// optional string field21 = 21;
inline bool TestRequiredFieldsBitmap::_internal_has_field21() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field21() const {
  return _internal_has_field21();
}
inline void TestRequiredFieldsBitmap::clear_field21() {
  _impl_.field21_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const std::string& TestRequiredFieldsBitmap::field21() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field21)
  return _internal_field21();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field21(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00100000u;
 _impl_.field21_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field21)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field21() {
  std::string* _s = _internal_mutable_field21();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field21)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field21() const {
  return _impl_.field21_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field21(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.field21_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field21() {
  _impl_._has_bits_[0] |= 0x00100000u;
  return _impl_.field21_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field21() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field21)
  if (!_internal_has_field21()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00100000u;
  auto* p = _impl_.field21_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field21_.IsDefault()) {
    _impl_.field21_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field21(std::string* field21) {
  if (field21 != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.field21_.SetAllocated(field21, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field21_.IsDefault()) {
    _impl_.field21_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field21)
}

// optional string field22 = 22;
inline bool TestRequiredFieldsBitmap::_internal_has_field22() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field22() const {
  return _internal_has_field22();
}
inline void TestRequiredFieldsBitmap::clear_field22() {
  _impl_.field22_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const std::string& TestRequiredFieldsBitmap::field22() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field22)
  return _internal_field22();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field22(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00200000u;
 _impl_.field22_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field22)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field22() {
  std::string* _s = _internal_mutable_field22();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field22)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field22() const {
  return _impl_.field22_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field22(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.field22_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field22() {
  _impl_._has_bits_[0] |= 0x00200000u;
  return _impl_.field22_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field22() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field22)
  if (!_internal_has_field22()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00200000u;
  auto* p = _impl_.field22_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field22_.IsDefault()) {
    _impl_.field22_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field22(std::string* field22) {
  if (field22 != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.field22_.SetAllocated(field22, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field22_.IsDefault()) {
    _impl_.field22_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field22)
}

// optional string field23 = 23;
inline bool TestRequiredFieldsBitmap::_internal_has_field23() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field23() const {
  return _internal_has_field23();
}
inline void TestRequiredFieldsBitmap::clear_field23() {
  _impl_.field23_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const std::string& TestRequiredFieldsBitmap::field23() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field23)
  return _internal_field23();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field23(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00400000u;
 _impl_.field23_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field23)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field23() {
  std::string* _s = _internal_mutable_field23();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field23)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field23() const {
  return _impl_.field23_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field23(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.field23_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field23() {
  _impl_._has_bits_[0] |= 0x00400000u;
  return _impl_.field23_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field23() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field23)
  if (!_internal_has_field23()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00400000u;
  auto* p = _impl_.field23_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field23_.IsDefault()) {
    _impl_.field23_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field23(std::string* field23) {
  if (field23 != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.field23_.SetAllocated(field23, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field23_.IsDefault()) {
    _impl_.field23_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field23)
}

// optional string field24 = 24;
inline bool TestRequiredFieldsBitmap::_internal_has_field24() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field24() const {
  return _internal_has_field24();
}
inline void TestRequiredFieldsBitmap::clear_field24() {
  _impl_.field24_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const std::string& TestRequiredFieldsBitmap::field24() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field24)
  return _internal_field24();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field24(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00800000u;
 _impl_.field24_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field24)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field24() {
  std::string* _s = _internal_mutable_field24();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field24)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field24() const {
  return _impl_.field24_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field24(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.field24_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field24() {
  _impl_._has_bits_[0] |= 0x00800000u;
  return _impl_.field24_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field24() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field24)
  if (!_internal_has_field24()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00800000u;
  auto* p = _impl_.field24_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field24_.IsDefault()) {
    _impl_.field24_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field24(std::string* field24) {
  if (field24 != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.field24_.SetAllocated(field24, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field24_.IsDefault()) {
    _impl_.field24_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field24)
}

// optional string field25 = 25;
inline bool TestRequiredFieldsBitmap::_internal_has_field25() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field25() const {
  return _internal_has_field25();
}
inline void TestRequiredFieldsBitmap::clear_field25() {
  _impl_.field25_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field25() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field25)
  return _internal_field25();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field25(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x01000000u;
 _impl_.field25_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field25)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field25() {
  std::string* _s = _internal_mutable_field25();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field25)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field25() const {
  return _impl_.field25_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field25(const std::string& value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.field25_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field25() {
  _impl_._has_bits_[0] |= 0x01000000u;
  return _impl_.field25_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field25() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field25)
  if (!_internal_has_field25()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x01000000u;
  auto* p = _impl_.field25_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field25_.IsDefault()) {
    _impl_.field25_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field25(std::string* field25) {
  if (field25 != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.field25_.SetAllocated(field25, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field25_.IsDefault()) {
    _impl_.field25_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field25)
}

// optional string field26 = 26;
inline bool TestRequiredFieldsBitmap::_internal_has_field26() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field26() const {
  return _internal_has_field26();
}
inline void TestRequiredFieldsBitmap::clear_field26() {
  _impl_.field26_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field26() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field26)
  return _internal_field26();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field26(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x02000000u;
 _impl_.field26_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field26)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field26() {
  std::string* _s = _internal_mutable_field26();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field26)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field26() const {
  return _impl_.field26_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field26(const std::string& value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.field26_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field26() {
  _impl_._has_bits_[0] |= 0x02000000u;
  return _impl_.field26_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field26() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field26)
  if (!_internal_has_field26()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x02000000u;
  auto* p = _impl_.field26_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field26_.IsDefault()) {
    _impl_.field26_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field26(std::string* field26) {
  if (field26 != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.field26_.SetAllocated(field26, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field26_.IsDefault()) {
    _impl_.field26_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field26)
}

// optional string field27 = 27;
inline bool TestRequiredFieldsBitmap::_internal_has_field27() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field27() const {
  return _internal_has_field27();
}
inline void TestRequiredFieldsBitmap::clear_field27() {
  _impl_.field27_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field27() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field27)
  return _internal_field27();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field27(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x04000000u;
 _impl_.field27_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field27)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field27() {
  std::string* _s = _internal_mutable_field27();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field27)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field27() const {
  return _impl_.field27_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field27(const std::string& value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.field27_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field27() {
  _impl_._has_bits_[0] |= 0x04000000u;
  return _impl_.field27_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field27() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field27)
  if (!_internal_has_field27()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x04000000u;
  auto* p = _impl_.field27_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field27_.IsDefault()) {
    _impl_.field27_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field27(std::string* field27) {
  if (field27 != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.field27_.SetAllocated(field27, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field27_.IsDefault()) {
    _impl_.field27_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field27)
}

// optional string field28 = 28;
inline bool TestRequiredFieldsBitmap::_internal_has_field28() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field28() const {
  return _internal_has_field28();
}
inline void TestRequiredFieldsBitmap::clear_field28() {
  _impl_.field28_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field28() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field28)
  return _internal_field28();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field28(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x08000000u;
 _impl_.field28_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field28)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field28() {
  std::string* _s = _internal_mutable_field28();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field28)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field28() const {
  return _impl_.field28_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field28(const std::string& value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.field28_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field28() {
  _impl_._has_bits_[0] |= 0x08000000u;
  return _impl_.field28_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field28() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field28)
  if (!_internal_has_field28()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x08000000u;
  auto* p = _impl_.field28_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field28_.IsDefault()) {
    _impl_.field28_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field28(std::string* field28) {
  if (field28 != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  _impl_.field28_.SetAllocated(field28, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field28_.IsDefault()) {
    _impl_.field28_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field28)
}

// optional string field29 = 29;
inline bool TestRequiredFieldsBitmap::_internal_has_field29() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field29() const {
  return _internal_has_field29();
}
inline void TestRequiredFieldsBitmap::clear_field29() {
  _impl_.field29_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field29() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field29)
  return _internal_field29();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field29(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x10000000u;
 _impl_.field29_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field29)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field29() {
  std::string* _s = _internal_mutable_field29();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field29)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field29() const {
  return _impl_.field29_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field29(const std::string& value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.field29_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field29() {
  _impl_._has_bits_[0] |= 0x10000000u;
  return _impl_.field29_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field29() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field29)
  if (!_internal_has_field29()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x10000000u;
  auto* p = _impl_.field29_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field29_.IsDefault()) {
    _impl_.field29_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field29(std::string* field29) {
  if (field29 != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  _impl_.field29_.SetAllocated(field29, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field29_.IsDefault()) {
    _impl_.field29_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field29)
}

// optional string field30 = 30;
inline bool TestRequiredFieldsBitmap::_internal_has_field30() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field30() const {
  return _internal_has_field30();
}
inline void TestRequiredFieldsBitmap::clear_field30() {
  _impl_.field30_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field30() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field30)
  return _internal_field30();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field30(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x20000000u;
 _impl_.field30_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field30)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field30() {
  std::string* _s = _internal_mutable_field30();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field30)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field30() const {
  return _impl_.field30_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field30(const std::string& value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.field30_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field30() {
  _impl_._has_bits_[0] |= 0x20000000u;
  return _impl_.field30_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field30() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field30)
  if (!_internal_has_field30()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x20000000u;
  auto* p = _impl_.field30_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field30_.IsDefault()) {
    _impl_.field30_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field30(std::string* field30) {
  if (field30 != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  _impl_.field30_.SetAllocated(field30, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field30_.IsDefault()) {
    _impl_.field30_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field30)
}

// optional string field31 = 31;
inline bool TestRequiredFieldsBitmap::_internal_has_field31() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field31() const {
  return _internal_has_field31();
}
inline void TestRequiredFieldsBitmap::clear_field31() {
  _impl_.field31_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field31() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field31)
  return _internal_field31();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field31(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x40000000u;
 _impl_.field31_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field31)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field31() {
  std::string* _s = _internal_mutable_field31();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field31)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field31() const {
  return _impl_.field31_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field31(const std::string& value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.field31_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field31() {
  _impl_._has_bits_[0] |= 0x40000000u;
  return _impl_.field31_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field31() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field31)
  if (!_internal_has_field31()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x40000000u;
  auto* p = _impl_.field31_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field31_.IsDefault()) {
    _impl_.field31_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field31(std::string* field31) {
  if (field31 != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  _impl_.field31_.SetAllocated(field31, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field31_.IsDefault()) {
    _impl_.field31_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field31)
}

// optional string field32 = 32;
inline bool TestRequiredFieldsBitmap::_internal_has_field32() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field32() const {
  return _internal_has_field32();
}
inline void TestRequiredFieldsBitmap::clear_field32() {
  _impl_.field32_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field32() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field32)
  return _internal_field32();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field32(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x80000000u;
 _impl_.field32_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field32)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field32() {
  std::string* _s = _internal_mutable_field32();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field32)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field32() const {
  return _impl_.field32_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field32(const std::string& value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.field32_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field32() {
  _impl_._has_bits_[0] |= 0x80000000u;
  return _impl_.field32_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field32() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field32)
  if (!_internal_has_field32()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x80000000u;
  auto* p = _impl_.field32_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field32_.IsDefault()) {
    _impl_.field32_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field32(std::string* field32) {
  if (field32 != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  _impl_.field32_.SetAllocated(field32, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field32_.IsDefault()) {
    _impl_.field32_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field32)
}

// optional string field33 = 33;
inline bool TestRequiredFieldsBitmap::_internal_has_field33() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field33() const {
  return _internal_has_field33();
}
inline void TestRequiredFieldsBitmap::clear_field33() {
  _impl_.field33_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const std::string& TestRequiredFieldsBitmap::field33() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field33)
  return _internal_field33();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field33(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000001u;
 _impl_.field33_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field33)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field33() {
  std::string* _s = _internal_mutable_field33();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field33)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field33() const {
  return _impl_.field33_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field33(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.field33_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field33() {
  _impl_._has_bits_[1] |= 0x00000001u;
  return _impl_.field33_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field33() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field33)
  if (!_internal_has_field33()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000001u;
  auto* p = _impl_.field33_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field33_.IsDefault()) {
    _impl_.field33_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field33(std::string* field33) {
  if (field33 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  _impl_.field33_.SetAllocated(field33, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field33_.IsDefault()) {
    _impl_.field33_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field33)
}

// optional string field34 = 34;
inline bool TestRequiredFieldsBitmap::_internal_has_field34() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field34() const {
  return _internal_has_field34();
}
inline void TestRequiredFieldsBitmap::clear_field34() {
  _impl_.field34_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const std::string& TestRequiredFieldsBitmap::field34() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field34)
  return _internal_field34();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field34(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000002u;
 _impl_.field34_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field34)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field34() {
  std::string* _s = _internal_mutable_field34();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field34)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field34() const {
  return _impl_.field34_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field34(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.field34_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field34() {
  _impl_._has_bits_[1] |= 0x00000002u;
  return _impl_.field34_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field34() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field34)
  if (!_internal_has_field34()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000002u;
  auto* p = _impl_.field34_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field34_.IsDefault()) {
    _impl_.field34_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field34(std::string* field34) {
  if (field34 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  _impl_.field34_.SetAllocated(field34, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field34_.IsDefault()) {
    _impl_.field34_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field34)
}

// optional string field35 = 35;
inline bool TestRequiredFieldsBitmap::_internal_has_field35() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field35() const {
  return _internal_has_field35();
}
inline void TestRequiredFieldsBitmap::clear_field35() {
  _impl_.field35_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const std::string& TestRequiredFieldsBitmap::field35() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field35)
  return _internal_field35();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field35(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000004u;
 _impl_.field35_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field35)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field35() {
  std::string* _s = _internal_mutable_field35();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field35)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field35() const {
  return _impl_.field35_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field35(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.field35_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field35() {
  _impl_._has_bits_[1] |= 0x00000004u;
  return _impl_.field35_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field35() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field35)
  if (!_internal_has_field35()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000004u;
  auto* p = _impl_.field35_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field35_.IsDefault()) {
    _impl_.field35_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field35(std::string* field35) {
  if (field35 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  _impl_.field35_.SetAllocated(field35, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field35_.IsDefault()) {
    _impl_.field35_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field35)
}

// optional string field36 = 36;
inline bool TestRequiredFieldsBitmap::_internal_has_field36() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field36() const {
  return _internal_has_field36();
}
inline void TestRequiredFieldsBitmap::clear_field36() {
  _impl_.field36_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const std::string& TestRequiredFieldsBitmap::field36() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field36)
  return _internal_field36();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field36(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000008u;
 _impl_.field36_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field36)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field36() {
  std::string* _s = _internal_mutable_field36();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field36)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field36() const {
  return _impl_.field36_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field36(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.field36_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field36() {
  _impl_._has_bits_[1] |= 0x00000008u;
  return _impl_.field36_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field36() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field36)
  if (!_internal_has_field36()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000008u;
  auto* p = _impl_.field36_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field36_.IsDefault()) {
    _impl_.field36_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field36(std::string* field36) {
  if (field36 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  _impl_.field36_.SetAllocated(field36, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field36_.IsDefault()) {
    _impl_.field36_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field36)
}

// optional string field37 = 37;
inline bool TestRequiredFieldsBitmap::_internal_has_field37() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field37() const {
  return _internal_has_field37();
}
inline void TestRequiredFieldsBitmap::clear_field37() {
  _impl_.field37_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const std::string& TestRequiredFieldsBitmap::field37() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field37)
  return _internal_field37();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field37(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000010u;
 _impl_.field37_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field37)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field37() {
  std::string* _s = _internal_mutable_field37();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field37)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field37() const {
  return _impl_.field37_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field37(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.field37_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field37() {
  _impl_._has_bits_[1] |= 0x00000010u;
  return _impl_.field37_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field37() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field37)
  if (!_internal_has_field37()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000010u;
  auto* p = _impl_.field37_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field37_.IsDefault()) {
    _impl_.field37_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field37(std::string* field37) {
  if (field37 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  _impl_.field37_.SetAllocated(field37, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field37_.IsDefault()) {
    _impl_.field37_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field37)
}

// optional string field38 = 38;
inline bool TestRequiredFieldsBitmap::_internal_has_field38() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field38() const {
  return _internal_has_field38();
}
inline void TestRequiredFieldsBitmap::clear_field38() {
  _impl_.field38_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const std::string& TestRequiredFieldsBitmap::field38() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field38)
  return _internal_field38();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field38(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000020u;
 _impl_.field38_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field38)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field38() {
  std::string* _s = _internal_mutable_field38();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field38)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field38() const {
  return _impl_.field38_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field38(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.field38_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field38() {
  _impl_._has_bits_[1] |= 0x00000020u;
  return _impl_.field38_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field38() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field38)
  if (!_internal_has_field38()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000020u;
  auto* p = _impl_.field38_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field38_.IsDefault()) {
    _impl_.field38_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field38(std::string* field38) {
  if (field38 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  _impl_.field38_.SetAllocated(field38, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field38_.IsDefault()) {
    _impl_.field38_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field38)
}

// optional string field39 = 39;
inline bool TestRequiredFieldsBitmap::_internal_has_field39() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field39() const {
  return _internal_has_field39();
}
inline void TestRequiredFieldsBitmap::clear_field39() {
  _impl_.field39_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const std::string& TestRequiredFieldsBitmap::field39() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field39)
  return _internal_field39();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field39(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000040u;
 _impl_.field39_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field39)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field39() {
  std::string* _s = _internal_mutable_field39();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field39)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field39() const {
  return _impl_.field39_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field39(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.field39_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field39() {
  _impl_._has_bits_[1] |= 0x00000040u;
  return _impl_.field39_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field39() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field39)
  if (!_internal_has_field39()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000040u;
  auto* p = _impl_.field39_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field39_.IsDefault()) {
    _impl_.field39_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field39(std::string* field39) {
  if (field39 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  _impl_.field39_.SetAllocated(field39, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field39_.IsDefault()) {
    _impl_.field39_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field39)
}

// optional string field40 = 40;
inline bool TestRequiredFieldsBitmap::_internal_has_field40() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field40() const {
  return _internal_has_field40();
}
inline void TestRequiredFieldsBitmap::clear_field40() {
  _impl_.field40_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const std::string& TestRequiredFieldsBitmap::field40() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field40)
  return _internal_field40();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field40(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000080u;
 _impl_.field40_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field40)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field40() {
  std::string* _s = _internal_mutable_field40();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field40)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field40() const {
  return _impl_.field40_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field40(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.field40_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field40() {
  _impl_._has_bits_[1] |= 0x00000080u;
  return _impl_.field40_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field40() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field40)
  if (!_internal_has_field40()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000080u;
  auto* p = _impl_.field40_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field40_.IsDefault()) {
    _impl_.field40_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field40(std::string* field40) {
  if (field40 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  _impl_.field40_.SetAllocated(field40, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field40_.IsDefault()) {
    _impl_.field40_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field40)
}

// optional string field41 = 41;
inline bool TestRequiredFieldsBitmap::_internal_has_field41() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field41() const {
  return _internal_has_field41();
}
inline void TestRequiredFieldsBitmap::clear_field41() {
  _impl_.field41_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const std::string& TestRequiredFieldsBitmap::field41() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field41)
  return _internal_field41();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field41(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000100u;
 _impl_.field41_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field41)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field41() {
  std::string* _s = _internal_mutable_field41();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field41)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field41() const {
  return _impl_.field41_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field41(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.field41_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field41() {
  _impl_._has_bits_[1] |= 0x00000100u;
  return _impl_.field41_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field41() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field41)
  if (!_internal_has_field41()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000100u;
  auto* p = _impl_.field41_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field41_.IsDefault()) {
    _impl_.field41_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field41(std::string* field41) {
  if (field41 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  _impl_.field41_.SetAllocated(field41, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field41_.IsDefault()) {
    _impl_.field41_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field41)
}

// optional string field42 = 42;
inline bool TestRequiredFieldsBitmap::_internal_has_field42() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field42() const {
  return _internal_has_field42();
}
inline void TestRequiredFieldsBitmap::clear_field42() {
  _impl_.field42_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const std::string& TestRequiredFieldsBitmap::field42() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field42)
  return _internal_field42();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field42(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000200u;
 _impl_.field42_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field42)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field42() {
  std::string* _s = _internal_mutable_field42();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field42)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field42() const {
  return _impl_.field42_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field42(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.field42_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field42() {
  _impl_._has_bits_[1] |= 0x00000200u;
  return _impl_.field42_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field42() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field42)
  if (!_internal_has_field42()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000200u;
  auto* p = _impl_.field42_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field42_.IsDefault()) {
    _impl_.field42_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field42(std::string* field42) {
  if (field42 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  _impl_.field42_.SetAllocated(field42, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field42_.IsDefault()) {
    _impl_.field42_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field42)
}

// optional string field43 = 43;
inline bool TestRequiredFieldsBitmap::_internal_has_field43() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field43() const {
  return _internal_has_field43();
}
inline void TestRequiredFieldsBitmap::clear_field43() {
  _impl_.field43_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const std::string& TestRequiredFieldsBitmap::field43() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field43)
  return _internal_field43();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field43(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000400u;
 _impl_.field43_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field43)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field43() {
  std::string* _s = _internal_mutable_field43();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field43)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field43() const {
  return _impl_.field43_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field43(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.field43_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field43() {
  _impl_._has_bits_[1] |= 0x00000400u;
  return _impl_.field43_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field43() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field43)
  if (!_internal_has_field43()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000400u;
  auto* p = _impl_.field43_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field43_.IsDefault()) {
    _impl_.field43_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field43(std::string* field43) {
  if (field43 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  _impl_.field43_.SetAllocated(field43, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field43_.IsDefault()) {
    _impl_.field43_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field43)
}

// optional string field44 = 44;
inline bool TestRequiredFieldsBitmap::_internal_has_field44() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field44() const {
  return _internal_has_field44();
}
inline void TestRequiredFieldsBitmap::clear_field44() {
  _impl_.field44_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const std::string& TestRequiredFieldsBitmap::field44() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field44)
  return _internal_field44();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field44(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00000800u;
 _impl_.field44_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field44)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field44() {
  std::string* _s = _internal_mutable_field44();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field44)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field44() const {
  return _impl_.field44_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field44(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00000800u;
  _impl_.field44_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field44() {
  _impl_._has_bits_[1] |= 0x00000800u;
  return _impl_.field44_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field44() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field44)
  if (!_internal_has_field44()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00000800u;
  auto* p = _impl_.field44_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field44_.IsDefault()) {
    _impl_.field44_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field44(std::string* field44) {
  if (field44 != nullptr) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  _impl_.field44_.SetAllocated(field44, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field44_.IsDefault()) {
    _impl_.field44_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field44)
}

// optional string field45 = 45;
inline bool TestRequiredFieldsBitmap::_internal_has_field45() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field45() const {
  return _internal_has_field45();
}
inline void TestRequiredFieldsBitmap::clear_field45() {
  _impl_.field45_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline const std::string& TestRequiredFieldsBitmap::field45() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field45)
  return _internal_field45();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field45(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00001000u;
 _impl_.field45_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field45)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field45() {
  std::string* _s = _internal_mutable_field45();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field45)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field45() const {
  return _impl_.field45_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field45(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00001000u;
  _impl_.field45_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field45() {
  _impl_._has_bits_[1] |= 0x00001000u;
  return _impl_.field45_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field45() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field45)
  if (!_internal_has_field45()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00001000u;
  auto* p = _impl_.field45_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field45_.IsDefault()) {
    _impl_.field45_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field45(std::string* field45) {
  if (field45 != nullptr) {
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  _impl_.field45_.SetAllocated(field45, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field45_.IsDefault()) {
    _impl_.field45_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field45)
}

// optional string field46 = 46;
inline bool TestRequiredFieldsBitmap::_internal_has_field46() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field46() const {
  return _internal_has_field46();
}
inline void TestRequiredFieldsBitmap::clear_field46() {
  _impl_.field46_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline const std::string& TestRequiredFieldsBitmap::field46() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field46)
  return _internal_field46();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field46(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00002000u;
 _impl_.field46_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field46)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field46() {
  std::string* _s = _internal_mutable_field46();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field46)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field46() const {
  return _impl_.field46_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field46(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00002000u;
  _impl_.field46_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field46() {
  _impl_._has_bits_[1] |= 0x00002000u;
  return _impl_.field46_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field46() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field46)
  if (!_internal_has_field46()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00002000u;
  auto* p = _impl_.field46_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field46_.IsDefault()) {
    _impl_.field46_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field46(std::string* field46) {
  if (field46 != nullptr) {
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  _impl_.field46_.SetAllocated(field46, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field46_.IsDefault()) {
    _impl_.field46_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field46)
}

// optional string field47 = 47;
inline bool TestRequiredFieldsBitmap::_internal_has_field47() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field47() const {
  return _internal_has_field47();
}
inline void TestRequiredFieldsBitmap::clear_field47() {
  _impl_.field47_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline const std::string& TestRequiredFieldsBitmap::field47() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field47)
  return _internal_field47();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field47(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00004000u;
 _impl_.field47_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field47)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field47() {
  std::string* _s = _internal_mutable_field47();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field47)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field47() const {
  return _impl_.field47_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field47(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00004000u;
  _impl_.field47_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field47() {
  _impl_._has_bits_[1] |= 0x00004000u;
  return _impl_.field47_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field47() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field47)
  if (!_internal_has_field47()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00004000u;
  auto* p = _impl_.field47_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field47_.IsDefault()) {
    _impl_.field47_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field47(std::string* field47) {
  if (field47 != nullptr) {
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  _impl_.field47_.SetAllocated(field47, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field47_.IsDefault()) {
    _impl_.field47_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field47)
}

// optional string field48 = 48;
inline bool TestRequiredFieldsBitmap::_internal_has_field48() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field48() const {
  return _internal_has_field48();
}
inline void TestRequiredFieldsBitmap::clear_field48() {
  _impl_.field48_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline const std::string& TestRequiredFieldsBitmap::field48() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field48)
  return _internal_field48();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field48(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00008000u;
 _impl_.field48_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field48)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field48() {
  std::string* _s = _internal_mutable_field48();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field48)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field48() const {
  return _impl_.field48_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field48(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00008000u;
  _impl_.field48_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field48() {
  _impl_._has_bits_[1] |= 0x00008000u;
  return _impl_.field48_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field48() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field48)
  if (!_internal_has_field48()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00008000u;
  auto* p = _impl_.field48_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field48_.IsDefault()) {
    _impl_.field48_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field48(std::string* field48) {
  if (field48 != nullptr) {
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  _impl_.field48_.SetAllocated(field48, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field48_.IsDefault()) {
    _impl_.field48_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field48)
}

// optional string field49 = 49;
inline bool TestRequiredFieldsBitmap::_internal_has_field49() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field49() const {
  return _internal_has_field49();
}
inline void TestRequiredFieldsBitmap::clear_field49() {
  _impl_.field49_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline const std::string& TestRequiredFieldsBitmap::field49() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field49)
  return _internal_field49();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field49(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00010000u;
 _impl_.field49_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field49)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field49() {
  std::string* _s = _internal_mutable_field49();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field49)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field49() const {
  return _impl_.field49_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field49(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00010000u;
  _impl_.field49_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field49() {
  _impl_._has_bits_[1] |= 0x00010000u;
  return _impl_.field49_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field49() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field49)
  if (!_internal_has_field49()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00010000u;
  auto* p = _impl_.field49_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field49_.IsDefault()) {
    _impl_.field49_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field49(std::string* field49) {
  if (field49 != nullptr) {
    _impl_._has_bits_[1] |= 0x00010000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00010000u;
  }
  _impl_.field49_.SetAllocated(field49, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field49_.IsDefault()) {
    _impl_.field49_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field49)
}

// optional string field50 = 50;
inline bool TestRequiredFieldsBitmap::_internal_has_field50() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field50() const {
  return _internal_has_field50();
}
inline void TestRequiredFieldsBitmap::clear_field50() {
  _impl_.field50_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline const std::string& TestRequiredFieldsBitmap::field50() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field50)
  return _internal_field50();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field50(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00020000u;
 _impl_.field50_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field50)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field50() {
  std::string* _s = _internal_mutable_field50();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field50)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field50() const {
  return _impl_.field50_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field50(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00020000u;
  _impl_.field50_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field50() {
  _impl_._has_bits_[1] |= 0x00020000u;
  return _impl_.field50_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field50() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field50)
  if (!_internal_has_field50()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00020000u;
  auto* p = _impl_.field50_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field50_.IsDefault()) {
    _impl_.field50_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field50(std::string* field50) {
  if (field50 != nullptr) {
    _impl_._has_bits_[1] |= 0x00020000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00020000u;
  }
  _impl_.field50_.SetAllocated(field50, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field50_.IsDefault()) {
    _impl_.field50_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field50)
}

// optional string field51 = 51;
inline bool TestRequiredFieldsBitmap::_internal_has_field51() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field51() const {
  return _internal_has_field51();
}
inline void TestRequiredFieldsBitmap::clear_field51() {
  _impl_.field51_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline const std::string& TestRequiredFieldsBitmap::field51() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field51)
  return _internal_field51();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field51(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00040000u;
 _impl_.field51_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field51)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field51() {
  std::string* _s = _internal_mutable_field51();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field51)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field51() const {
  return _impl_.field51_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field51(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00040000u;
  _impl_.field51_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field51() {
  _impl_._has_bits_[1] |= 0x00040000u;
  return _impl_.field51_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field51() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field51)
  if (!_internal_has_field51()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00040000u;
  auto* p = _impl_.field51_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field51_.IsDefault()) {
    _impl_.field51_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field51(std::string* field51) {
  if (field51 != nullptr) {
    _impl_._has_bits_[1] |= 0x00040000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00040000u;
  }
  _impl_.field51_.SetAllocated(field51, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field51_.IsDefault()) {
    _impl_.field51_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field51)
}

// optional string field52 = 52;
inline bool TestRequiredFieldsBitmap::_internal_has_field52() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field52() const {
  return _internal_has_field52();
}
inline void TestRequiredFieldsBitmap::clear_field52() {
  _impl_.field52_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline const std::string& TestRequiredFieldsBitmap::field52() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field52)
  return _internal_field52();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field52(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00080000u;
 _impl_.field52_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field52)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field52() {
  std::string* _s = _internal_mutable_field52();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field52)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field52() const {
  return _impl_.field52_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field52(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00080000u;
  _impl_.field52_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field52() {
  _impl_._has_bits_[1] |= 0x00080000u;
  return _impl_.field52_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field52() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field52)
  if (!_internal_has_field52()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00080000u;
  auto* p = _impl_.field52_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field52_.IsDefault()) {
    _impl_.field52_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field52(std::string* field52) {
  if (field52 != nullptr) {
    _impl_._has_bits_[1] |= 0x00080000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00080000u;
  }
  _impl_.field52_.SetAllocated(field52, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field52_.IsDefault()) {
    _impl_.field52_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field52)
}

// optional string field53 = 53;
inline bool TestRequiredFieldsBitmap::_internal_has_field53() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field53() const {
  return _internal_has_field53();
}
inline void TestRequiredFieldsBitmap::clear_field53() {
  _impl_.field53_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline const std::string& TestRequiredFieldsBitmap::field53() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field53)
  return _internal_field53();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field53(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00100000u;
 _impl_.field53_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field53)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field53() {
  std::string* _s = _internal_mutable_field53();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field53)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field53() const {
  return _impl_.field53_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field53(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00100000u;
  _impl_.field53_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field53() {
  _impl_._has_bits_[1] |= 0x00100000u;
  return _impl_.field53_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field53() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field53)
  if (!_internal_has_field53()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00100000u;
  auto* p = _impl_.field53_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field53_.IsDefault()) {
    _impl_.field53_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field53(std::string* field53) {
  if (field53 != nullptr) {
    _impl_._has_bits_[1] |= 0x00100000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00100000u;
  }
  _impl_.field53_.SetAllocated(field53, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field53_.IsDefault()) {
    _impl_.field53_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field53)
}

// optional string field54 = 54;
inline bool TestRequiredFieldsBitmap::_internal_has_field54() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field54() const {
  return _internal_has_field54();
}
inline void TestRequiredFieldsBitmap::clear_field54() {
  _impl_.field54_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline const std::string& TestRequiredFieldsBitmap::field54() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field54)
  return _internal_field54();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field54(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00200000u;
 _impl_.field54_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field54)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field54() {
  std::string* _s = _internal_mutable_field54();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field54)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field54() const {
  return _impl_.field54_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field54(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00200000u;
  _impl_.field54_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field54() {
  _impl_._has_bits_[1] |= 0x00200000u;
  return _impl_.field54_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field54() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field54)
  if (!_internal_has_field54()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00200000u;
  auto* p = _impl_.field54_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field54_.IsDefault()) {
    _impl_.field54_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field54(std::string* field54) {
  if (field54 != nullptr) {
    _impl_._has_bits_[1] |= 0x00200000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00200000u;
  }
  _impl_.field54_.SetAllocated(field54, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field54_.IsDefault()) {
    _impl_.field54_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field54)
}

// optional string field55 = 55;
inline bool TestRequiredFieldsBitmap::_internal_has_field55() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field55() const {
  return _internal_has_field55();
}
inline void TestRequiredFieldsBitmap::clear_field55() {
  _impl_.field55_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline const std::string& TestRequiredFieldsBitmap::field55() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field55)
  return _internal_field55();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field55(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00400000u;
 _impl_.field55_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field55)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field55() {
  std::string* _s = _internal_mutable_field55();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field55)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field55() const {
  return _impl_.field55_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field55(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00400000u;
  _impl_.field55_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field55() {
  _impl_._has_bits_[1] |= 0x00400000u;
  return _impl_.field55_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field55() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field55)
  if (!_internal_has_field55()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00400000u;
  auto* p = _impl_.field55_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field55_.IsDefault()) {
    _impl_.field55_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field55(std::string* field55) {
  if (field55 != nullptr) {
    _impl_._has_bits_[1] |= 0x00400000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00400000u;
  }
  _impl_.field55_.SetAllocated(field55, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field55_.IsDefault()) {
    _impl_.field55_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field55)
}

// optional string field56 = 56;
inline bool TestRequiredFieldsBitmap::_internal_has_field56() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field56() const {
  return _internal_has_field56();
}
inline void TestRequiredFieldsBitmap::clear_field56() {
  _impl_.field56_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline const std::string& TestRequiredFieldsBitmap::field56() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field56)
  return _internal_field56();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field56(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x00800000u;
 _impl_.field56_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field56)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field56() {
  std::string* _s = _internal_mutable_field56();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field56)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field56() const {
  return _impl_.field56_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field56(const std::string& value) {
  _impl_._has_bits_[1] |= 0x00800000u;
  _impl_.field56_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field56() {
  _impl_._has_bits_[1] |= 0x00800000u;
  return _impl_.field56_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field56() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field56)
  if (!_internal_has_field56()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x00800000u;
  auto* p = _impl_.field56_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field56_.IsDefault()) {
    _impl_.field56_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field56(std::string* field56) {
  if (field56 != nullptr) {
    _impl_._has_bits_[1] |= 0x00800000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00800000u;
  }
  _impl_.field56_.SetAllocated(field56, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field56_.IsDefault()) {
    _impl_.field56_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field56)
}

// optional string field57 = 57;
inline bool TestRequiredFieldsBitmap::_internal_has_field57() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field57() const {
  return _internal_has_field57();
}
inline void TestRequiredFieldsBitmap::clear_field57() {
  _impl_.field57_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field57() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field57)
  return _internal_field57();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field57(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x01000000u;
 _impl_.field57_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field57)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field57() {
  std::string* _s = _internal_mutable_field57();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field57)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field57() const {
  return _impl_.field57_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field57(const std::string& value) {
  _impl_._has_bits_[1] |= 0x01000000u;
  _impl_.field57_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field57() {
  _impl_._has_bits_[1] |= 0x01000000u;
  return _impl_.field57_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field57() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field57)
  if (!_internal_has_field57()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x01000000u;
  auto* p = _impl_.field57_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field57_.IsDefault()) {
    _impl_.field57_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field57(std::string* field57) {
  if (field57 != nullptr) {
    _impl_._has_bits_[1] |= 0x01000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x01000000u;
  }
  _impl_.field57_.SetAllocated(field57, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field57_.IsDefault()) {
    _impl_.field57_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field57)
}

// optional string field58 = 58;
inline bool TestRequiredFieldsBitmap::_internal_has_field58() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field58() const {
  return _internal_has_field58();
}
inline void TestRequiredFieldsBitmap::clear_field58() {
  _impl_.field58_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field58() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field58)
  return _internal_field58();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field58(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x02000000u;
 _impl_.field58_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field58)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field58() {
  std::string* _s = _internal_mutable_field58();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field58)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field58() const {
  return _impl_.field58_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field58(const std::string& value) {
  _impl_._has_bits_[1] |= 0x02000000u;
  _impl_.field58_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field58() {
  _impl_._has_bits_[1] |= 0x02000000u;
  return _impl_.field58_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field58() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field58)
  if (!_internal_has_field58()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x02000000u;
  auto* p = _impl_.field58_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field58_.IsDefault()) {
    _impl_.field58_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field58(std::string* field58) {
  if (field58 != nullptr) {
    _impl_._has_bits_[1] |= 0x02000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x02000000u;
  }
  _impl_.field58_.SetAllocated(field58, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field58_.IsDefault()) {
    _impl_.field58_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field58)
}

// optional string field59 = 59;
inline bool TestRequiredFieldsBitmap::_internal_has_field59() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field59() const {
  return _internal_has_field59();
}
inline void TestRequiredFieldsBitmap::clear_field59() {
  _impl_.field59_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field59() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field59)
  return _internal_field59();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field59(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x04000000u;
 _impl_.field59_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field59)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field59() {
  std::string* _s = _internal_mutable_field59();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field59)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field59() const {
  return _impl_.field59_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field59(const std::string& value) {
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.field59_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field59() {
  _impl_._has_bits_[1] |= 0x04000000u;
  return _impl_.field59_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field59() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field59)
  if (!_internal_has_field59()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x04000000u;
  auto* p = _impl_.field59_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field59_.IsDefault()) {
    _impl_.field59_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field59(std::string* field59) {
  if (field59 != nullptr) {
    _impl_._has_bits_[1] |= 0x04000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x04000000u;
  }
  _impl_.field59_.SetAllocated(field59, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field59_.IsDefault()) {
    _impl_.field59_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field59)
}

// optional string field60 = 60;
inline bool TestRequiredFieldsBitmap::_internal_has_field60() const {
  bool value = (_impl_._has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field60() const {
  return _internal_has_field60();
}
inline void TestRequiredFieldsBitmap::clear_field60() {
  _impl_.field60_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x08000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field60() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field60)
  return _internal_field60();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field60(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x08000000u;
 _impl_.field60_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field60)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field60() {
  std::string* _s = _internal_mutable_field60();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field60)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field60() const {
  return _impl_.field60_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field60(const std::string& value) {
  _impl_._has_bits_[1] |= 0x08000000u;
  _impl_.field60_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field60() {
  _impl_._has_bits_[1] |= 0x08000000u;
  return _impl_.field60_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field60() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field60)
  if (!_internal_has_field60()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x08000000u;
  auto* p = _impl_.field60_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field60_.IsDefault()) {
    _impl_.field60_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field60(std::string* field60) {
  if (field60 != nullptr) {
    _impl_._has_bits_[1] |= 0x08000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x08000000u;
  }
  _impl_.field60_.SetAllocated(field60, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field60_.IsDefault()) {
    _impl_.field60_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field60)
}

// optional string field61 = 61;
inline bool TestRequiredFieldsBitmap::_internal_has_field61() const {
  bool value = (_impl_._has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field61() const {
  return _internal_has_field61();
}
inline void TestRequiredFieldsBitmap::clear_field61() {
  _impl_.field61_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x10000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field61() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field61)
  return _internal_field61();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field61(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x10000000u;
 _impl_.field61_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field61)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field61() {
  std::string* _s = _internal_mutable_field61();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field61)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field61() const {
  return _impl_.field61_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field61(const std::string& value) {
  _impl_._has_bits_[1] |= 0x10000000u;
  _impl_.field61_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field61() {
  _impl_._has_bits_[1] |= 0x10000000u;
  return _impl_.field61_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field61() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field61)
  if (!_internal_has_field61()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x10000000u;
  auto* p = _impl_.field61_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field61_.IsDefault()) {
    _impl_.field61_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field61(std::string* field61) {
  if (field61 != nullptr) {
    _impl_._has_bits_[1] |= 0x10000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x10000000u;
  }
  _impl_.field61_.SetAllocated(field61, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field61_.IsDefault()) {
    _impl_.field61_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field61)
}

// optional string field62 = 62;
inline bool TestRequiredFieldsBitmap::_internal_has_field62() const {
  bool value = (_impl_._has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field62() const {
  return _internal_has_field62();
}
inline void TestRequiredFieldsBitmap::clear_field62() {
  _impl_.field62_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x20000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field62() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field62)
  return _internal_field62();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field62(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x20000000u;
 _impl_.field62_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field62)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field62() {
  std::string* _s = _internal_mutable_field62();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field62)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field62() const {
  return _impl_.field62_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field62(const std::string& value) {
  _impl_._has_bits_[1] |= 0x20000000u;
  _impl_.field62_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field62() {
  _impl_._has_bits_[1] |= 0x20000000u;
  return _impl_.field62_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field62() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field62)
  if (!_internal_has_field62()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x20000000u;
  auto* p = _impl_.field62_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field62_.IsDefault()) {
    _impl_.field62_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field62(std::string* field62) {
  if (field62 != nullptr) {
    _impl_._has_bits_[1] |= 0x20000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x20000000u;
  }
  _impl_.field62_.SetAllocated(field62, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field62_.IsDefault()) {
    _impl_.field62_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field62)
}

// optional string field63 = 63;
inline bool TestRequiredFieldsBitmap::_internal_has_field63() const {
  bool value = (_impl_._has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field63() const {
  return _internal_has_field63();
}
inline void TestRequiredFieldsBitmap::clear_field63() {
  _impl_.field63_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x40000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field63() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field63)
  return _internal_field63();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field63(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x40000000u;
 _impl_.field63_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field63)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field63() {
  std::string* _s = _internal_mutable_field63();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field63)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field63() const {
  return _impl_.field63_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field63(const std::string& value) {
  _impl_._has_bits_[1] |= 0x40000000u;
  _impl_.field63_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field63() {
  _impl_._has_bits_[1] |= 0x40000000u;
  return _impl_.field63_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field63() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field63)
  if (!_internal_has_field63()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x40000000u;
  auto* p = _impl_.field63_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field63_.IsDefault()) {
    _impl_.field63_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field63(std::string* field63) {
  if (field63 != nullptr) {
    _impl_._has_bits_[1] |= 0x40000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x40000000u;
  }
  _impl_.field63_.SetAllocated(field63, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field63_.IsDefault()) {
    _impl_.field63_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field63)
}

// optional string field64 = 64;
inline bool TestRequiredFieldsBitmap::_internal_has_field64() const {
  bool value = (_impl_._has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field64() const {
  return _internal_has_field64();
}
inline void TestRequiredFieldsBitmap::clear_field64() {
  _impl_.field64_.ClearToEmpty();
  _impl_._has_bits_[1] &= ~0x80000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field64() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field64)
  return _internal_field64();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field64(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[1] |= 0x80000000u;
 _impl_.field64_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field64)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field64() {
  std::string* _s = _internal_mutable_field64();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field64)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field64() const {
  return _impl_.field64_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field64(const std::string& value) {
  _impl_._has_bits_[1] |= 0x80000000u;
  _impl_.field64_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field64() {
  _impl_._has_bits_[1] |= 0x80000000u;
  return _impl_.field64_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field64() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field64)
  if (!_internal_has_field64()) {
    return nullptr;
  }
  _impl_._has_bits_[1] &= ~0x80000000u;
  auto* p = _impl_.field64_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field64_.IsDefault()) {
    _impl_.field64_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field64(std::string* field64) {
  if (field64 != nullptr) {
    _impl_._has_bits_[1] |= 0x80000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x80000000u;
  }
  _impl_.field64_.SetAllocated(field64, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field64_.IsDefault()) {
    _impl_.field64_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field64)
}

// optional string field65 = 65;
inline bool TestRequiredFieldsBitmap::_internal_has_field65() const {
  bool value = (_impl_._has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field65() const {
  return _internal_has_field65();
}
inline void TestRequiredFieldsBitmap::clear_field65() {
  _impl_.field65_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000001u;
}
inline const std::string& TestRequiredFieldsBitmap::field65() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field65)
  return _internal_field65();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field65(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000001u;
 _impl_.field65_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field65)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field65() {
  std::string* _s = _internal_mutable_field65();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field65)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field65() const {
  return _impl_.field65_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field65(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000001u;
  _impl_.field65_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field65() {
  _impl_._has_bits_[2] |= 0x00000001u;
  return _impl_.field65_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field65() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field65)
  if (!_internal_has_field65()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000001u;
  auto* p = _impl_.field65_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field65_.IsDefault()) {
    _impl_.field65_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field65(std::string* field65) {
  if (field65 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000001u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000001u;
  }
  _impl_.field65_.SetAllocated(field65, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field65_.IsDefault()) {
    _impl_.field65_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field65)
}

// optional string field66 = 66;
inline bool TestRequiredFieldsBitmap::_internal_has_field66() const {
  bool value = (_impl_._has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field66() const {
  return _internal_has_field66();
}
inline void TestRequiredFieldsBitmap::clear_field66() {
  _impl_.field66_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000002u;
}
inline const std::string& TestRequiredFieldsBitmap::field66() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field66)
  return _internal_field66();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field66(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000002u;
 _impl_.field66_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field66)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field66() {
  std::string* _s = _internal_mutable_field66();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field66)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field66() const {
  return _impl_.field66_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field66(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000002u;
  _impl_.field66_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field66() {
  _impl_._has_bits_[2] |= 0x00000002u;
  return _impl_.field66_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field66() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field66)
  if (!_internal_has_field66()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000002u;
  auto* p = _impl_.field66_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field66_.IsDefault()) {
    _impl_.field66_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field66(std::string* field66) {
  if (field66 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000002u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000002u;
  }
  _impl_.field66_.SetAllocated(field66, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field66_.IsDefault()) {
    _impl_.field66_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field66)
}

// optional string field67 = 67;
inline bool TestRequiredFieldsBitmap::_internal_has_field67() const {
  bool value = (_impl_._has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field67() const {
  return _internal_has_field67();
}
inline void TestRequiredFieldsBitmap::clear_field67() {
  _impl_.field67_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000004u;
}
inline const std::string& TestRequiredFieldsBitmap::field67() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field67)
  return _internal_field67();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field67(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000004u;
 _impl_.field67_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field67)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field67() {
  std::string* _s = _internal_mutable_field67();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field67)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field67() const {
  return _impl_.field67_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field67(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000004u;
  _impl_.field67_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field67() {
  _impl_._has_bits_[2] |= 0x00000004u;
  return _impl_.field67_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field67() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field67)
  if (!_internal_has_field67()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000004u;
  auto* p = _impl_.field67_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field67_.IsDefault()) {
    _impl_.field67_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field67(std::string* field67) {
  if (field67 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000004u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000004u;
  }
  _impl_.field67_.SetAllocated(field67, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field67_.IsDefault()) {
    _impl_.field67_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field67)
}

// optional string field68 = 68;
inline bool TestRequiredFieldsBitmap::_internal_has_field68() const {
  bool value = (_impl_._has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field68() const {
  return _internal_has_field68();
}
inline void TestRequiredFieldsBitmap::clear_field68() {
  _impl_.field68_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000008u;
}
inline const std::string& TestRequiredFieldsBitmap::field68() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field68)
  return _internal_field68();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field68(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000008u;
 _impl_.field68_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field68)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field68() {
  std::string* _s = _internal_mutable_field68();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field68)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field68() const {
  return _impl_.field68_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field68(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000008u;
  _impl_.field68_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field68() {
  _impl_._has_bits_[2] |= 0x00000008u;
  return _impl_.field68_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field68() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field68)
  if (!_internal_has_field68()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000008u;
  auto* p = _impl_.field68_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field68_.IsDefault()) {
    _impl_.field68_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field68(std::string* field68) {
  if (field68 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000008u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000008u;
  }
  _impl_.field68_.SetAllocated(field68, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field68_.IsDefault()) {
    _impl_.field68_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field68)
}

// optional string field69 = 69;
inline bool TestRequiredFieldsBitmap::_internal_has_field69() const {
  bool value = (_impl_._has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field69() const {
  return _internal_has_field69();
}
inline void TestRequiredFieldsBitmap::clear_field69() {
  _impl_.field69_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000010u;
}
inline const std::string& TestRequiredFieldsBitmap::field69() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field69)
  return _internal_field69();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field69(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000010u;
 _impl_.field69_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field69)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field69() {
  std::string* _s = _internal_mutable_field69();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field69)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field69() const {
  return _impl_.field69_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field69(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000010u;
  _impl_.field69_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field69() {
  _impl_._has_bits_[2] |= 0x00000010u;
  return _impl_.field69_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field69() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field69)
  if (!_internal_has_field69()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000010u;
  auto* p = _impl_.field69_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field69_.IsDefault()) {
    _impl_.field69_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field69(std::string* field69) {
  if (field69 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000010u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000010u;
  }
  _impl_.field69_.SetAllocated(field69, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field69_.IsDefault()) {
    _impl_.field69_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field69)
}

// optional string field70 = 70;
inline bool TestRequiredFieldsBitmap::_internal_has_field70() const {
  bool value = (_impl_._has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field70() const {
  return _internal_has_field70();
}
inline void TestRequiredFieldsBitmap::clear_field70() {
  _impl_.field70_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000020u;
}
inline const std::string& TestRequiredFieldsBitmap::field70() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field70)
  return _internal_field70();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field70(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000020u;
 _impl_.field70_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field70)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field70() {
  std::string* _s = _internal_mutable_field70();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field70)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field70() const {
  return _impl_.field70_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field70(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000020u;
  _impl_.field70_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field70() {
  _impl_._has_bits_[2] |= 0x00000020u;
  return _impl_.field70_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field70() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field70)
  if (!_internal_has_field70()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000020u;
  auto* p = _impl_.field70_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field70_.IsDefault()) {
    _impl_.field70_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field70(std::string* field70) {
  if (field70 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000020u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000020u;
  }
  _impl_.field70_.SetAllocated(field70, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field70_.IsDefault()) {
    _impl_.field70_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field70)
}

// optional string field71 = 71;
inline bool TestRequiredFieldsBitmap::_internal_has_field71() const {
  bool value = (_impl_._has_bits_[2] & 0x00000040u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field71() const {
  return _internal_has_field71();
}
inline void TestRequiredFieldsBitmap::clear_field71() {
  _impl_.field71_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000040u;
}
inline const std::string& TestRequiredFieldsBitmap::field71() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field71)
  return _internal_field71();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field71(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000040u;
 _impl_.field71_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field71)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field71() {
  std::string* _s = _internal_mutable_field71();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field71)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field71() const {
  return _impl_.field71_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field71(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000040u;
  _impl_.field71_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field71() {
  _impl_._has_bits_[2] |= 0x00000040u;
  return _impl_.field71_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field71() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field71)
  if (!_internal_has_field71()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000040u;
  auto* p = _impl_.field71_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field71_.IsDefault()) {
    _impl_.field71_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field71(std::string* field71) {
  if (field71 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000040u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000040u;
  }
  _impl_.field71_.SetAllocated(field71, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field71_.IsDefault()) {
    _impl_.field71_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field71)
}

// optional string field72 = 72;
inline bool TestRequiredFieldsBitmap::_internal_has_field72() const {
  bool value = (_impl_._has_bits_[2] & 0x00000080u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field72() const {
  return _internal_has_field72();
}
inline void TestRequiredFieldsBitmap::clear_field72() {
  _impl_.field72_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000080u;
}
inline const std::string& TestRequiredFieldsBitmap::field72() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field72)
  return _internal_field72();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field72(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000080u;
 _impl_.field72_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field72)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field72() {
  std::string* _s = _internal_mutable_field72();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field72)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field72() const {
  return _impl_.field72_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field72(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000080u;
  _impl_.field72_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field72() {
  _impl_._has_bits_[2] |= 0x00000080u;
  return _impl_.field72_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field72() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field72)
  if (!_internal_has_field72()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000080u;
  auto* p = _impl_.field72_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field72_.IsDefault()) {
    _impl_.field72_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field72(std::string* field72) {
  if (field72 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000080u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000080u;
  }
  _impl_.field72_.SetAllocated(field72, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field72_.IsDefault()) {
    _impl_.field72_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field72)
}

// optional string field73 = 73;
inline bool TestRequiredFieldsBitmap::_internal_has_field73() const {
  bool value = (_impl_._has_bits_[2] & 0x00000100u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field73() const {
  return _internal_has_field73();
}
inline void TestRequiredFieldsBitmap::clear_field73() {
  _impl_.field73_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000100u;
}
inline const std::string& TestRequiredFieldsBitmap::field73() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field73)
  return _internal_field73();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field73(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000100u;
 _impl_.field73_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field73)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field73() {
  std::string* _s = _internal_mutable_field73();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field73)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field73() const {
  return _impl_.field73_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field73(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000100u;
  _impl_.field73_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field73() {
  _impl_._has_bits_[2] |= 0x00000100u;
  return _impl_.field73_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field73() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field73)
  if (!_internal_has_field73()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000100u;
  auto* p = _impl_.field73_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field73_.IsDefault()) {
    _impl_.field73_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field73(std::string* field73) {
  if (field73 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000100u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000100u;
  }
  _impl_.field73_.SetAllocated(field73, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field73_.IsDefault()) {
    _impl_.field73_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field73)
}

// optional string field74 = 74;
inline bool TestRequiredFieldsBitmap::_internal_has_field74() const {
  bool value = (_impl_._has_bits_[2] & 0x00000200u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field74() const {
  return _internal_has_field74();
}
inline void TestRequiredFieldsBitmap::clear_field74() {
  _impl_.field74_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000200u;
}
inline const std::string& TestRequiredFieldsBitmap::field74() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field74)
  return _internal_field74();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field74(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000200u;
 _impl_.field74_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field74)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field74() {
  std::string* _s = _internal_mutable_field74();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field74)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field74() const {
  return _impl_.field74_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field74(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000200u;
  _impl_.field74_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field74() {
  _impl_._has_bits_[2] |= 0x00000200u;
  return _impl_.field74_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field74() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field74)
  if (!_internal_has_field74()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000200u;
  auto* p = _impl_.field74_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field74_.IsDefault()) {
    _impl_.field74_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field74(std::string* field74) {
  if (field74 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000200u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000200u;
  }
  _impl_.field74_.SetAllocated(field74, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field74_.IsDefault()) {
    _impl_.field74_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field74)
}

// optional string field75 = 75;
inline bool TestRequiredFieldsBitmap::_internal_has_field75() const {
  bool value = (_impl_._has_bits_[2] & 0x00000400u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field75() const {
  return _internal_has_field75();
}
inline void TestRequiredFieldsBitmap::clear_field75() {
  _impl_.field75_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000400u;
}
inline const std::string& TestRequiredFieldsBitmap::field75() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field75)
  return _internal_field75();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field75(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000400u;
 _impl_.field75_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field75)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field75() {
  std::string* _s = _internal_mutable_field75();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field75)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field75() const {
  return _impl_.field75_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field75(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000400u;
  _impl_.field75_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field75() {
  _impl_._has_bits_[2] |= 0x00000400u;
  return _impl_.field75_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field75() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field75)
  if (!_internal_has_field75()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000400u;
  auto* p = _impl_.field75_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field75_.IsDefault()) {
    _impl_.field75_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field75(std::string* field75) {
  if (field75 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000400u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000400u;
  }
  _impl_.field75_.SetAllocated(field75, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field75_.IsDefault()) {
    _impl_.field75_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field75)
}

// optional string field76 = 76;
inline bool TestRequiredFieldsBitmap::_internal_has_field76() const {
  bool value = (_impl_._has_bits_[2] & 0x00000800u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field76() const {
  return _internal_has_field76();
}
inline void TestRequiredFieldsBitmap::clear_field76() {
  _impl_.field76_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00000800u;
}
inline const std::string& TestRequiredFieldsBitmap::field76() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field76)
  return _internal_field76();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field76(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00000800u;
 _impl_.field76_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field76)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field76() {
  std::string* _s = _internal_mutable_field76();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field76)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field76() const {
  return _impl_.field76_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field76(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00000800u;
  _impl_.field76_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field76() {
  _impl_._has_bits_[2] |= 0x00000800u;
  return _impl_.field76_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field76() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field76)
  if (!_internal_has_field76()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00000800u;
  auto* p = _impl_.field76_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field76_.IsDefault()) {
    _impl_.field76_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field76(std::string* field76) {
  if (field76 != nullptr) {
    _impl_._has_bits_[2] |= 0x00000800u;
  } else {
    _impl_._has_bits_[2] &= ~0x00000800u;
  }
  _impl_.field76_.SetAllocated(field76, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field76_.IsDefault()) {
    _impl_.field76_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field76)
}

// optional string field77 = 77;
inline bool TestRequiredFieldsBitmap::_internal_has_field77() const {
  bool value = (_impl_._has_bits_[2] & 0x00001000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field77() const {
  return _internal_has_field77();
}
inline void TestRequiredFieldsBitmap::clear_field77() {
  _impl_.field77_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00001000u;
}
inline const std::string& TestRequiredFieldsBitmap::field77() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field77)
  return _internal_field77();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field77(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00001000u;
 _impl_.field77_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field77)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field77() {
  std::string* _s = _internal_mutable_field77();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field77)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field77() const {
  return _impl_.field77_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field77(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00001000u;
  _impl_.field77_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field77() {
  _impl_._has_bits_[2] |= 0x00001000u;
  return _impl_.field77_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field77() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field77)
  if (!_internal_has_field77()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00001000u;
  auto* p = _impl_.field77_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field77_.IsDefault()) {
    _impl_.field77_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field77(std::string* field77) {
  if (field77 != nullptr) {
    _impl_._has_bits_[2] |= 0x00001000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00001000u;
  }
  _impl_.field77_.SetAllocated(field77, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field77_.IsDefault()) {
    _impl_.field77_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field77)
}

// optional string field78 = 78;
inline bool TestRequiredFieldsBitmap::_internal_has_field78() const {
  bool value = (_impl_._has_bits_[2] & 0x00002000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field78() const {
  return _internal_has_field78();
}
inline void TestRequiredFieldsBitmap::clear_field78() {
  _impl_.field78_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00002000u;
}
inline const std::string& TestRequiredFieldsBitmap::field78() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field78)
  return _internal_field78();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field78(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00002000u;
 _impl_.field78_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field78)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field78() {
  std::string* _s = _internal_mutable_field78();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field78)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field78() const {
  return _impl_.field78_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field78(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00002000u;
  _impl_.field78_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field78() {
  _impl_._has_bits_[2] |= 0x00002000u;
  return _impl_.field78_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field78() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field78)
  if (!_internal_has_field78()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00002000u;
  auto* p = _impl_.field78_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field78_.IsDefault()) {
    _impl_.field78_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field78(std::string* field78) {
  if (field78 != nullptr) {
    _impl_._has_bits_[2] |= 0x00002000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00002000u;
  }
  _impl_.field78_.SetAllocated(field78, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field78_.IsDefault()) {
    _impl_.field78_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field78)
}

// optional string field79 = 79;
inline bool TestRequiredFieldsBitmap::_internal_has_field79() const {
  bool value = (_impl_._has_bits_[2] & 0x00004000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field79() const {
  return _internal_has_field79();
}
inline void TestRequiredFieldsBitmap::clear_field79() {
  _impl_.field79_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00004000u;
}
inline const std::string& TestRequiredFieldsBitmap::field79() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field79)
  return _internal_field79();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field79(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00004000u;
 _impl_.field79_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field79)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field79() {
  std::string* _s = _internal_mutable_field79();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field79)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field79() const {
  return _impl_.field79_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field79(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00004000u;
  _impl_.field79_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field79() {
  _impl_._has_bits_[2] |= 0x00004000u;
  return _impl_.field79_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field79() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field79)
  if (!_internal_has_field79()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00004000u;
  auto* p = _impl_.field79_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field79_.IsDefault()) {
    _impl_.field79_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field79(std::string* field79) {
  if (field79 != nullptr) {
    _impl_._has_bits_[2] |= 0x00004000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00004000u;
  }
  _impl_.field79_.SetAllocated(field79, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field79_.IsDefault()) {
    _impl_.field79_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field79)
}

// optional string field80 = 80;
inline bool TestRequiredFieldsBitmap::_internal_has_field80() const {
  bool value = (_impl_._has_bits_[2] & 0x00008000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field80() const {
  return _internal_has_field80();
}
inline void TestRequiredFieldsBitmap::clear_field80() {
  _impl_.field80_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00008000u;
}
inline const std::string& TestRequiredFieldsBitmap::field80() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field80)
  return _internal_field80();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field80(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00008000u;
 _impl_.field80_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field80)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field80() {
  std::string* _s = _internal_mutable_field80();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field80)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field80() const {
  return _impl_.field80_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field80(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00008000u;
  _impl_.field80_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field80() {
  _impl_._has_bits_[2] |= 0x00008000u;
  return _impl_.field80_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field80() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field80)
  if (!_internal_has_field80()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00008000u;
  auto* p = _impl_.field80_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field80_.IsDefault()) {
    _impl_.field80_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field80(std::string* field80) {
  if (field80 != nullptr) {
    _impl_._has_bits_[2] |= 0x00008000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00008000u;
  }
  _impl_.field80_.SetAllocated(field80, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field80_.IsDefault()) {
    _impl_.field80_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field80)
}

// optional string field81 = 81;
inline bool TestRequiredFieldsBitmap::_internal_has_field81() const {
  bool value = (_impl_._has_bits_[2] & 0x00010000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field81() const {
  return _internal_has_field81();
}
inline void TestRequiredFieldsBitmap::clear_field81() {
  _impl_.field81_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00010000u;
}
inline const std::string& TestRequiredFieldsBitmap::field81() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field81)
  return _internal_field81();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field81(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00010000u;
 _impl_.field81_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field81)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field81() {
  std::string* _s = _internal_mutable_field81();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field81)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field81() const {
  return _impl_.field81_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field81(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00010000u;
  _impl_.field81_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field81() {
  _impl_._has_bits_[2] |= 0x00010000u;
  return _impl_.field81_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field81() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field81)
  if (!_internal_has_field81()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00010000u;
  auto* p = _impl_.field81_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field81_.IsDefault()) {
    _impl_.field81_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field81(std::string* field81) {
  if (field81 != nullptr) {
    _impl_._has_bits_[2] |= 0x00010000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00010000u;
  }
  _impl_.field81_.SetAllocated(field81, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field81_.IsDefault()) {
    _impl_.field81_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field81)
}

// optional string field82 = 82;
inline bool TestRequiredFieldsBitmap::_internal_has_field82() const {
  bool value = (_impl_._has_bits_[2] & 0x00020000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field82() const {
  return _internal_has_field82();
}
inline void TestRequiredFieldsBitmap::clear_field82() {
  _impl_.field82_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00020000u;
}
inline const std::string& TestRequiredFieldsBitmap::field82() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field82)
  return _internal_field82();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field82(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00020000u;
 _impl_.field82_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field82)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field82() {
  std::string* _s = _internal_mutable_field82();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field82)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field82() const {
  return _impl_.field82_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field82(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00020000u;
  _impl_.field82_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field82() {
  _impl_._has_bits_[2] |= 0x00020000u;
  return _impl_.field82_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field82() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field82)
  if (!_internal_has_field82()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00020000u;
  auto* p = _impl_.field82_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field82_.IsDefault()) {
    _impl_.field82_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field82(std::string* field82) {
  if (field82 != nullptr) {
    _impl_._has_bits_[2] |= 0x00020000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00020000u;
  }
  _impl_.field82_.SetAllocated(field82, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field82_.IsDefault()) {
    _impl_.field82_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field82)
}

// optional string field83 = 83;
inline bool TestRequiredFieldsBitmap::_internal_has_field83() const {
  bool value = (_impl_._has_bits_[2] & 0x00040000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field83() const {
  return _internal_has_field83();
}
inline void TestRequiredFieldsBitmap::clear_field83() {
  _impl_.field83_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00040000u;
}
inline const std::string& TestRequiredFieldsBitmap::field83() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field83)
  return _internal_field83();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field83(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00040000u;
 _impl_.field83_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field83)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field83() {
  std::string* _s = _internal_mutable_field83();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field83)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field83() const {
  return _impl_.field83_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field83(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00040000u;
  _impl_.field83_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field83() {
  _impl_._has_bits_[2] |= 0x00040000u;
  return _impl_.field83_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field83() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field83)
  if (!_internal_has_field83()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00040000u;
  auto* p = _impl_.field83_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field83_.IsDefault()) {
    _impl_.field83_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field83(std::string* field83) {
  if (field83 != nullptr) {
    _impl_._has_bits_[2] |= 0x00040000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00040000u;
  }
  _impl_.field83_.SetAllocated(field83, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field83_.IsDefault()) {
    _impl_.field83_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field83)
}

// optional string field84 = 84;
inline bool TestRequiredFieldsBitmap::_internal_has_field84() const {
  bool value = (_impl_._has_bits_[2] & 0x00080000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field84() const {
  return _internal_has_field84();
}
inline void TestRequiredFieldsBitmap::clear_field84() {
  _impl_.field84_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00080000u;
}
inline const std::string& TestRequiredFieldsBitmap::field84() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field84)
  return _internal_field84();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field84(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00080000u;
 _impl_.field84_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field84)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field84() {
  std::string* _s = _internal_mutable_field84();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field84)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field84() const {
  return _impl_.field84_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field84(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00080000u;
  _impl_.field84_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field84() {
  _impl_._has_bits_[2] |= 0x00080000u;
  return _impl_.field84_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field84() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field84)
  if (!_internal_has_field84()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00080000u;
  auto* p = _impl_.field84_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field84_.IsDefault()) {
    _impl_.field84_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field84(std::string* field84) {
  if (field84 != nullptr) {
    _impl_._has_bits_[2] |= 0x00080000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00080000u;
  }
  _impl_.field84_.SetAllocated(field84, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field84_.IsDefault()) {
    _impl_.field84_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field84)
}

// optional string field85 = 85;
inline bool TestRequiredFieldsBitmap::_internal_has_field85() const {
  bool value = (_impl_._has_bits_[2] & 0x00100000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field85() const {
  return _internal_has_field85();
}
inline void TestRequiredFieldsBitmap::clear_field85() {
  _impl_.field85_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00100000u;
}
inline const std::string& TestRequiredFieldsBitmap::field85() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field85)
  return _internal_field85();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field85(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00100000u;
 _impl_.field85_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field85)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field85() {
  std::string* _s = _internal_mutable_field85();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field85)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field85() const {
  return _impl_.field85_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field85(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00100000u;
  _impl_.field85_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field85() {
  _impl_._has_bits_[2] |= 0x00100000u;
  return _impl_.field85_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field85() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field85)
  if (!_internal_has_field85()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00100000u;
  auto* p = _impl_.field85_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field85_.IsDefault()) {
    _impl_.field85_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field85(std::string* field85) {
  if (field85 != nullptr) {
    _impl_._has_bits_[2] |= 0x00100000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00100000u;
  }
  _impl_.field85_.SetAllocated(field85, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field85_.IsDefault()) {
    _impl_.field85_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field85)
}

// optional string field86 = 86;
inline bool TestRequiredFieldsBitmap::_internal_has_field86() const {
  bool value = (_impl_._has_bits_[2] & 0x00200000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field86() const {
  return _internal_has_field86();
}
inline void TestRequiredFieldsBitmap::clear_field86() {
  _impl_.field86_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00200000u;
}
inline const std::string& TestRequiredFieldsBitmap::field86() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field86)
  return _internal_field86();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field86(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00200000u;
 _impl_.field86_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field86)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field86() {
  std::string* _s = _internal_mutable_field86();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field86)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field86() const {
  return _impl_.field86_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field86(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00200000u;
  _impl_.field86_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field86() {
  _impl_._has_bits_[2] |= 0x00200000u;
  return _impl_.field86_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field86() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field86)
  if (!_internal_has_field86()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00200000u;
  auto* p = _impl_.field86_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field86_.IsDefault()) {
    _impl_.field86_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field86(std::string* field86) {
  if (field86 != nullptr) {
    _impl_._has_bits_[2] |= 0x00200000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00200000u;
  }
  _impl_.field86_.SetAllocated(field86, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field86_.IsDefault()) {
    _impl_.field86_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field86)
}

// optional string field87 = 87;
inline bool TestRequiredFieldsBitmap::_internal_has_field87() const {
  bool value = (_impl_._has_bits_[2] & 0x00400000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field87() const {
  return _internal_has_field87();
}
inline void TestRequiredFieldsBitmap::clear_field87() {
  _impl_.field87_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00400000u;
}
inline const std::string& TestRequiredFieldsBitmap::field87() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field87)
  return _internal_field87();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field87(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00400000u;
 _impl_.field87_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field87)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field87() {
  std::string* _s = _internal_mutable_field87();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field87)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field87() const {
  return _impl_.field87_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field87(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00400000u;
  _impl_.field87_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field87() {
  _impl_._has_bits_[2] |= 0x00400000u;
  return _impl_.field87_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field87() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field87)
  if (!_internal_has_field87()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00400000u;
  auto* p = _impl_.field87_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field87_.IsDefault()) {
    _impl_.field87_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field87(std::string* field87) {
  if (field87 != nullptr) {
    _impl_._has_bits_[2] |= 0x00400000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00400000u;
  }
  _impl_.field87_.SetAllocated(field87, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field87_.IsDefault()) {
    _impl_.field87_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field87)
}

// optional string field88 = 88;
inline bool TestRequiredFieldsBitmap::_internal_has_field88() const {
  bool value = (_impl_._has_bits_[2] & 0x00800000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field88() const {
  return _internal_has_field88();
}
inline void TestRequiredFieldsBitmap::clear_field88() {
  _impl_.field88_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x00800000u;
}
inline const std::string& TestRequiredFieldsBitmap::field88() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field88)
  return _internal_field88();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field88(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x00800000u;
 _impl_.field88_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field88)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field88() {
  std::string* _s = _internal_mutable_field88();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field88)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field88() const {
  return _impl_.field88_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field88(const std::string& value) {
  _impl_._has_bits_[2] |= 0x00800000u;
  _impl_.field88_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field88() {
  _impl_._has_bits_[2] |= 0x00800000u;
  return _impl_.field88_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field88() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field88)
  if (!_internal_has_field88()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x00800000u;
  auto* p = _impl_.field88_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field88_.IsDefault()) {
    _impl_.field88_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field88(std::string* field88) {
  if (field88 != nullptr) {
    _impl_._has_bits_[2] |= 0x00800000u;
  } else {
    _impl_._has_bits_[2] &= ~0x00800000u;
  }
  _impl_.field88_.SetAllocated(field88, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field88_.IsDefault()) {
    _impl_.field88_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field88)
}

// optional string field89 = 89;
inline bool TestRequiredFieldsBitmap::_internal_has_field89() const {
  bool value = (_impl_._has_bits_[2] & 0x01000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field89() const {
  return _internal_has_field89();
}
inline void TestRequiredFieldsBitmap::clear_field89() {
  _impl_.field89_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x01000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field89() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field89)
  return _internal_field89();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field89(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x01000000u;
 _impl_.field89_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field89)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field89() {
  std::string* _s = _internal_mutable_field89();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field89)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field89() const {
  return _impl_.field89_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field89(const std::string& value) {
  _impl_._has_bits_[2] |= 0x01000000u;
  _impl_.field89_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field89() {
  _impl_._has_bits_[2] |= 0x01000000u;
  return _impl_.field89_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field89() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field89)
  if (!_internal_has_field89()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x01000000u;
  auto* p = _impl_.field89_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field89_.IsDefault()) {
    _impl_.field89_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field89(std::string* field89) {
  if (field89 != nullptr) {
    _impl_._has_bits_[2] |= 0x01000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x01000000u;
  }
  _impl_.field89_.SetAllocated(field89, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field89_.IsDefault()) {
    _impl_.field89_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field89)
}

// optional string field90 = 90;
inline bool TestRequiredFieldsBitmap::_internal_has_field90() const {
  bool value = (_impl_._has_bits_[2] & 0x02000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field90() const {
  return _internal_has_field90();
}
inline void TestRequiredFieldsBitmap::clear_field90() {
  _impl_.field90_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x02000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field90() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field90)
  return _internal_field90();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field90(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x02000000u;
 _impl_.field90_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field90)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field90() {
  std::string* _s = _internal_mutable_field90();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field90)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field90() const {
  return _impl_.field90_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field90(const std::string& value) {
  _impl_._has_bits_[2] |= 0x02000000u;
  _impl_.field90_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field90() {
  _impl_._has_bits_[2] |= 0x02000000u;
  return _impl_.field90_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field90() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field90)
  if (!_internal_has_field90()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x02000000u;
  auto* p = _impl_.field90_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field90_.IsDefault()) {
    _impl_.field90_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field90(std::string* field90) {
  if (field90 != nullptr) {
    _impl_._has_bits_[2] |= 0x02000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x02000000u;
  }
  _impl_.field90_.SetAllocated(field90, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field90_.IsDefault()) {
    _impl_.field90_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field90)
}

// optional string field91 = 91;
inline bool TestRequiredFieldsBitmap::_internal_has_field91() const {
  bool value = (_impl_._has_bits_[2] & 0x04000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field91() const {
  return _internal_has_field91();
}
inline void TestRequiredFieldsBitmap::clear_field91() {
  _impl_.field91_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x04000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field91() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field91)
  return _internal_field91();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field91(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x04000000u;
 _impl_.field91_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field91)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field91() {
  std::string* _s = _internal_mutable_field91();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field91)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field91() const {
  return _impl_.field91_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field91(const std::string& value) {
  _impl_._has_bits_[2] |= 0x04000000u;
  _impl_.field91_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field91() {
  _impl_._has_bits_[2] |= 0x04000000u;
  return _impl_.field91_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field91() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field91)
  if (!_internal_has_field91()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x04000000u;
  auto* p = _impl_.field91_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field91_.IsDefault()) {
    _impl_.field91_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field91(std::string* field91) {
  if (field91 != nullptr) {
    _impl_._has_bits_[2] |= 0x04000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x04000000u;
  }
  _impl_.field91_.SetAllocated(field91, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field91_.IsDefault()) {
    _impl_.field91_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field91)
}

// optional string field92 = 92;
inline bool TestRequiredFieldsBitmap::_internal_has_field92() const {
  bool value = (_impl_._has_bits_[2] & 0x08000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field92() const {
  return _internal_has_field92();
}
inline void TestRequiredFieldsBitmap::clear_field92() {
  _impl_.field92_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x08000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field92() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field92)
  return _internal_field92();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field92(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x08000000u;
 _impl_.field92_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field92)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field92() {
  std::string* _s = _internal_mutable_field92();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field92)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field92() const {
  return _impl_.field92_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field92(const std::string& value) {
  _impl_._has_bits_[2] |= 0x08000000u;
  _impl_.field92_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field92() {
  _impl_._has_bits_[2] |= 0x08000000u;
  return _impl_.field92_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field92() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field92)
  if (!_internal_has_field92()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x08000000u;
  auto* p = _impl_.field92_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field92_.IsDefault()) {
    _impl_.field92_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field92(std::string* field92) {
  if (field92 != nullptr) {
    _impl_._has_bits_[2] |= 0x08000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x08000000u;
  }
  _impl_.field92_.SetAllocated(field92, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field92_.IsDefault()) {
    _impl_.field92_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field92)
}

// optional string field93 = 93;
inline bool TestRequiredFieldsBitmap::_internal_has_field93() const {
  bool value = (_impl_._has_bits_[2] & 0x10000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field93() const {
  return _internal_has_field93();
}
inline void TestRequiredFieldsBitmap::clear_field93() {
  _impl_.field93_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x10000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field93() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field93)
  return _internal_field93();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field93(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x10000000u;
 _impl_.field93_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field93)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field93() {
  std::string* _s = _internal_mutable_field93();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field93)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field93() const {
  return _impl_.field93_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field93(const std::string& value) {
  _impl_._has_bits_[2] |= 0x10000000u;
  _impl_.field93_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field93() {
  _impl_._has_bits_[2] |= 0x10000000u;
  return _impl_.field93_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field93() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field93)
  if (!_internal_has_field93()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x10000000u;
  auto* p = _impl_.field93_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field93_.IsDefault()) {
    _impl_.field93_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field93(std::string* field93) {
  if (field93 != nullptr) {
    _impl_._has_bits_[2] |= 0x10000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x10000000u;
  }
  _impl_.field93_.SetAllocated(field93, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field93_.IsDefault()) {
    _impl_.field93_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field93)
}

// optional string field94 = 94;
inline bool TestRequiredFieldsBitmap::_internal_has_field94() const {
  bool value = (_impl_._has_bits_[2] & 0x20000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field94() const {
  return _internal_has_field94();
}
inline void TestRequiredFieldsBitmap::clear_field94() {
  _impl_.field94_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x20000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field94() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field94)
  return _internal_field94();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field94(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x20000000u;
 _impl_.field94_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field94)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field94() {
  std::string* _s = _internal_mutable_field94();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field94)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field94() const {
  return _impl_.field94_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field94(const std::string& value) {
  _impl_._has_bits_[2] |= 0x20000000u;
  _impl_.field94_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field94() {
  _impl_._has_bits_[2] |= 0x20000000u;
  return _impl_.field94_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field94() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field94)
  if (!_internal_has_field94()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x20000000u;
  auto* p = _impl_.field94_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field94_.IsDefault()) {
    _impl_.field94_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field94(std::string* field94) {
  if (field94 != nullptr) {
    _impl_._has_bits_[2] |= 0x20000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x20000000u;
  }
  _impl_.field94_.SetAllocated(field94, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field94_.IsDefault()) {
    _impl_.field94_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field94)
}

// optional string field95 = 95;
inline bool TestRequiredFieldsBitmap::_internal_has_field95() const {
  bool value = (_impl_._has_bits_[2] & 0x40000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field95() const {
  return _internal_has_field95();
}
inline void TestRequiredFieldsBitmap::clear_field95() {
  _impl_.field95_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x40000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field95() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field95)
  return _internal_field95();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field95(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x40000000u;
 _impl_.field95_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field95)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field95() {
  std::string* _s = _internal_mutable_field95();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field95)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field95() const {
  return _impl_.field95_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field95(const std::string& value) {
  _impl_._has_bits_[2] |= 0x40000000u;
  _impl_.field95_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field95() {
  _impl_._has_bits_[2] |= 0x40000000u;
  return _impl_.field95_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field95() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field95)
  if (!_internal_has_field95()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x40000000u;
  auto* p = _impl_.field95_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field95_.IsDefault()) {
    _impl_.field95_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field95(std::string* field95) {
  if (field95 != nullptr) {
    _impl_._has_bits_[2] |= 0x40000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x40000000u;
  }
  _impl_.field95_.SetAllocated(field95, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field95_.IsDefault()) {
    _impl_.field95_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field95)
}

// optional string field96 = 96;
inline bool TestRequiredFieldsBitmap::_internal_has_field96() const {
  bool value = (_impl_._has_bits_[2] & 0x80000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field96() const {
  return _internal_has_field96();
}
inline void TestRequiredFieldsBitmap::clear_field96() {
  _impl_.field96_.ClearToEmpty();
  _impl_._has_bits_[2] &= ~0x80000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field96() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field96)
  return _internal_field96();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field96(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[2] |= 0x80000000u;
 _impl_.field96_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field96)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field96() {
  std::string* _s = _internal_mutable_field96();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field96)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field96() const {
  return _impl_.field96_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field96(const std::string& value) {
  _impl_._has_bits_[2] |= 0x80000000u;
  _impl_.field96_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field96() {
  _impl_._has_bits_[2] |= 0x80000000u;
  return _impl_.field96_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field96() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field96)
  if (!_internal_has_field96()) {
    return nullptr;
  }
  _impl_._has_bits_[2] &= ~0x80000000u;
  auto* p = _impl_.field96_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field96_.IsDefault()) {
    _impl_.field96_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field96(std::string* field96) {
  if (field96 != nullptr) {
    _impl_._has_bits_[2] |= 0x80000000u;
  } else {
    _impl_._has_bits_[2] &= ~0x80000000u;
  }
  _impl_.field96_.SetAllocated(field96, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field96_.IsDefault()) {
    _impl_.field96_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field96)
}

// optional string field97 = 97;
inline bool TestRequiredFieldsBitmap::_internal_has_field97() const {
  bool value = (_impl_._has_bits_[3] & 0x00000001u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field97() const {
  return _internal_has_field97();
}
inline void TestRequiredFieldsBitmap::clear_field97() {
  _impl_.field97_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000001u;
}
inline const std::string& TestRequiredFieldsBitmap::field97() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field97)
  return _internal_field97();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field97(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000001u;
 _impl_.field97_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field97)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field97() {
  std::string* _s = _internal_mutable_field97();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field97)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field97() const {
  return _impl_.field97_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field97(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000001u;
  _impl_.field97_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field97() {
  _impl_._has_bits_[3] |= 0x00000001u;
  return _impl_.field97_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field97() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field97)
  if (!_internal_has_field97()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000001u;
  auto* p = _impl_.field97_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field97_.IsDefault()) {
    _impl_.field97_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field97(std::string* field97) {
  if (field97 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000001u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000001u;
  }
  _impl_.field97_.SetAllocated(field97, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field97_.IsDefault()) {
    _impl_.field97_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field97)
}

// optional string field98 = 98;
inline bool TestRequiredFieldsBitmap::_internal_has_field98() const {
  bool value = (_impl_._has_bits_[3] & 0x00000002u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field98() const {
  return _internal_has_field98();
}
inline void TestRequiredFieldsBitmap::clear_field98() {
  _impl_.field98_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000002u;
}
inline const std::string& TestRequiredFieldsBitmap::field98() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field98)
  return _internal_field98();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field98(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000002u;
 _impl_.field98_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field98)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field98() {
  std::string* _s = _internal_mutable_field98();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field98)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field98() const {
  return _impl_.field98_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field98(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000002u;
  _impl_.field98_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field98() {
  _impl_._has_bits_[3] |= 0x00000002u;
  return _impl_.field98_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field98() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field98)
  if (!_internal_has_field98()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000002u;
  auto* p = _impl_.field98_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field98_.IsDefault()) {
    _impl_.field98_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field98(std::string* field98) {
  if (field98 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000002u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000002u;
  }
  _impl_.field98_.SetAllocated(field98, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field98_.IsDefault()) {
    _impl_.field98_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field98)
}

// optional string field99 = 99;
inline bool TestRequiredFieldsBitmap::_internal_has_field99() const {
  bool value = (_impl_._has_bits_[3] & 0x00000004u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field99() const {
  return _internal_has_field99();
}
inline void TestRequiredFieldsBitmap::clear_field99() {
  _impl_.field99_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000004u;
}
inline const std::string& TestRequiredFieldsBitmap::field99() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field99)
  return _internal_field99();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field99(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000004u;
 _impl_.field99_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field99)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field99() {
  std::string* _s = _internal_mutable_field99();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field99)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field99() const {
  return _impl_.field99_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field99(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000004u;
  _impl_.field99_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field99() {
  _impl_._has_bits_[3] |= 0x00000004u;
  return _impl_.field99_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field99() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field99)
  if (!_internal_has_field99()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000004u;
  auto* p = _impl_.field99_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field99_.IsDefault()) {
    _impl_.field99_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field99(std::string* field99) {
  if (field99 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000004u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000004u;
  }
  _impl_.field99_.SetAllocated(field99, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field99_.IsDefault()) {
    _impl_.field99_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field99)
}

// optional string field100 = 100;
inline bool TestRequiredFieldsBitmap::_internal_has_field100() const {
  bool value = (_impl_._has_bits_[3] & 0x00000008u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field100() const {
  return _internal_has_field100();
}
inline void TestRequiredFieldsBitmap::clear_field100() {
  _impl_.field100_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000008u;
}
inline const std::string& TestRequiredFieldsBitmap::field100() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field100)
  return _internal_field100();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field100(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000008u;
 _impl_.field100_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field100)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field100() {
  std::string* _s = _internal_mutable_field100();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field100)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field100() const {
  return _impl_.field100_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field100(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000008u;
  _impl_.field100_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field100() {
  _impl_._has_bits_[3] |= 0x00000008u;
  return _impl_.field100_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field100() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field100)
  if (!_internal_has_field100()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000008u;
  auto* p = _impl_.field100_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field100_.IsDefault()) {
    _impl_.field100_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field100(std::string* field100) {
  if (field100 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000008u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000008u;
  }
  _impl_.field100_.SetAllocated(field100, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field100_.IsDefault()) {
    _impl_.field100_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field100)
}

// optional string field101 = 101;
inline bool TestRequiredFieldsBitmap::_internal_has_field101() const {
  bool value = (_impl_._has_bits_[3] & 0x00000010u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field101() const {
  return _internal_has_field101();
}
inline void TestRequiredFieldsBitmap::clear_field101() {
  _impl_.field101_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000010u;
}
inline const std::string& TestRequiredFieldsBitmap::field101() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field101)
  return _internal_field101();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field101(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000010u;
 _impl_.field101_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field101)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field101() {
  std::string* _s = _internal_mutable_field101();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field101)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field101() const {
  return _impl_.field101_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field101(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000010u;
  _impl_.field101_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field101() {
  _impl_._has_bits_[3] |= 0x00000010u;
  return _impl_.field101_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field101() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field101)
  if (!_internal_has_field101()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000010u;
  auto* p = _impl_.field101_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field101_.IsDefault()) {
    _impl_.field101_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field101(std::string* field101) {
  if (field101 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000010u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000010u;
  }
  _impl_.field101_.SetAllocated(field101, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field101_.IsDefault()) {
    _impl_.field101_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field101)
}

// optional string field102 = 102;
inline bool TestRequiredFieldsBitmap::_internal_has_field102() const {
  bool value = (_impl_._has_bits_[3] & 0x00000020u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field102() const {
  return _internal_has_field102();
}
inline void TestRequiredFieldsBitmap::clear_field102() {
  _impl_.field102_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000020u;
}
inline const std::string& TestRequiredFieldsBitmap::field102() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field102)
  return _internal_field102();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field102(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000020u;
 _impl_.field102_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field102)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field102() {
  std::string* _s = _internal_mutable_field102();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field102)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field102() const {
  return _impl_.field102_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field102(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000020u;
  _impl_.field102_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field102() {
  _impl_._has_bits_[3] |= 0x00000020u;
  return _impl_.field102_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field102() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field102)
  if (!_internal_has_field102()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000020u;
  auto* p = _impl_.field102_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field102_.IsDefault()) {
    _impl_.field102_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field102(std::string* field102) {
  if (field102 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000020u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000020u;
  }
  _impl_.field102_.SetAllocated(field102, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field102_.IsDefault()) {
    _impl_.field102_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field102)
}

// optional string field103 = 103;
inline bool TestRequiredFieldsBitmap::_internal_has_field103() const {
  bool value = (_impl_._has_bits_[3] & 0x00000040u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field103() const {
  return _internal_has_field103();
}
inline void TestRequiredFieldsBitmap::clear_field103() {
  _impl_.field103_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000040u;
}
inline const std::string& TestRequiredFieldsBitmap::field103() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field103)
  return _internal_field103();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field103(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000040u;
 _impl_.field103_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field103)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field103() {
  std::string* _s = _internal_mutable_field103();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field103)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field103() const {
  return _impl_.field103_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field103(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000040u;
  _impl_.field103_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field103() {
  _impl_._has_bits_[3] |= 0x00000040u;
  return _impl_.field103_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field103() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field103)
  if (!_internal_has_field103()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000040u;
  auto* p = _impl_.field103_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field103_.IsDefault()) {
    _impl_.field103_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field103(std::string* field103) {
  if (field103 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000040u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000040u;
  }
  _impl_.field103_.SetAllocated(field103, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field103_.IsDefault()) {
    _impl_.field103_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field103)
}

// optional string field104 = 104;
inline bool TestRequiredFieldsBitmap::_internal_has_field104() const {
  bool value = (_impl_._has_bits_[3] & 0x00000080u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field104() const {
  return _internal_has_field104();
}
inline void TestRequiredFieldsBitmap::clear_field104() {
  _impl_.field104_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000080u;
}
inline const std::string& TestRequiredFieldsBitmap::field104() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field104)
  return _internal_field104();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field104(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000080u;
 _impl_.field104_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field104)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field104() {
  std::string* _s = _internal_mutable_field104();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field104)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field104() const {
  return _impl_.field104_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field104(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000080u;
  _impl_.field104_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field104() {
  _impl_._has_bits_[3] |= 0x00000080u;
  return _impl_.field104_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field104() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field104)
  if (!_internal_has_field104()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000080u;
  auto* p = _impl_.field104_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field104_.IsDefault()) {
    _impl_.field104_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field104(std::string* field104) {
  if (field104 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000080u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000080u;
  }
  _impl_.field104_.SetAllocated(field104, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field104_.IsDefault()) {
    _impl_.field104_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field104)
}

// optional string field105 = 105;
inline bool TestRequiredFieldsBitmap::_internal_has_field105() const {
  bool value = (_impl_._has_bits_[3] & 0x00000100u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field105() const {
  return _internal_has_field105();
}
inline void TestRequiredFieldsBitmap::clear_field105() {
  _impl_.field105_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000100u;
}
inline const std::string& TestRequiredFieldsBitmap::field105() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field105)
  return _internal_field105();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field105(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000100u;
 _impl_.field105_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field105)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field105() {
  std::string* _s = _internal_mutable_field105();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field105)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field105() const {
  return _impl_.field105_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field105(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000100u;
  _impl_.field105_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field105() {
  _impl_._has_bits_[3] |= 0x00000100u;
  return _impl_.field105_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field105() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field105)
  if (!_internal_has_field105()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000100u;
  auto* p = _impl_.field105_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field105_.IsDefault()) {
    _impl_.field105_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field105(std::string* field105) {
  if (field105 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000100u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000100u;
  }
  _impl_.field105_.SetAllocated(field105, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field105_.IsDefault()) {
    _impl_.field105_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field105)
}

// optional string field106 = 106;
inline bool TestRequiredFieldsBitmap::_internal_has_field106() const {
  bool value = (_impl_._has_bits_[3] & 0x00000200u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field106() const {
  return _internal_has_field106();
}
inline void TestRequiredFieldsBitmap::clear_field106() {
  _impl_.field106_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000200u;
}
inline const std::string& TestRequiredFieldsBitmap::field106() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field106)
  return _internal_field106();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field106(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000200u;
 _impl_.field106_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field106)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field106() {
  std::string* _s = _internal_mutable_field106();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field106)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field106() const {
  return _impl_.field106_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field106(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000200u;
  _impl_.field106_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field106() {
  _impl_._has_bits_[3] |= 0x00000200u;
  return _impl_.field106_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field106() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field106)
  if (!_internal_has_field106()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000200u;
  auto* p = _impl_.field106_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field106_.IsDefault()) {
    _impl_.field106_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field106(std::string* field106) {
  if (field106 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000200u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000200u;
  }
  _impl_.field106_.SetAllocated(field106, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field106_.IsDefault()) {
    _impl_.field106_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field106)
}

// optional string field107 = 107;
inline bool TestRequiredFieldsBitmap::_internal_has_field107() const {
  bool value = (_impl_._has_bits_[3] & 0x00000400u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field107() const {
  return _internal_has_field107();
}
inline void TestRequiredFieldsBitmap::clear_field107() {
  _impl_.field107_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000400u;
}
inline const std::string& TestRequiredFieldsBitmap::field107() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field107)
  return _internal_field107();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field107(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000400u;
 _impl_.field107_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field107)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field107() {
  std::string* _s = _internal_mutable_field107();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field107)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field107() const {
  return _impl_.field107_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field107(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000400u;
  _impl_.field107_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field107() {
  _impl_._has_bits_[3] |= 0x00000400u;
  return _impl_.field107_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field107() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field107)
  if (!_internal_has_field107()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000400u;
  auto* p = _impl_.field107_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field107_.IsDefault()) {
    _impl_.field107_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field107(std::string* field107) {
  if (field107 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000400u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000400u;
  }
  _impl_.field107_.SetAllocated(field107, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field107_.IsDefault()) {
    _impl_.field107_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field107)
}

// optional string field108 = 108;
inline bool TestRequiredFieldsBitmap::_internal_has_field108() const {
  bool value = (_impl_._has_bits_[3] & 0x00000800u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field108() const {
  return _internal_has_field108();
}
inline void TestRequiredFieldsBitmap::clear_field108() {
  _impl_.field108_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00000800u;
}
inline const std::string& TestRequiredFieldsBitmap::field108() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field108)
  return _internal_field108();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field108(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00000800u;
 _impl_.field108_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field108)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field108() {
  std::string* _s = _internal_mutable_field108();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field108)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field108() const {
  return _impl_.field108_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field108(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00000800u;
  _impl_.field108_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field108() {
  _impl_._has_bits_[3] |= 0x00000800u;
  return _impl_.field108_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field108() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field108)
  if (!_internal_has_field108()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00000800u;
  auto* p = _impl_.field108_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field108_.IsDefault()) {
    _impl_.field108_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field108(std::string* field108) {
  if (field108 != nullptr) {
    _impl_._has_bits_[3] |= 0x00000800u;
  } else {
    _impl_._has_bits_[3] &= ~0x00000800u;
  }
  _impl_.field108_.SetAllocated(field108, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field108_.IsDefault()) {
    _impl_.field108_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field108)
}

// optional string field109 = 109;
inline bool TestRequiredFieldsBitmap::_internal_has_field109() const {
  bool value = (_impl_._has_bits_[3] & 0x00001000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field109() const {
  return _internal_has_field109();
}
inline void TestRequiredFieldsBitmap::clear_field109() {
  _impl_.field109_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00001000u;
}
inline const std::string& TestRequiredFieldsBitmap::field109() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field109)
  return _internal_field109();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field109(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00001000u;
 _impl_.field109_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field109)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field109() {
  std::string* _s = _internal_mutable_field109();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field109)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field109() const {
  return _impl_.field109_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field109(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00001000u;
  _impl_.field109_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field109() {
  _impl_._has_bits_[3] |= 0x00001000u;
  return _impl_.field109_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field109() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field109)
  if (!_internal_has_field109()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00001000u;
  auto* p = _impl_.field109_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field109_.IsDefault()) {
    _impl_.field109_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field109(std::string* field109) {
  if (field109 != nullptr) {
    _impl_._has_bits_[3] |= 0x00001000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00001000u;
  }
  _impl_.field109_.SetAllocated(field109, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field109_.IsDefault()) {
    _impl_.field109_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field109)
}

// optional string field110 = 110;
inline bool TestRequiredFieldsBitmap::_internal_has_field110() const {
  bool value = (_impl_._has_bits_[3] & 0x00002000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field110() const {
  return _internal_has_field110();
}
inline void TestRequiredFieldsBitmap::clear_field110() {
  _impl_.field110_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00002000u;
}
inline const std::string& TestRequiredFieldsBitmap::field110() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field110)
  return _internal_field110();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field110(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00002000u;
 _impl_.field110_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field110)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field110() {
  std::string* _s = _internal_mutable_field110();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field110)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field110() const {
  return _impl_.field110_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field110(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00002000u;
  _impl_.field110_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field110() {
  _impl_._has_bits_[3] |= 0x00002000u;
  return _impl_.field110_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field110() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field110)
  if (!_internal_has_field110()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00002000u;
  auto* p = _impl_.field110_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field110_.IsDefault()) {
    _impl_.field110_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field110(std::string* field110) {
  if (field110 != nullptr) {
    _impl_._has_bits_[3] |= 0x00002000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00002000u;
  }
  _impl_.field110_.SetAllocated(field110, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field110_.IsDefault()) {
    _impl_.field110_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field110)
}

// optional string field111 = 111;
inline bool TestRequiredFieldsBitmap::_internal_has_field111() const {
  bool value = (_impl_._has_bits_[3] & 0x00004000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field111() const {
  return _internal_has_field111();
}
inline void TestRequiredFieldsBitmap::clear_field111() {
  _impl_.field111_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00004000u;
}
inline const std::string& TestRequiredFieldsBitmap::field111() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field111)
  return _internal_field111();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field111(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00004000u;
 _impl_.field111_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field111)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field111() {
  std::string* _s = _internal_mutable_field111();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field111)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field111() const {
  return _impl_.field111_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field111(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00004000u;
  _impl_.field111_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field111() {
  _impl_._has_bits_[3] |= 0x00004000u;
  return _impl_.field111_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field111() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field111)
  if (!_internal_has_field111()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00004000u;
  auto* p = _impl_.field111_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field111_.IsDefault()) {
    _impl_.field111_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field111(std::string* field111) {
  if (field111 != nullptr) {
    _impl_._has_bits_[3] |= 0x00004000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00004000u;
  }
  _impl_.field111_.SetAllocated(field111, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field111_.IsDefault()) {
    _impl_.field111_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field111)
}

// optional string field112 = 112;
inline bool TestRequiredFieldsBitmap::_internal_has_field112() const {
  bool value = (_impl_._has_bits_[3] & 0x00008000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field112() const {
  return _internal_has_field112();
}
inline void TestRequiredFieldsBitmap::clear_field112() {
  _impl_.field112_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00008000u;
}
inline const std::string& TestRequiredFieldsBitmap::field112() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field112)
  return _internal_field112();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field112(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00008000u;
 _impl_.field112_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field112)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field112() {
  std::string* _s = _internal_mutable_field112();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field112)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field112() const {
  return _impl_.field112_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field112(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00008000u;
  _impl_.field112_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field112() {
  _impl_._has_bits_[3] |= 0x00008000u;
  return _impl_.field112_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field112() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field112)
  if (!_internal_has_field112()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00008000u;
  auto* p = _impl_.field112_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field112_.IsDefault()) {
    _impl_.field112_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field112(std::string* field112) {
  if (field112 != nullptr) {
    _impl_._has_bits_[3] |= 0x00008000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00008000u;
  }
  _impl_.field112_.SetAllocated(field112, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field112_.IsDefault()) {
    _impl_.field112_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field112)
}

// optional string field113 = 113;
inline bool TestRequiredFieldsBitmap::_internal_has_field113() const {
  bool value = (_impl_._has_bits_[3] & 0x00010000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field113() const {
  return _internal_has_field113();
}
inline void TestRequiredFieldsBitmap::clear_field113() {
  _impl_.field113_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00010000u;
}
inline const std::string& TestRequiredFieldsBitmap::field113() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field113)
  return _internal_field113();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field113(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00010000u;
 _impl_.field113_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field113)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field113() {
  std::string* _s = _internal_mutable_field113();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field113)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field113() const {
  return _impl_.field113_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field113(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00010000u;
  _impl_.field113_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field113() {
  _impl_._has_bits_[3] |= 0x00010000u;
  return _impl_.field113_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field113() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field113)
  if (!_internal_has_field113()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00010000u;
  auto* p = _impl_.field113_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field113_.IsDefault()) {
    _impl_.field113_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field113(std::string* field113) {
  if (field113 != nullptr) {
    _impl_._has_bits_[3] |= 0x00010000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00010000u;
  }
  _impl_.field113_.SetAllocated(field113, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field113_.IsDefault()) {
    _impl_.field113_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field113)
}

// optional string field114 = 114;
inline bool TestRequiredFieldsBitmap::_internal_has_field114() const {
  bool value = (_impl_._has_bits_[3] & 0x00020000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field114() const {
  return _internal_has_field114();
}
inline void TestRequiredFieldsBitmap::clear_field114() {
  _impl_.field114_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00020000u;
}
inline const std::string& TestRequiredFieldsBitmap::field114() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field114)
  return _internal_field114();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field114(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00020000u;
 _impl_.field114_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field114)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field114() {
  std::string* _s = _internal_mutable_field114();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field114)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field114() const {
  return _impl_.field114_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field114(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00020000u;
  _impl_.field114_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field114() {
  _impl_._has_bits_[3] |= 0x00020000u;
  return _impl_.field114_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field114() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field114)
  if (!_internal_has_field114()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00020000u;
  auto* p = _impl_.field114_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field114_.IsDefault()) {
    _impl_.field114_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field114(std::string* field114) {
  if (field114 != nullptr) {
    _impl_._has_bits_[3] |= 0x00020000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00020000u;
  }
  _impl_.field114_.SetAllocated(field114, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field114_.IsDefault()) {
    _impl_.field114_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field114)
}

// optional string field115 = 115;
inline bool TestRequiredFieldsBitmap::_internal_has_field115() const {
  bool value = (_impl_._has_bits_[3] & 0x00040000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field115() const {
  return _internal_has_field115();
}
inline void TestRequiredFieldsBitmap::clear_field115() {
  _impl_.field115_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00040000u;
}
inline const std::string& TestRequiredFieldsBitmap::field115() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field115)
  return _internal_field115();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field115(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00040000u;
 _impl_.field115_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field115)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field115() {
  std::string* _s = _internal_mutable_field115();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field115)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field115() const {
  return _impl_.field115_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field115(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00040000u;
  _impl_.field115_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field115() {
  _impl_._has_bits_[3] |= 0x00040000u;
  return _impl_.field115_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field115() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field115)
  if (!_internal_has_field115()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00040000u;
  auto* p = _impl_.field115_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field115_.IsDefault()) {
    _impl_.field115_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field115(std::string* field115) {
  if (field115 != nullptr) {
    _impl_._has_bits_[3] |= 0x00040000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00040000u;
  }
  _impl_.field115_.SetAllocated(field115, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field115_.IsDefault()) {
    _impl_.field115_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field115)
}

// optional string field116 = 116;
inline bool TestRequiredFieldsBitmap::_internal_has_field116() const {
  bool value = (_impl_._has_bits_[3] & 0x00080000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field116() const {
  return _internal_has_field116();
}
inline void TestRequiredFieldsBitmap::clear_field116() {
  _impl_.field116_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00080000u;
}
inline const std::string& TestRequiredFieldsBitmap::field116() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field116)
  return _internal_field116();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field116(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00080000u;
 _impl_.field116_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field116)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field116() {
  std::string* _s = _internal_mutable_field116();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field116)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field116() const {
  return _impl_.field116_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field116(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00080000u;
  _impl_.field116_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field116() {
  _impl_._has_bits_[3] |= 0x00080000u;
  return _impl_.field116_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field116() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field116)
  if (!_internal_has_field116()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00080000u;
  auto* p = _impl_.field116_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field116_.IsDefault()) {
    _impl_.field116_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field116(std::string* field116) {
  if (field116 != nullptr) {
    _impl_._has_bits_[3] |= 0x00080000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00080000u;
  }
  _impl_.field116_.SetAllocated(field116, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field116_.IsDefault()) {
    _impl_.field116_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field116)
}

// optional string field117 = 117;
inline bool TestRequiredFieldsBitmap::_internal_has_field117() const {
  bool value = (_impl_._has_bits_[3] & 0x00100000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field117() const {
  return _internal_has_field117();
}
inline void TestRequiredFieldsBitmap::clear_field117() {
  _impl_.field117_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00100000u;
}
inline const std::string& TestRequiredFieldsBitmap::field117() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field117)
  return _internal_field117();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field117(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00100000u;
 _impl_.field117_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field117)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field117() {
  std::string* _s = _internal_mutable_field117();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field117)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field117() const {
  return _impl_.field117_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field117(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00100000u;
  _impl_.field117_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field117() {
  _impl_._has_bits_[3] |= 0x00100000u;
  return _impl_.field117_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field117() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field117)
  if (!_internal_has_field117()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00100000u;
  auto* p = _impl_.field117_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field117_.IsDefault()) {
    _impl_.field117_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field117(std::string* field117) {
  if (field117 != nullptr) {
    _impl_._has_bits_[3] |= 0x00100000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00100000u;
  }
  _impl_.field117_.SetAllocated(field117, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field117_.IsDefault()) {
    _impl_.field117_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field117)
}

// optional string field118 = 118;
inline bool TestRequiredFieldsBitmap::_internal_has_field118() const {
  bool value = (_impl_._has_bits_[3] & 0x00200000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field118() const {
  return _internal_has_field118();
}
inline void TestRequiredFieldsBitmap::clear_field118() {
  _impl_.field118_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00200000u;
}
inline const std::string& TestRequiredFieldsBitmap::field118() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field118)
  return _internal_field118();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field118(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00200000u;
 _impl_.field118_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field118)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field118() {
  std::string* _s = _internal_mutable_field118();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field118)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field118() const {
  return _impl_.field118_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field118(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00200000u;
  _impl_.field118_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field118() {
  _impl_._has_bits_[3] |= 0x00200000u;
  return _impl_.field118_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field118() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field118)
  if (!_internal_has_field118()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00200000u;
  auto* p = _impl_.field118_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field118_.IsDefault()) {
    _impl_.field118_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field118(std::string* field118) {
  if (field118 != nullptr) {
    _impl_._has_bits_[3] |= 0x00200000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00200000u;
  }
  _impl_.field118_.SetAllocated(field118, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field118_.IsDefault()) {
    _impl_.field118_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field118)
}

// optional string field119 = 119;
inline bool TestRequiredFieldsBitmap::_internal_has_field119() const {
  bool value = (_impl_._has_bits_[3] & 0x00400000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field119() const {
  return _internal_has_field119();
}
inline void TestRequiredFieldsBitmap::clear_field119() {
  _impl_.field119_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00400000u;
}
inline const std::string& TestRequiredFieldsBitmap::field119() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field119)
  return _internal_field119();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field119(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00400000u;
 _impl_.field119_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field119)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field119() {
  std::string* _s = _internal_mutable_field119();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field119)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field119() const {
  return _impl_.field119_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field119(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00400000u;
  _impl_.field119_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field119() {
  _impl_._has_bits_[3] |= 0x00400000u;
  return _impl_.field119_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field119() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field119)
  if (!_internal_has_field119()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00400000u;
  auto* p = _impl_.field119_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field119_.IsDefault()) {
    _impl_.field119_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field119(std::string* field119) {
  if (field119 != nullptr) {
    _impl_._has_bits_[3] |= 0x00400000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00400000u;
  }
  _impl_.field119_.SetAllocated(field119, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field119_.IsDefault()) {
    _impl_.field119_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field119)
}

// optional string field120 = 120;
inline bool TestRequiredFieldsBitmap::_internal_has_field120() const {
  bool value = (_impl_._has_bits_[3] & 0x00800000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field120() const {
  return _internal_has_field120();
}
inline void TestRequiredFieldsBitmap::clear_field120() {
  _impl_.field120_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x00800000u;
}
inline const std::string& TestRequiredFieldsBitmap::field120() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field120)
  return _internal_field120();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field120(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x00800000u;
 _impl_.field120_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field120)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field120() {
  std::string* _s = _internal_mutable_field120();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field120)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field120() const {
  return _impl_.field120_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field120(const std::string& value) {
  _impl_._has_bits_[3] |= 0x00800000u;
  _impl_.field120_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field120() {
  _impl_._has_bits_[3] |= 0x00800000u;
  return _impl_.field120_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field120() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field120)
  if (!_internal_has_field120()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x00800000u;
  auto* p = _impl_.field120_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field120_.IsDefault()) {
    _impl_.field120_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field120(std::string* field120) {
  if (field120 != nullptr) {
    _impl_._has_bits_[3] |= 0x00800000u;
  } else {
    _impl_._has_bits_[3] &= ~0x00800000u;
  }
  _impl_.field120_.SetAllocated(field120, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field120_.IsDefault()) {
    _impl_.field120_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field120)
}

// optional string field121 = 121;
inline bool TestRequiredFieldsBitmap::_internal_has_field121() const {
  bool value = (_impl_._has_bits_[3] & 0x01000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field121() const {
  return _internal_has_field121();
}
inline void TestRequiredFieldsBitmap::clear_field121() {
  _impl_.field121_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x01000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field121() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field121)
  return _internal_field121();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field121(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x01000000u;
 _impl_.field121_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field121)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field121() {
  std::string* _s = _internal_mutable_field121();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field121)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field121() const {
  return _impl_.field121_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field121(const std::string& value) {
  _impl_._has_bits_[3] |= 0x01000000u;
  _impl_.field121_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field121() {
  _impl_._has_bits_[3] |= 0x01000000u;
  return _impl_.field121_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field121() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field121)
  if (!_internal_has_field121()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x01000000u;
  auto* p = _impl_.field121_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field121_.IsDefault()) {
    _impl_.field121_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field121(std::string* field121) {
  if (field121 != nullptr) {
    _impl_._has_bits_[3] |= 0x01000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x01000000u;
  }
  _impl_.field121_.SetAllocated(field121, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field121_.IsDefault()) {
    _impl_.field121_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field121)
}

// optional string field122 = 122;
inline bool TestRequiredFieldsBitmap::_internal_has_field122() const {
  bool value = (_impl_._has_bits_[3] & 0x02000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field122() const {
  return _internal_has_field122();
}
inline void TestRequiredFieldsBitmap::clear_field122() {
  _impl_.field122_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x02000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field122() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field122)
  return _internal_field122();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field122(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x02000000u;
 _impl_.field122_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field122)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field122() {
  std::string* _s = _internal_mutable_field122();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field122)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field122() const {
  return _impl_.field122_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field122(const std::string& value) {
  _impl_._has_bits_[3] |= 0x02000000u;
  _impl_.field122_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field122() {
  _impl_._has_bits_[3] |= 0x02000000u;
  return _impl_.field122_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field122() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field122)
  if (!_internal_has_field122()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x02000000u;
  auto* p = _impl_.field122_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field122_.IsDefault()) {
    _impl_.field122_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field122(std::string* field122) {
  if (field122 != nullptr) {
    _impl_._has_bits_[3] |= 0x02000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x02000000u;
  }
  _impl_.field122_.SetAllocated(field122, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field122_.IsDefault()) {
    _impl_.field122_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field122)
}

// optional string field123 = 123;
inline bool TestRequiredFieldsBitmap::_internal_has_field123() const {
  bool value = (_impl_._has_bits_[3] & 0x04000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field123() const {
  return _internal_has_field123();
}
inline void TestRequiredFieldsBitmap::clear_field123() {
  _impl_.field123_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x04000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field123() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field123)
  return _internal_field123();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field123(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x04000000u;
 _impl_.field123_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field123)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field123() {
  std::string* _s = _internal_mutable_field123();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field123)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field123() const {
  return _impl_.field123_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field123(const std::string& value) {
  _impl_._has_bits_[3] |= 0x04000000u;
  _impl_.field123_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field123() {
  _impl_._has_bits_[3] |= 0x04000000u;
  return _impl_.field123_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field123() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field123)
  if (!_internal_has_field123()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x04000000u;
  auto* p = _impl_.field123_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field123_.IsDefault()) {
    _impl_.field123_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field123(std::string* field123) {
  if (field123 != nullptr) {
    _impl_._has_bits_[3] |= 0x04000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x04000000u;
  }
  _impl_.field123_.SetAllocated(field123, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field123_.IsDefault()) {
    _impl_.field123_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field123)
}

// optional string field124 = 124;
inline bool TestRequiredFieldsBitmap::_internal_has_field124() const {
  bool value = (_impl_._has_bits_[3] & 0x08000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field124() const {
  return _internal_has_field124();
}
inline void TestRequiredFieldsBitmap::clear_field124() {
  _impl_.field124_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x08000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field124() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field124)
  return _internal_field124();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field124(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x08000000u;
 _impl_.field124_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field124)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field124() {
  std::string* _s = _internal_mutable_field124();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field124)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field124() const {
  return _impl_.field124_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field124(const std::string& value) {
  _impl_._has_bits_[3] |= 0x08000000u;
  _impl_.field124_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field124() {
  _impl_._has_bits_[3] |= 0x08000000u;
  return _impl_.field124_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field124() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field124)
  if (!_internal_has_field124()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x08000000u;
  auto* p = _impl_.field124_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field124_.IsDefault()) {
    _impl_.field124_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field124(std::string* field124) {
  if (field124 != nullptr) {
    _impl_._has_bits_[3] |= 0x08000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x08000000u;
  }
  _impl_.field124_.SetAllocated(field124, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field124_.IsDefault()) {
    _impl_.field124_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field124)
}

// optional string field125 = 125;
inline bool TestRequiredFieldsBitmap::_internal_has_field125() const {
  bool value = (_impl_._has_bits_[3] & 0x10000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field125() const {
  return _internal_has_field125();
}
inline void TestRequiredFieldsBitmap::clear_field125() {
  _impl_.field125_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x10000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field125() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field125)
  return _internal_field125();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field125(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x10000000u;
 _impl_.field125_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field125)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field125() {
  std::string* _s = _internal_mutable_field125();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field125)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field125() const {
  return _impl_.field125_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field125(const std::string& value) {
  _impl_._has_bits_[3] |= 0x10000000u;
  _impl_.field125_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field125() {
  _impl_._has_bits_[3] |= 0x10000000u;
  return _impl_.field125_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field125() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field125)
  if (!_internal_has_field125()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x10000000u;
  auto* p = _impl_.field125_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field125_.IsDefault()) {
    _impl_.field125_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field125(std::string* field125) {
  if (field125 != nullptr) {
    _impl_._has_bits_[3] |= 0x10000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x10000000u;
  }
  _impl_.field125_.SetAllocated(field125, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field125_.IsDefault()) {
    _impl_.field125_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field125)
}

// optional string field126 = 126;
inline bool TestRequiredFieldsBitmap::_internal_has_field126() const {
  bool value = (_impl_._has_bits_[3] & 0x20000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field126() const {
  return _internal_has_field126();
}
inline void TestRequiredFieldsBitmap::clear_field126() {
  _impl_.field126_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x20000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field126() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field126)
  return _internal_field126();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field126(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x20000000u;
 _impl_.field126_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field126)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field126() {
  std::string* _s = _internal_mutable_field126();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field126)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field126() const {
  return _impl_.field126_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field126(const std::string& value) {
  _impl_._has_bits_[3] |= 0x20000000u;
  _impl_.field126_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field126() {
  _impl_._has_bits_[3] |= 0x20000000u;
  return _impl_.field126_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field126() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field126)
  if (!_internal_has_field126()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x20000000u;
  auto* p = _impl_.field126_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field126_.IsDefault()) {
    _impl_.field126_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field126(std::string* field126) {
  if (field126 != nullptr) {
    _impl_._has_bits_[3] |= 0x20000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x20000000u;
  }
  _impl_.field126_.SetAllocated(field126, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field126_.IsDefault()) {
    _impl_.field126_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field126)
}

// optional string field127 = 127;
inline bool TestRequiredFieldsBitmap::_internal_has_field127() const {
  bool value = (_impl_._has_bits_[3] & 0x40000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field127() const {
  return _internal_has_field127();
}
inline void TestRequiredFieldsBitmap::clear_field127() {
  _impl_.field127_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x40000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field127() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field127)
  return _internal_field127();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field127(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x40000000u;
 _impl_.field127_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field127)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field127() {
  std::string* _s = _internal_mutable_field127();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field127)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field127() const {
  return _impl_.field127_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field127(const std::string& value) {
  _impl_._has_bits_[3] |= 0x40000000u;
  _impl_.field127_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field127() {
  _impl_._has_bits_[3] |= 0x40000000u;
  return _impl_.field127_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field127() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field127)
  if (!_internal_has_field127()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x40000000u;
  auto* p = _impl_.field127_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field127_.IsDefault()) {
    _impl_.field127_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field127(std::string* field127) {
  if (field127 != nullptr) {
    _impl_._has_bits_[3] |= 0x40000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x40000000u;
  }
  _impl_.field127_.SetAllocated(field127, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field127_.IsDefault()) {
    _impl_.field127_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field127)
}

// optional string field128 = 128;
inline bool TestRequiredFieldsBitmap::_internal_has_field128() const {
  bool value = (_impl_._has_bits_[3] & 0x80000000u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field128() const {
  return _internal_has_field128();
}
inline void TestRequiredFieldsBitmap::clear_field128() {
  _impl_.field128_.ClearToEmpty();
  _impl_._has_bits_[3] &= ~0x80000000u;
}
inline const std::string& TestRequiredFieldsBitmap::field128() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field128)
  return _internal_field128();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field128(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[3] |= 0x80000000u;
 _impl_.field128_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field128)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field128() {
  std::string* _s = _internal_mutable_field128();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field128)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field128() const {
  return _impl_.field128_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field128(const std::string& value) {
  _impl_._has_bits_[3] |= 0x80000000u;
  _impl_.field128_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field128() {
  _impl_._has_bits_[3] |= 0x80000000u;
  return _impl_.field128_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field128() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field128)
  if (!_internal_has_field128()) {
    return nullptr;
  }
  _impl_._has_bits_[3] &= ~0x80000000u;
  auto* p = _impl_.field128_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field128_.IsDefault()) {
    _impl_.field128_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field128(std::string* field128) {
  if (field128 != nullptr) {
    _impl_._has_bits_[3] |= 0x80000000u;
  } else {
    _impl_._has_bits_[3] &= ~0x80000000u;
  }
  _impl_.field128_.SetAllocated(field128, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field128_.IsDefault()) {
    _impl_.field128_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field128)
}

// required string field129 = 129;
inline bool TestRequiredFieldsBitmap::_internal_has_field129() const {
  bool value = (_impl_._has_bits_[4] & 0x00000001u) != 0;
  return value;
}
inline bool TestRequiredFieldsBitmap::has_field129() const {
  return _internal_has_field129();
}
inline void TestRequiredFieldsBitmap::clear_field129() {
  _impl_.field129_.ClearToEmpty();
  _impl_._has_bits_[4] &= ~0x00000001u;
}
inline const std::string& TestRequiredFieldsBitmap::field129() const {
  // @@protoc_insertion_point(field_get:foo.TestRequiredFieldsBitmap.field129)
  return _internal_field129();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestRequiredFieldsBitmap::set_field129(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[4] |= 0x00000001u;
 _impl_.field129_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestRequiredFieldsBitmap.field129)
}
inline std::string* TestRequiredFieldsBitmap::mutable_field129() {
  std::string* _s = _internal_mutable_field129();
  // @@protoc_insertion_point(field_mutable:foo.TestRequiredFieldsBitmap.field129)
  return _s;
}
inline const std::string& TestRequiredFieldsBitmap::_internal_field129() const {
  return _impl_.field129_.Get();
}
inline void TestRequiredFieldsBitmap::_internal_set_field129(const std::string& value) {
  _impl_._has_bits_[4] |= 0x00000001u;
  _impl_.field129_.Set(value, GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::_internal_mutable_field129() {
  _impl_._has_bits_[4] |= 0x00000001u;
  return _impl_.field129_.Mutable(GetArenaForAllocation());
}
inline std::string* TestRequiredFieldsBitmap::release_field129() {
  // @@protoc_insertion_point(field_release:foo.TestRequiredFieldsBitmap.field129)
  if (!_internal_has_field129()) {
    return nullptr;
  }
  _impl_._has_bits_[4] &= ~0x00000001u;
  auto* p = _impl_.field129_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field129_.IsDefault()) {
    _impl_.field129_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestRequiredFieldsBitmap::set_allocated_field129(std::string* field129) {
  if (field129 != nullptr) {
    _impl_._has_bits_[4] |= 0x00000001u;
  } else {
    _impl_._has_bits_[4] &= ~0x00000001u;
  }
  _impl_.field129_.SetAllocated(field129, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field129_.IsDefault()) {
    _impl_.field129_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestRequiredFieldsBitmap.field129)
}

// -------------------------------------------------------------------

// TestFieldFlags

// optional int32 no_flags1 = 1;
inline bool TestFieldFlags::_internal_has_no_flags1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestFieldFlags::has_no_flags1() const {
  return _internal_has_no_flags1();
}
inline void TestFieldFlags::clear_no_flags1() {
  _impl_.no_flags1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TestFieldFlags::_internal_no_flags1() const {
  return _impl_.no_flags1_;
}
inline int32_t TestFieldFlags::no_flags1() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.no_flags1)
  return _internal_no_flags1();
}
inline void TestFieldFlags::_internal_set_no_flags1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.no_flags1_ = value;
}
inline void TestFieldFlags::set_no_flags1(int32_t value) {
  _internal_set_no_flags1(value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.no_flags1)
}

// required int32 no_flags2 = 2;
inline bool TestFieldFlags::_internal_has_no_flags2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestFieldFlags::has_no_flags2() const {
  return _internal_has_no_flags2();
}
inline void TestFieldFlags::clear_no_flags2() {
  _impl_.no_flags2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TestFieldFlags::_internal_no_flags2() const {
  return _impl_.no_flags2_;
}
inline int32_t TestFieldFlags::no_flags2() const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.no_flags2)
  return _internal_no_flags2();
}
inline void TestFieldFlags::_internal_set_no_flags2(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.no_flags2_ = value;
}
inline void TestFieldFlags::set_no_flags2(int32_t value) {
  _internal_set_no_flags2(value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.no_flags2)
}

// repeated int32 no_flags3 = 3;
inline int TestFieldFlags::_internal_no_flags3_size() const {
  return _impl_.no_flags3_.size();
}
inline int TestFieldFlags::no_flags3_size() const {
  return _internal_no_flags3_size();
}
inline void TestFieldFlags::clear_no_flags3() {
  _impl_.no_flags3_.Clear();
}
inline int32_t TestFieldFlags::_internal_no_flags3(int index) const {
  return _impl_.no_flags3_.Get(index);
}
inline int32_t TestFieldFlags::no_flags3(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.no_flags3)
  return _internal_no_flags3(index);
}
inline void TestFieldFlags::set_no_flags3(int index, int32_t value) {
  _impl_.no_flags3_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.no_flags3)
}
inline void TestFieldFlags::_internal_add_no_flags3(int32_t value) {
  _impl_.no_flags3_.Add(value);
}
inline void TestFieldFlags::add_no_flags3(int32_t value) {
  _internal_add_no_flags3(value);
  // @@protoc_insertion_point(field_add:foo.TestFieldFlags.no_flags3)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::_internal_no_flags3() const {
  return _impl_.no_flags3_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::no_flags3() const {
  // @@protoc_insertion_point(field_list:foo.TestFieldFlags.no_flags3)
  return _internal_no_flags3();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::_internal_mutable_no_flags3() {
  return &_impl_.no_flags3_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::mutable_no_flags3() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestFieldFlags.no_flags3)
  return _internal_mutable_no_flags3();
}

// repeated int32 packed = 4 [packed = true];
inline int TestFieldFlags::_internal_packed_size() const {
  return _impl_.packed_.size();
}
inline int TestFieldFlags::packed_size() const {
  return _internal_packed_size();
}
inline void TestFieldFlags::clear_packed() {
  _impl_.packed_.Clear();
}
inline int32_t TestFieldFlags::_internal_packed(int index) const {
  return _impl_.packed_.Get(index);
}
inline int32_t TestFieldFlags::packed(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.packed)
  return _internal_packed(index);
}
inline void TestFieldFlags::set_packed(int index, int32_t value) {
  _impl_.packed_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.packed)
}
inline void TestFieldFlags::_internal_add_packed(int32_t value) {
  _impl_.packed_.Add(value);
}
inline void TestFieldFlags::add_packed(int32_t value) {
  _internal_add_packed(value);
  // @@protoc_insertion_point(field_add:foo.TestFieldFlags.packed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::_internal_packed() const {
  return _impl_.packed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::packed() const {
  // @@protoc_insertion_point(field_list:foo.TestFieldFlags.packed)
  return _internal_packed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::_internal_mutable_packed() {
  return &_impl_.packed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::mutable_packed() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestFieldFlags.packed)
  return _internal_mutable_packed();
}

// repeated int32 packed_deprecated = 5 [packed = true, deprecated = true];
inline int TestFieldFlags::_internal_packed_deprecated_size() const {
  return _impl_.packed_deprecated_.size();
}
inline int TestFieldFlags::packed_deprecated_size() const {
  return _internal_packed_deprecated_size();
}
inline void TestFieldFlags::clear_packed_deprecated() {
  _impl_.packed_deprecated_.Clear();
}
inline int32_t TestFieldFlags::_internal_packed_deprecated(int index) const {
  return _impl_.packed_deprecated_.Get(index);
}
inline int32_t TestFieldFlags::packed_deprecated(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.packed_deprecated)
  return _internal_packed_deprecated(index);
}
inline void TestFieldFlags::set_packed_deprecated(int index, int32_t value) {
  _impl_.packed_deprecated_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.packed_deprecated)
}
inline void TestFieldFlags::_internal_add_packed_deprecated(int32_t value) {
  _impl_.packed_deprecated_.Add(value);
}
inline void TestFieldFlags::add_packed_deprecated(int32_t value) {
  _internal_add_packed_deprecated(value);
  // @@protoc_insertion_point(field_add:foo.TestFieldFlags.packed_deprecated)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::_internal_packed_deprecated() const {
  return _impl_.packed_deprecated_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::packed_deprecated() const {
  // @@protoc_insertion_point(field_list:foo.TestFieldFlags.packed_deprecated)
  return _internal_packed_deprecated();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::_internal_mutable_packed_deprecated() {
  return &_impl_.packed_deprecated_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::mutable_packed_deprecated() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestFieldFlags.packed_deprecated)
  return _internal_mutable_packed_deprecated();
}

// repeated int32 deprecated = 6 [deprecated = true];
inline int TestFieldFlags::_internal_deprecated_size() const {
  return _impl_.deprecated_.size();
}
inline int TestFieldFlags::deprecated_size() const {
  return _internal_deprecated_size();
}
inline void TestFieldFlags::clear_deprecated() {
  _impl_.deprecated_.Clear();
}
inline int32_t TestFieldFlags::_internal_deprecated(int index) const {
  return _impl_.deprecated_.Get(index);
}
inline int32_t TestFieldFlags::deprecated(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestFieldFlags.deprecated)
  return _internal_deprecated(index);
}
inline void TestFieldFlags::set_deprecated(int index, int32_t value) {
  _impl_.deprecated_.Set(index, value);
  // @@protoc_insertion_point(field_set:foo.TestFieldFlags.deprecated)
}
inline void TestFieldFlags::_internal_add_deprecated(int32_t value) {
  _impl_.deprecated_.Add(value);
}
inline void TestFieldFlags::add_deprecated(int32_t value) {
  _internal_add_deprecated(value);
  // @@protoc_insertion_point(field_add:foo.TestFieldFlags.deprecated)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TestFieldFlags::deprecated() const {
  // @@protoc_insertion_point(field_list:foo.TestFieldFlags.deprecated)
  return _internal_deprecated();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::_internal_mutable_deprecated() {
  return &_impl_.deprecated_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TestFieldFlags::mutable_deprecated() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestFieldFlags.deprecated)
  return _internal_mutable_deprecated();
}

// -------------------------------------------------------------------

// TestMessageCheck_SubMessage

// required string str = 1;
inline bool TestMessageCheck_SubMessage::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessageCheck_SubMessage::has_str() const {
  return _internal_has_str();
}
inline void TestMessageCheck_SubMessage::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestMessageCheck_SubMessage::str() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.SubMessage.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessageCheck_SubMessage::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.SubMessage.str)
}
inline std::string* TestMessageCheck_SubMessage::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.SubMessage.str)
  return _s;
}
inline const std::string& TestMessageCheck_SubMessage::_internal_str() const {
  return _impl_.str_.Get();
}
inline void TestMessageCheck_SubMessage::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessageCheck_SubMessage::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessageCheck_SubMessage::release_str() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.SubMessage.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessageCheck_SubMessage::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.SubMessage.str)
}

// -------------------------------------------------------------------

// TestMessageCheck

// required .foo.TestMessageCheck.SubMessage required_msg = 1;
inline bool TestMessageCheck::_internal_has_required_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.required_msg_ != nullptr);
  return value;
}
inline bool TestMessageCheck::has_required_msg() const {
  return _internal_has_required_msg();
}
inline void TestMessageCheck::clear_required_msg() {
  if (_impl_.required_msg_ != nullptr) _impl_.required_msg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::_internal_required_msg() const {
  const ::foo::TestMessageCheck_SubMessage* p = _impl_.required_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::TestMessageCheck_SubMessage&>(
      ::foo::_TestMessageCheck_SubMessage_default_instance_);
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::required_msg() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.required_msg)
  return _internal_required_msg();
}
inline void TestMessageCheck::unsafe_arena_set_allocated_required_msg(
    ::foo::TestMessageCheck_SubMessage* required_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.required_msg_);
  }
  _impl_.required_msg_ = required_msg;
  if (required_msg) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessageCheck.required_msg)
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::release_required_msg() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::foo::TestMessageCheck_SubMessage* temp = _impl_.required_msg_;
  _impl_.required_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::unsafe_arena_release_required_msg() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.required_msg)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::foo::TestMessageCheck_SubMessage* temp = _impl_.required_msg_;
  _impl_.required_msg_ = nullptr;
  return temp;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::_internal_mutable_required_msg() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.required_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::TestMessageCheck_SubMessage>(GetArenaForAllocation());
    _impl_.required_msg_ = p;
  }
  return _impl_.required_msg_;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::mutable_required_msg() {
  ::foo::TestMessageCheck_SubMessage* _msg = _internal_mutable_required_msg();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.required_msg)
  return _msg;
}
inline void TestMessageCheck::set_allocated_required_msg(::foo::TestMessageCheck_SubMessage* required_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.required_msg_;
  }
  if (required_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(required_msg);
    if (message_arena != submessage_arena) {
      required_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, required_msg, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.required_msg_ = required_msg;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.required_msg)
}

// repeated .foo.TestMessageCheck.SubMessage repeated_msg = 2;
inline int TestMessageCheck::_internal_repeated_msg_size() const {
  return _impl_.repeated_msg_.size();
}
inline int TestMessageCheck::repeated_msg_size() const {
  return _internal_repeated_msg_size();
}
inline void TestMessageCheck::clear_repeated_msg() {
  _impl_.repeated_msg_.Clear();
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::mutable_repeated_msg(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.repeated_msg)
  return _impl_.repeated_msg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::TestMessageCheck_SubMessage >*
TestMessageCheck::mutable_repeated_msg() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessageCheck.repeated_msg)
  return &_impl_.repeated_msg_;
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::_internal_repeated_msg(int index) const {
  return _impl_.repeated_msg_.Get(index);
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::repeated_msg(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.repeated_msg)
  return _internal_repeated_msg(index);
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::_internal_add_repeated_msg() {
  return _impl_.repeated_msg_.Add();
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::add_repeated_msg() {
  ::foo::TestMessageCheck_SubMessage* _add = _internal_add_repeated_msg();
  // @@protoc_insertion_point(field_add:foo.TestMessageCheck.repeated_msg)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::foo::TestMessageCheck_SubMessage >&
TestMessageCheck::repeated_msg() const {
  // @@protoc_insertion_point(field_list:foo.TestMessageCheck.repeated_msg)
  return _impl_.repeated_msg_;
}

// optional .foo.TestMessageCheck.SubMessage optional_msg = 3;
inline bool TestMessageCheck::_internal_has_optional_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.optional_msg_ != nullptr);
  return value;
}
inline bool TestMessageCheck::has_optional_msg() const {
  return _internal_has_optional_msg();
}
inline void TestMessageCheck::clear_optional_msg() {
  if (_impl_.optional_msg_ != nullptr) _impl_.optional_msg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::_internal_optional_msg() const {
  const ::foo::TestMessageCheck_SubMessage* p = _impl_.optional_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::TestMessageCheck_SubMessage&>(
      ::foo::_TestMessageCheck_SubMessage_default_instance_);
}
inline const ::foo::TestMessageCheck_SubMessage& TestMessageCheck::optional_msg() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.optional_msg)
  return _internal_optional_msg();
}
inline void TestMessageCheck::unsafe_arena_set_allocated_optional_msg(
    ::foo::TestMessageCheck_SubMessage* optional_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optional_msg_);
  }
  _impl_.optional_msg_ = optional_msg;
  if (optional_msg) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessageCheck.optional_msg)
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::release_optional_msg() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::foo::TestMessageCheck_SubMessage* temp = _impl_.optional_msg_;
  _impl_.optional_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::unsafe_arena_release_optional_msg() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.optional_msg)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::foo::TestMessageCheck_SubMessage* temp = _impl_.optional_msg_;
  _impl_.optional_msg_ = nullptr;
  return temp;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::_internal_mutable_optional_msg() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.optional_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::TestMessageCheck_SubMessage>(GetArenaForAllocation());
    _impl_.optional_msg_ = p;
  }
  return _impl_.optional_msg_;
}
inline ::foo::TestMessageCheck_SubMessage* TestMessageCheck::mutable_optional_msg() {
  ::foo::TestMessageCheck_SubMessage* _msg = _internal_mutable_optional_msg();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.optional_msg)
  return _msg;
}
inline void TestMessageCheck::set_allocated_optional_msg(::foo::TestMessageCheck_SubMessage* optional_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optional_msg_;
  }
  if (optional_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_msg);
    if (message_arena != submessage_arena) {
      optional_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_msg, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.optional_msg_ = optional_msg;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.optional_msg)
}

// required string required_string = 4;
inline bool TestMessageCheck::_internal_has_required_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestMessageCheck::has_required_string() const {
  return _internal_has_required_string();
}
inline void TestMessageCheck::clear_required_string() {
  _impl_.required_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestMessageCheck::required_string() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.required_string)
  return _internal_required_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessageCheck::set_required_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.required_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.required_string)
}
inline std::string* TestMessageCheck::mutable_required_string() {
  std::string* _s = _internal_mutable_required_string();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.required_string)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_required_string() const {
  return _impl_.required_string_.Get();
}
inline void TestMessageCheck::_internal_set_required_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.required_string_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessageCheck::_internal_mutable_required_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.required_string_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessageCheck::release_required_string() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.required_string)
  if (!_internal_has_required_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.required_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_string_.IsDefault()) {
    _impl_.required_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessageCheck::set_allocated_required_string(std::string* required_string) {
  if (required_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.required_string_.SetAllocated(required_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_string_.IsDefault()) {
    _impl_.required_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.required_string)
}

// repeated string repeated_string = 5;
inline int TestMessageCheck::_internal_repeated_string_size() const {
  return _impl_.repeated_string_.size();
}
inline int TestMessageCheck::repeated_string_size() const {
  return _internal_repeated_string_size();
}
inline void TestMessageCheck::clear_repeated_string() {
  _impl_.repeated_string_.Clear();
}
inline std::string* TestMessageCheck::add_repeated_string() {
  std::string* _s = _internal_add_repeated_string();
  // @@protoc_insertion_point(field_add_mutable:foo.TestMessageCheck.repeated_string)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_repeated_string(int index) const {
  return _impl_.repeated_string_.Get(index);
}
inline const std::string& TestMessageCheck::repeated_string(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.repeated_string)
  return _internal_repeated_string(index);
}
inline std::string* TestMessageCheck::mutable_repeated_string(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.repeated_string)
  return _impl_.repeated_string_.Mutable(index);
}
inline void TestMessageCheck::set_repeated_string(int index, const std::string& value) {
  _impl_.repeated_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::set_repeated_string(int index, std::string&& value) {
  _impl_.repeated_string_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::set_repeated_string(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.repeated_string_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::set_repeated_string(int index, const char* value, size_t size) {
  _impl_.repeated_string_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:foo.TestMessageCheck.repeated_string)
}
inline std::string* TestMessageCheck::_internal_add_repeated_string() {
  return _impl_.repeated_string_.Add();
}
inline void TestMessageCheck::add_repeated_string(const std::string& value) {
  _impl_.repeated_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::add_repeated_string(std::string&& value) {
  _impl_.repeated_string_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::add_repeated_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.repeated_string_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:foo.TestMessageCheck.repeated_string)
}
inline void TestMessageCheck::add_repeated_string(const char* value, size_t size) {
  _impl_.repeated_string_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:foo.TestMessageCheck.repeated_string)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestMessageCheck::repeated_string() const {
  // @@protoc_insertion_point(field_list:foo.TestMessageCheck.repeated_string)
  return _impl_.repeated_string_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestMessageCheck::mutable_repeated_string() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessageCheck.repeated_string)
  return &_impl_.repeated_string_;
}

// optional string optional_string = 6;
inline bool TestMessageCheck::_internal_has_optional_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestMessageCheck::has_optional_string() const {
  return _internal_has_optional_string();
}
inline void TestMessageCheck::clear_optional_string() {
  _impl_.optional_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TestMessageCheck::optional_string() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.optional_string)
  return _internal_optional_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessageCheck::set_optional_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.optional_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.optional_string)
}
inline std::string* TestMessageCheck::mutable_optional_string() {
  std::string* _s = _internal_mutable_optional_string();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.optional_string)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_optional_string() const {
  return _impl_.optional_string_.Get();
}
inline void TestMessageCheck::_internal_set_optional_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.optional_string_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessageCheck::_internal_mutable_optional_string() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.optional_string_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessageCheck::release_optional_string() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.optional_string)
  if (!_internal_has_optional_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.optional_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_string_.IsDefault()) {
    _impl_.optional_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessageCheck::set_allocated_optional_string(std::string* optional_string) {
  if (optional_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.optional_string_.SetAllocated(optional_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_string_.IsDefault()) {
    _impl_.optional_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.optional_string)
}

// required bytes required_bytes = 7;
inline bool TestMessageCheck::_internal_has_required_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TestMessageCheck::has_required_bytes() const {
  return _internal_has_required_bytes();
}
inline void TestMessageCheck::clear_required_bytes() {
  _impl_.required_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TestMessageCheck::required_bytes() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.required_bytes)
  return _internal_required_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessageCheck::set_required_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.required_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.required_bytes)
}
inline std::string* TestMessageCheck::mutable_required_bytes() {
  std::string* _s = _internal_mutable_required_bytes();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.required_bytes)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_required_bytes() const {
  return _impl_.required_bytes_.Get();
}
inline void TestMessageCheck::_internal_set_required_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.required_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessageCheck::_internal_mutable_required_bytes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.required_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessageCheck::release_required_bytes() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.required_bytes)
  if (!_internal_has_required_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.required_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_bytes_.IsDefault()) {
    _impl_.required_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessageCheck::set_allocated_required_bytes(std::string* required_bytes) {
  if (required_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.required_bytes_.SetAllocated(required_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.required_bytes_.IsDefault()) {
    _impl_.required_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.required_bytes)
}

// repeated bytes repeated_bytes = 8;
inline int TestMessageCheck::_internal_repeated_bytes_size() const {
  return _impl_.repeated_bytes_.size();
}
inline int TestMessageCheck::repeated_bytes_size() const {
  return _internal_repeated_bytes_size();
}
inline void TestMessageCheck::clear_repeated_bytes() {
  _impl_.repeated_bytes_.Clear();
}
inline std::string* TestMessageCheck::add_repeated_bytes() {
  std::string* _s = _internal_add_repeated_bytes();
  // @@protoc_insertion_point(field_add_mutable:foo.TestMessageCheck.repeated_bytes)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_repeated_bytes(int index) const {
  return _impl_.repeated_bytes_.Get(index);
}
inline const std::string& TestMessageCheck::repeated_bytes(int index) const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.repeated_bytes)
  return _internal_repeated_bytes(index);
}
inline std::string* TestMessageCheck::mutable_repeated_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.repeated_bytes)
  return _impl_.repeated_bytes_.Mutable(index);
}
inline void TestMessageCheck::set_repeated_bytes(int index, const std::string& value) {
  _impl_.repeated_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::set_repeated_bytes(int index, std::string&& value) {
  _impl_.repeated_bytes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::set_repeated_bytes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.repeated_bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::set_repeated_bytes(int index, const void* value, size_t size) {
  _impl_.repeated_bytes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:foo.TestMessageCheck.repeated_bytes)
}
inline std::string* TestMessageCheck::_internal_add_repeated_bytes() {
  return _impl_.repeated_bytes_.Add();
}
inline void TestMessageCheck::add_repeated_bytes(const std::string& value) {
  _impl_.repeated_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::add_repeated_bytes(std::string&& value) {
  _impl_.repeated_bytes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::add_repeated_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.repeated_bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:foo.TestMessageCheck.repeated_bytes)
}
inline void TestMessageCheck::add_repeated_bytes(const void* value, size_t size) {
  _impl_.repeated_bytes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:foo.TestMessageCheck.repeated_bytes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestMessageCheck::repeated_bytes() const {
  // @@protoc_insertion_point(field_list:foo.TestMessageCheck.repeated_bytes)
  return _impl_.repeated_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestMessageCheck::mutable_repeated_bytes() {
  // @@protoc_insertion_point(field_mutable_list:foo.TestMessageCheck.repeated_bytes)
  return &_impl_.repeated_bytes_;
}

// optional bytes optional_bytes = 9;
inline bool TestMessageCheck::_internal_has_optional_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TestMessageCheck::has_optional_bytes() const {
  return _internal_has_optional_bytes();
}
inline void TestMessageCheck::clear_optional_bytes() {
  _impl_.optional_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TestMessageCheck::optional_bytes() const {
  // @@protoc_insertion_point(field_get:foo.TestMessageCheck.optional_bytes)
  return _internal_optional_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestMessageCheck::set_optional_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.optional_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:foo.TestMessageCheck.optional_bytes)
}
inline std::string* TestMessageCheck::mutable_optional_bytes() {
  std::string* _s = _internal_mutable_optional_bytes();
  // @@protoc_insertion_point(field_mutable:foo.TestMessageCheck.optional_bytes)
  return _s;
}
inline const std::string& TestMessageCheck::_internal_optional_bytes() const {
  return _impl_.optional_bytes_.Get();
}
inline void TestMessageCheck::_internal_set_optional_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.optional_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* TestMessageCheck::_internal_mutable_optional_bytes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.optional_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* TestMessageCheck::release_optional_bytes() {
  // @@protoc_insertion_point(field_release:foo.TestMessageCheck.optional_bytes)
  if (!_internal_has_optional_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.optional_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_bytes_.IsDefault()) {
    _impl_.optional_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestMessageCheck::set_allocated_optional_bytes(std::string* optional_bytes) {
  if (optional_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.optional_bytes_.SetAllocated(optional_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.optional_bytes_.IsDefault()) {
    _impl_.optional_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessageCheck.optional_bytes)
}

// -------------------------------------------------------------------

// TestMessSubMess

// required .foo.TestMess rep_mess = 1;
inline bool TestMessSubMess::_internal_has_rep_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rep_mess_ != nullptr);
  return value;
}
inline bool TestMessSubMess::has_rep_mess() const {
  return _internal_has_rep_mess();
}
inline void TestMessSubMess::clear_rep_mess() {
  if (_impl_.rep_mess_ != nullptr) _impl_.rep_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::foo::TestMess& TestMessSubMess::_internal_rep_mess() const {
  const ::foo::TestMess* p = _impl_.rep_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::TestMess&>(
      ::foo::_TestMess_default_instance_);
}
inline const ::foo::TestMess& TestMessSubMess::rep_mess() const {
  // @@protoc_insertion_point(field_get:foo.TestMessSubMess.rep_mess)
  return _internal_rep_mess();
}
inline void TestMessSubMess::unsafe_arena_set_allocated_rep_mess(
    ::foo::TestMess* rep_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rep_mess_);
  }
  _impl_.rep_mess_ = rep_mess;
  if (rep_mess) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessSubMess.rep_mess)
}
inline ::foo::TestMess* TestMessSubMess::release_rep_mess() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::TestMess* temp = _impl_.rep_mess_;
  _impl_.rep_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::TestMess* TestMessSubMess::unsafe_arena_release_rep_mess() {
  // @@protoc_insertion_point(field_release:foo.TestMessSubMess.rep_mess)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::foo::TestMess* temp = _impl_.rep_mess_;
  _impl_.rep_mess_ = nullptr;
  return temp;
}
inline ::foo::TestMess* TestMessSubMess::_internal_mutable_rep_mess() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rep_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::TestMess>(GetArenaForAllocation());
    _impl_.rep_mess_ = p;
  }
  return _impl_.rep_mess_;
}
inline ::foo::TestMess* TestMessSubMess::mutable_rep_mess() {
  ::foo::TestMess* _msg = _internal_mutable_rep_mess();
  // @@protoc_insertion_point(field_mutable:foo.TestMessSubMess.rep_mess)
  return _msg;
}
inline void TestMessSubMess::set_allocated_rep_mess(::foo::TestMess* rep_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rep_mess_;
  }
  if (rep_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rep_mess);
    if (message_arena != submessage_arena) {
      rep_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rep_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rep_mess_ = rep_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessSubMess.rep_mess)
}

// required .foo.TestMessOptional opt_mess = 2;
inline bool TestMessSubMess::_internal_has_opt_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.opt_mess_ != nullptr);
  return value;
}
inline bool TestMessSubMess::has_opt_mess() const {
  return _internal_has_opt_mess();
}
inline void TestMessSubMess::clear_opt_mess() {
  if (_impl_.opt_mess_ != nullptr) _impl_.opt_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::foo::TestMessOptional& TestMessSubMess::_internal_opt_mess() const {
  const ::foo::TestMessOptional* p = _impl_.opt_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::TestMessOptional&>(
      ::foo::_TestMessOptional_default_instance_);
}
inline const ::foo::TestMessOptional& TestMessSubMess::opt_mess() const {
  // @@protoc_insertion_point(field_get:foo.TestMessSubMess.opt_mess)
  return _internal_opt_mess();
}
inline void TestMessSubMess::unsafe_arena_set_allocated_opt_mess(
    ::foo::TestMessOptional* opt_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.opt_mess_);
  }
  _impl_.opt_mess_ = opt_mess;
  if (opt_mess) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessSubMess.opt_mess)
}
inline ::foo::TestMessOptional* TestMessSubMess::release_opt_mess() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foo::TestMessOptional* temp = _impl_.opt_mess_;
  _impl_.opt_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::TestMessOptional* TestMessSubMess::unsafe_arena_release_opt_mess() {
  // @@protoc_insertion_point(field_release:foo.TestMessSubMess.opt_mess)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::foo::TestMessOptional* temp = _impl_.opt_mess_;
  _impl_.opt_mess_ = nullptr;
  return temp;
}
inline ::foo::TestMessOptional* TestMessSubMess::_internal_mutable_opt_mess() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.opt_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::TestMessOptional>(GetArenaForAllocation());
    _impl_.opt_mess_ = p;
  }
  return _impl_.opt_mess_;
}
inline ::foo::TestMessOptional* TestMessSubMess::mutable_opt_mess() {
  ::foo::TestMessOptional* _msg = _internal_mutable_opt_mess();
  // @@protoc_insertion_point(field_mutable:foo.TestMessSubMess.opt_mess)
  return _msg;
}
inline void TestMessSubMess::set_allocated_opt_mess(::foo::TestMessOptional* opt_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.opt_mess_;
  }
  if (opt_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(opt_mess);
    if (message_arena != submessage_arena) {
      opt_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opt_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.opt_mess_ = opt_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessSubMess.opt_mess)
}

// required .foo.TestMessOneof oneof_mess = 3;
inline bool TestMessSubMess::_internal_has_oneof_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.oneof_mess_ != nullptr);
  return value;
}
inline bool TestMessSubMess::has_oneof_mess() const {
  return _internal_has_oneof_mess();
}
inline void TestMessSubMess::clear_oneof_mess() {
  if (_impl_.oneof_mess_ != nullptr) _impl_.oneof_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::foo::TestMessOneof& TestMessSubMess::_internal_oneof_mess() const {
  const ::foo::TestMessOneof* p = _impl_.oneof_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::TestMessOneof&>(
      ::foo::_TestMessOneof_default_instance_);
}
inline const ::foo::TestMessOneof& TestMessSubMess::oneof_mess() const {
  // @@protoc_insertion_point(field_get:foo.TestMessSubMess.oneof_mess)
  return _internal_oneof_mess();
}
inline void TestMessSubMess::unsafe_arena_set_allocated_oneof_mess(
    ::foo::TestMessOneof* oneof_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oneof_mess_);
  }
  _impl_.oneof_mess_ = oneof_mess;
  if (oneof_mess) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessSubMess.oneof_mess)
}
inline ::foo::TestMessOneof* TestMessSubMess::release_oneof_mess() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::foo::TestMessOneof* temp = _impl_.oneof_mess_;
  _impl_.oneof_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::TestMessOneof* TestMessSubMess::unsafe_arena_release_oneof_mess() {
  // @@protoc_insertion_point(field_release:foo.TestMessSubMess.oneof_mess)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::foo::TestMessOneof* temp = _impl_.oneof_mess_;
  _impl_.oneof_mess_ = nullptr;
  return temp;
}
inline ::foo::TestMessOneof* TestMessSubMess::_internal_mutable_oneof_mess() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.oneof_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::TestMessOneof>(GetArenaForAllocation());
    _impl_.oneof_mess_ = p;
  }
  return _impl_.oneof_mess_;
}
inline ::foo::TestMessOneof* TestMessSubMess::mutable_oneof_mess() {
  ::foo::TestMessOneof* _msg = _internal_mutable_oneof_mess();
  // @@protoc_insertion_point(field_mutable:foo.TestMessSubMess.oneof_mess)
  return _msg;
}
inline void TestMessSubMess::set_allocated_oneof_mess(::foo::TestMessOneof* oneof_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.oneof_mess_;
  }
  if (oneof_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oneof_mess);
    if (message_arena != submessage_arena) {
      oneof_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oneof_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.oneof_mess_ = oneof_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessSubMess.oneof_mess)
}

// required .foo.SubMess req_mess = 4;
inline bool TestMessSubMess::_internal_has_req_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.req_mess_ != nullptr);
  return value;
}
inline bool TestMessSubMess::has_req_mess() const {
  return _internal_has_req_mess();
}
inline void TestMessSubMess::clear_req_mess() {
  if (_impl_.req_mess_ != nullptr) _impl_.req_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::foo::SubMess& TestMessSubMess::_internal_req_mess() const {
  const ::foo::SubMess* p = _impl_.req_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::SubMess&>(
      ::foo::_SubMess_default_instance_);
}
inline const ::foo::SubMess& TestMessSubMess::req_mess() const {
  // @@protoc_insertion_point(field_get:foo.TestMessSubMess.req_mess)
  return _internal_req_mess();
}
inline void TestMessSubMess::unsafe_arena_set_allocated_req_mess(
    ::foo::SubMess* req_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.req_mess_);
  }
  _impl_.req_mess_ = req_mess;
  if (req_mess) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessSubMess.req_mess)
}
inline ::foo::SubMess* TestMessSubMess::release_req_mess() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::foo::SubMess* temp = _impl_.req_mess_;
  _impl_.req_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::SubMess* TestMessSubMess::unsafe_arena_release_req_mess() {
  // @@protoc_insertion_point(field_release:foo.TestMessSubMess.req_mess)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::foo::SubMess* temp = _impl_.req_mess_;
  _impl_.req_mess_ = nullptr;
  return temp;
}
inline ::foo::SubMess* TestMessSubMess::_internal_mutable_req_mess() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.req_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::SubMess>(GetArenaForAllocation());
    _impl_.req_mess_ = p;
  }
  return _impl_.req_mess_;
}
inline ::foo::SubMess* TestMessSubMess::mutable_req_mess() {
  ::foo::SubMess* _msg = _internal_mutable_req_mess();
  // @@protoc_insertion_point(field_mutable:foo.TestMessSubMess.req_mess)
  return _msg;
}
inline void TestMessSubMess::set_allocated_req_mess(::foo::SubMess* req_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.req_mess_;
  }
  if (req_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(req_mess);
    if (message_arena != submessage_arena) {
      req_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.req_mess_ = req_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessSubMess.req_mess)
}

// required .foo.DefaultOptionalValues def_mess = 5;
inline bool TestMessSubMess::_internal_has_def_mess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.def_mess_ != nullptr);
  return value;
}
inline bool TestMessSubMess::has_def_mess() const {
  return _internal_has_def_mess();
}
inline void TestMessSubMess::clear_def_mess() {
  if (_impl_.def_mess_ != nullptr) _impl_.def_mess_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::foo::DefaultOptionalValues& TestMessSubMess::_internal_def_mess() const {
  const ::foo::DefaultOptionalValues* p = _impl_.def_mess_;
  return p != nullptr ? *p : reinterpret_cast<const ::foo::DefaultOptionalValues&>(
      ::foo::_DefaultOptionalValues_default_instance_);
}
inline const ::foo::DefaultOptionalValues& TestMessSubMess::def_mess() const {
  // @@protoc_insertion_point(field_get:foo.TestMessSubMess.def_mess)
  return _internal_def_mess();
}
inline void TestMessSubMess::unsafe_arena_set_allocated_def_mess(
    ::foo::DefaultOptionalValues* def_mess) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.def_mess_);
  }
  _impl_.def_mess_ = def_mess;
  if (def_mess) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:foo.TestMessSubMess.def_mess)
}
inline ::foo::DefaultOptionalValues* TestMessSubMess::release_def_mess() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::foo::DefaultOptionalValues* temp = _impl_.def_mess_;
  _impl_.def_mess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::foo::DefaultOptionalValues* TestMessSubMess::unsafe_arena_release_def_mess() {
  // @@protoc_insertion_point(field_release:foo.TestMessSubMess.def_mess)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::foo::DefaultOptionalValues* temp = _impl_.def_mess_;
  _impl_.def_mess_ = nullptr;
  return temp;
}
inline ::foo::DefaultOptionalValues* TestMessSubMess::_internal_mutable_def_mess() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.def_mess_ == nullptr) {
    auto* p = CreateMaybeMessage<::foo::DefaultOptionalValues>(GetArenaForAllocation());
    _impl_.def_mess_ = p;
  }
  return _impl_.def_mess_;
}
inline ::foo::DefaultOptionalValues* TestMessSubMess::mutable_def_mess() {
  ::foo::DefaultOptionalValues* _msg = _internal_mutable_def_mess();
  // @@protoc_insertion_point(field_mutable:foo.TestMessSubMess.def_mess)
  return _msg;
}
inline void TestMessSubMess::set_allocated_def_mess(::foo::DefaultOptionalValues* def_mess) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.def_mess_;
  }
  if (def_mess) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(def_mess);
    if (message_arena != submessage_arena) {
      def_mess = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, def_mess, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.def_mess_ = def_mess;
  // @@protoc_insertion_point(field_set_allocated:foo.TestMessSubMess.def_mess)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace foo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::foo::LowerCase_CaseEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::foo::LowerCase_CaseEnum>() {
  return ::foo::LowerCase_CaseEnum_descriptor();
}
template <> struct is_proto_enum< ::foo::TestEnumSmall> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::foo::TestEnumSmall>() {
  return ::foo::TestEnumSmall_descriptor();
}
template <> struct is_proto_enum< ::foo::TestEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::foo::TestEnum>() {
  return ::foo::TestEnum_descriptor();
}
template <> struct is_proto_enum< ::foo::TestEnumDupValues> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::foo::TestEnumDupValues>() {
  return ::foo::TestEnumDupValues_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_t_2ftest_2dfull_2eproto
